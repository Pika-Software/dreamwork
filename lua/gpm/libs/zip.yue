import gpm, pairs, tostring from _G
import environment from gpm

import await, async, file, FileSystemError from environment

import time from environment.os
import equal from environment.path
import fempty from environment.debug
import match, sub, find, gsub from string
import DecompressDeflate from environment.deflate
import CRC32, ByteStream, MD5 from environment.util
import Addon, IsFilePathAllowed from environment.addon
import AsyncRead, AsyncWrite, MountGMA, NormalizeGamePath from file

-- https://medium.com/@felixstridsberg/the-zip-file-format-6c8a160d1c34
iterateZipFiles = file.IterateZipFiles = ( fileHandle, doCRC ) ->
    unless fileHandle
        return fempty

    doCRC = doCRC == true

    return ->
        if fileHandle\Read( 4 ) ~= "PK\x03\x04"
            return

        data = {}

        fileHandle\Skip( 4 )

        compressionMethod = fileHandle\ReadUShort!

        data.time = fileHandle\ReadUShort!
        data.date = fileHandle\ReadUShort!

        crc32 = fileHandle\ReadULong!
        data.crc = crc32

        compressedSize = fileHandle\ReadULong!
        data.size = fileHandle\ReadULong!

        pathLength = fileHandle\ReadUShort!
        extraLength = fileHandle\ReadUShort!

        data.path = fileHandle\Read( pathLength )
        fileHandle\Skip( extraLength )

        -- TODO: external binary module for other compression methods support

        local content
        switch compressionMethod
            -- Without compression
            when 0
                content = fileHandle\Read( compressedSize )

            -- Deflate compression
            when 8
                content = DecompressDeflate( fileHandle\Read( compressedSize ) )

            else
                error "Unsupported compression method: " .. compressionMethod

        if doCRC and content ~= nil
            result = CRC32( content )
            if tostring( crc32 ) ~= result
                error "CRC-32 mismatch: " .. crc32 .. " != " .. result

        data.content = content
        return data

file.Delete( "gpm/mount" )
file.CreateDir( "gpm/mount", true )

mountZIPData = file.MountZIPData = async ( data, uniqueName ) ->
    gma = Addon!

    local isInFolder, last
    temp = {}

    for data in iterateZipFiles( ByteStream( data ), true )
        filePath = data.path
        temp[ filePath ] = data.content

        if isInFolder ~= false
            current = match( filePath, "^(.-)/" )
            if last
                isInFolder = equal( last, current )

            last = current

    files = temp
    if isInFolder
        files = {}
        endPos = #last + 2
        for fileName, content in pairs( temp )
            files[ sub( fileName, endPos ) ] = content

    for fileName, content in pairs( files )
        if IsFilePathAllowed( fileName )
            filePath = fileName
            if find( filePath, "/lua/packages/", 1, true ) ~= nil
                filePath = gsub( filePath, "/lua/packages/", "/lua/gpm/vfs/packages/" )

            gma\AddFile( filePath, content )

    bs = ByteStream!
    gma\SetTitle( MD5( uniqueName .. time! ) )
    gma\Write( bs, nil, false )

    filePath = "gpm/mount/" .. gma\GetTitle! .. ".gma"
    await AsyncWrite( filePath, bs.Data, "DATA", true )

    ok, result = MountGMA( "/data/" .. filePath )
    unless ok
        error FileSystemError result

    return result

asyncMount = async ( filePath, gamePath ) ->
    return await mountZIPData( await( AsyncRead( filePath, gamePath, true ) ), "file:///" .. filePath )

file.MountZIP = ( filePath, gamePath, skipNormalize ) ->
    unless skipNormalize
        filePath, gamePath = NormalizeGamePath( filePath, gamePath )

    return asyncMount( filePath, gamePath )
