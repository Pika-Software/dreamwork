_G = _G
import environment, Logger from _G.gpm
import file, istable, CLIENT, SERVER, MENU_DLL from _G
import async, await, debug, util, path, string, Promise, CodeCompileError, FileSystemError, error, ArgAssert from environment
import ByteStream, IsBinaryModuleInstalled from util
import byte, sub, len, match, ByteSplit from string
import resolve, getDirectory, getFile from path
import concat from environment.table
import fempty from debug
import Find from file

-- Entropia File System Watcher: https://github.com/Pika-Software/gm_efsw
if SERVER and not _G.efsw and IsBinaryModuleInstalled( "efsw" ) and pcall( require, "efsw" )
    Logger\Info( "gm_efsw is initialized, package auto-reloading are available." )

lib = environment.file

local luaPath
if SERVER
    luaPath = "lsv"
elseif CLIENT
    luaPath = "lcl"
elseif MENU_DLL
    luaPath = "LuaMenu"
else
    luaPath = "LUA"

lib.LuaPath = luaPath

luaExtensions = lib.LuaExtensions = {
    lua: true
    yue: true
    moon: true
}

writeAllowedGamePaths = lib.WriteAllowedGamePaths = {
    "DATA": true
}

assertWriteAllowed = ( filePath, gamePath ) ->
    if writeAllowedGamePaths[ gamePath ] or MENU_DLL
        return nil

    error FileSystemError "File '" .. filePath .. "' is not allowed to be written to '" .. gamePath .. "'.", 3
    return nil

local normalizeGamePath, absoluteGamePath
do

    dir2path = {
        lua: luaPath
        data: "DATA"
        download: "DOWNLOAD"
    }

    normalizeGamePath = lib.NormalizeGamePath = ( absolutePath, gamePath ) ->
        absolutePath = sub( resolve( absolutePath ), 2 )

        if gamePath
            return absolutePath, gamePath

        rootFolder, relativePath = match( absolutePath, "^([^/]+)/?(.*)" )
        if rootFolder
            gamePath = dir2path[ rootFolder ]
            if gamePath
                return relativePath, gamePath

        return absolutePath, "GAME"

    path2dir = {
        DOWNLOAD: "/download"
        LuaMenu: "/lua"
        DATA: "/data"
        LUA: "/lua"
        lsv: "/lua"
        lcl: "/lua"
    }

    absoluteGamePath = lib.AbsoluteGamePath = ( filePath, gamePath, withoutSlash ) ->
        if gamePath
            filePath = ( path2dir[ gamePath ] or "" ) .. "/" .. filePath

        if withoutSlash and byte( filePath, 1 ) == 0x2F --[[ / ]]
            filePath = sub( filePath, 2 )

        return filePath

do

    import Time from file

    lib.Time = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return Time( filePath, gamePath )

lib.Find = ( filePath, gamePath, skipNormalize ) ->
    unless skipNormalize
        filePath, gamePath = normalizeGamePath( filePath, gamePath )

    return Find( filePath, gamePath )

do

    import replaceDir, replaceFile from path
    import Rename from file

    lib.Move = ( pathFrom, pathTo, gamePathFrom, gamePathTo, skipNormalize ) ->
        unless skipNormalize
            pathFrom, gamePathFrom = normalizeGamePath( pathFrom, gamePathFrom )

        assertWriteAllowed( pathFrom, gamePathFrom )

        unless skipNormalize
            pathTo, gamePathTo = normalizeGamePath( pathTo, gamePathTo )

        assertWriteAllowed( pathTo, gamePathTo )

        return Rename( pathFrom, replaceDir( pathFrom, pathTo ), gamePathFrom, gamePathTo )

    --[[

        Usage:

            file.Move( fullPathToFile, newFilePath )
            file.Move( "/data/test.txt", "/data/dir/" )

    ]]

    lib.Rename = ( filePath, newName, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        assertWriteAllowed( filePath, gamePath )

        return Rename( filePath, replaceFile( filePath, newName ), gamePath )

    --[[

        Usage:

            file.Rename( fullPathToFile, newFileName )
            file.Rename( "/data/test.txt", "test2.txt" )

    ]]

luaGamePaths = {
    "LuaMenu": true
    "lsv": true
    "LUA": true
    "lcl": true
}

local isFileMounted, isDirMounted
do

    allowedGamePaths = {
        "LUA": true
        "lsv": true
        "lcl": true
        "GAME": true
        "WORKSHOP": true
        "THIRDPARTY": true
    }

    mountedFiles = lib.MountedFiles = rawget( environment.file, "MountedFiles" ) or {}

    isFileMounted = lib.IsFileMounted = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFiles[ filePath ]

    mountedFolders = lib.MountedFolders = rawget( environment.file, "MountedFolders" ) or {}

    isDirMounted = lib.IsDirMounted = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFolders[ filePath ]

    do

        import MountGMA from environment.game

        lib.MountGMA = ( relativePath ) ->
            success, files = MountGMA( sub( resolve( relativePath ), 2 ) )
            if success
                fileCount = #files
                for index = 1, fileCount
                    filePath = files[ index ]

                    -- mounted files
                    mountedFiles[ filePath ] = true

                    -- mounted folders
                    segments, segmentCount = ByteSplit( getDirectory( filePath, false ), 0x2F --[[ / ]] )
                    segmentCount -= 1

                    while segmentCount ~= 0
                        mountedFolders[ concat( segments, "/", 1, segmentCount ) ] = true
                        segmentCount -= 1

                Logger\Debug( "GMA file '%s' was mounted to GAME with %d files.", relativePath, fileCount )

            return success, files

local isDir, isFile, createDir
do

    import Delete, Exists, IsDir from file

    lib.Exists = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return Exists( filePath, gamePath ) or isFileMounted( filePath, gamePath, true ) or isDirMounted( filePath, gamePath, true )

    isDir = lib.IsDir = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return IsDir( filePath, gamePath ) or isDirMounted( filePath, gamePath, true )

    isFile = lib.IsFile = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return ( Exists( filePath, gamePath ) and not IsDir( filePath, gamePath ) ) or isFileMounted( filePath, gamePath, true )

    do

        delete = ( filePath, gamePath ) ->
            if isDir( filePath, gamePath, true )
                files, folders = Find( filePath .. "/*", gamePath )
                for folderName in *folders
                    delete( filePath .. "/" .. folderName, gamePath )

                for fileName in *files
                    Delete( filePath .. "/" .. fileName, gamePath )

                return Delete( filePath, gamePath )

            return Delete( filePath, gamePath )

        lib.Delete = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            return delete( filePath, gamePath )

    do

        import CreateDir from file

        createDir = lib.CreateDir = ( directoryPath, force, gamePath, skipNormalize ) ->
            unless skipNormalize
                directoryPath, gamePath = normalizeGamePath( directoryPath, gamePath )

            assertWriteAllowed( directoryPath, gamePath )

            if force
                local currentPath
                for folderName in *ByteSplit( directoryPath, 0x2F --[[ / ]] )
                    if folderName
                        if currentPath
                            currentPath ..= "/" .. folderName
                        else
                            currentPath = folderName

                        if isDir( currentPath, gamePath, true )
                            continue

                        Delete( currentPath, gamePath )
                        CreateDir( currentPath, gamePath )

                return currentPath

            CreateDir( directoryPath, gamePath )
            return directoryPath

    do

        import Size from file

        size = ( filePath, gamePath ) ->
            if isDir( filePath, gamePath )
                bytes = 0

                files, folders = Find( filePath .. "/*", gamePath )
                for fileName in *files
                    bytes += Size( filePath .. "/" .. fileName, gamePath )

                for folderName in *folders
                    bytes += size( filePath .. "/" .. folderName, gamePath )

                return bytes

            return Size( filePath, gamePath )

        lib.Size = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            return size( filePath, gamePath )

do

    getFolderContents = ( directoryPath, gamePath, result, length ) ->
        files, folders = Find( directoryPath .. "*", gamePath )
        unless files
            return result, length

        for fileName in *files
            length += 1
            result[ length ] = directoryPath .. fileName

        for folderName in *folders
            result, length = getFolderContents( directoryPath .. folderName .. "/", gamePath, result, length )

        return result, length

    lib.GetFolderContents = ( directoryPath, gamePath, skipNormalize ) ->
        unless skipNormalize
            directoryPath, gamePath = normalizeGamePath( directoryPath, gamePath )

        result, length = {}, 0

        if directoryPath == "" or isDir( directoryPath, gamePath, true )
            if directoryPath ~= ""
                directoryPath ..= "/"

            return getFolderContents( directoryPath, gamePath, result, length )

        return result, length

local append, read, write
do

    local open
    do

        import Open from file

        writeModes = {
            ["a"]: true,
            ["w"]: true,
            ["ab"]: true,
            ["wb"]: true
        }

        open = lib.Open = ( filePath, fileMode, gamePath, skipNormalize ) ->
            unless skipNormalize
                if filePath == "memory" and not gamePath
                    return ByteStream!

                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            if writeModes[ fileMode ]
                directoryPath = getDirectory( filePath, true )
                if directoryPath ~= "" and directoryPath ~= "/"
                    createDir( directoryPath, true, gamePath, true )

            return Open( filePath, fileMode, gamePath )

    File = util.FindMetaTable( "File" )

    do

        import getmetatable from _G

        environment.isfile = ( any ) ->
            return getmetatable( any ) == File

    import Close, Read, Write, EndOfFile from File

    do

        import ReadULong, WriteULong, ReadByte, WriteByte, Seek, Skip, Tell from File

        do

            import tostring from _G

            File.IsValid = ( fileHandle ) ->
                return tostring( fileHandle ) ~= "File [NULL]"

        File.SeekToBegin = ( fileHandle ) ->
            return Seek( fileHandle, 0 )

        do

            import Size from File

            File.SeekToEnd = ( fileHandle ) ->
                return Seek( fileHandle, Size( fileHandle ) )

        File.SkipEmpty = ( fileHandle ) ->
            while not EndOfFile( fileHandle )
                if ReadByte( fileHandle ) ~= 0
                    Skip( fileHandle, -1 )
                    break

        -- String
        File.ReadString = ( fileHandle ) ->
            startPos, length = Tell( fileHandle ), 0
            while not EndOfFile( fileHandle ) and ReadByte( fileHandle ) ~= 0
                length += 1

            Seek( fileHandle, startPos )
            data = Read( fileHandle, length )
            Skip( fileHandle, 1 )
            return data

        File.WriteString = ByteStream.WriteString

        -- Line
        File.WriteLine = ByteStream.WriteLine

        unless File.ReadUInt64
            File.ReadUInt64 = ( fileHandle ) ->
                number = ReadULong( fileHandle )
                Skip( fileHandle, 4 )
                return number

        unless File.WriteUInt64
            File.WriteUInt64 = ( fileHandle, number ) ->
                WriteULong( fileHandle, number )
                WriteULong( fileHandle, 0 )
                return

        File.ReadAll = ( fileHandle ) ->
            Seek( fileHandle, 0 )
            return Read( fileHandle, Size( fileHandle ) )

        -- UnixTime
        File.ReadTime = ByteStream.ReadTime
        File.WriteTime = ByteStream.WriteTime

        -- ZipFile
        File.ReadZipFile = ByteStream.ReadZipFile
        File.WriteZipFile = ByteStream.WriteZipFile

        -- Color
        File.ReadColor = ByteStream.ReadColor
        File.WriteColor = ByteStream.WriteColor

    append = lib.Append = ( filePath, content, gamePath, skipNormalize ) ->
        fileHandle = open( filePath, "ab", gamePath, skipNormalize )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

    read = lib.Read = ( filePath, gamePath, length, skipNormalize ) ->
        fileHandle = open( filePath, "rb", gamePath, skipNormalize )
        if fileHandle
            return Read( fileHandle, length ), Close( fileHandle )

    write = lib.Write = ( filePath, content, gamePath, skipNormalize ) ->
        fileHandle = open( filePath, "wb", gamePath, skipNormalize )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

    do

        import ReadLine from File
        import gsub from string

        readLines = lib.Lines = ( filePath, gamePath, skipNormalize ) ->
            fileHandle = open( filePath, "rb", gamePath, skipNormalize )
            if fileHandle
                lines, length = {}, 0

                while not EndOfFile( fileHandle )
                    length += 1
                    lines[ length ] = ReadLine( fileHandle )

                Close( fileHandle )
                pointer = 0

                return ->
                    pointer += 1
                    return lines[ pointer ], pointer

            return fempty

        import getinfo from debug

        debug.getfcode = ( location ) ->
            info = getinfo( location )
            :linedefined = info
            if linedefined < 0
                return info.source

            :lastlinedefined = info
            lines, length = {}, 0

            for str, line in readLines( gsub( info.source, "^@", "/" ), nil )
                if line >= linedefined
                    length += 1
                    lines[ length ] = str

                if line >= lastlinedefined
                    break

            if length == 0
                return ""

            spaces = match( lines[ 1 ], "^%s+" )
            if spaces
                spLength = len( spaces )
                spLength1 = spLength + 1

                for index = 1, length
                    str = lines[ index ]
                    if sub( str, 1, spLength ) == spaces
                        lines[ index ] = sub( str, spLength1 )

            return concat( lines, "", 1, length )

if SERVER

    import getCurrentFile, stripExtension from path

    -- For future overrides by plugins
    lib.InternalAddCSLuaFile = _G.AddCSLuaFile

    addCSLuaFile = ( filePath, isFolder ) ->
        if byte( filePath, len( filePath ) ) == 0x2f --[[/]]
            filePath = sub( filePath, 1, len( filePath ) - 1 )

        subPath = sub( filePath, 6 )

        if isFolder or isDir( subPath, luaPath, true )
            findFiles, findFolders = Find( subPath .. "/*", luaPath )

            foldersCount = #findFolders
            filesCount = #findFiles

            if foldersCount == 0 and filesCount == 0
                error CodeCompileError "Couldn't AddCSLuaFile directory '" .. filePath .. "/' - Directory is empty", 3

            for index = 1, foldersCount
                addCSLuaFile( filePath .. "/" .. findFolders[ index ], true )

            files, length = {}, 0

            for index = 1, filesCount
                fileName, extension = stripExtension( findFiles[ index ] )

                isValidFile = luaExtensions[ extension ]
                if isValidFile
                    for j = length, 1, -1
                        if files[ j ][ 1 ] == fileName
                            isValidFile = false
                            break

                if isValidFile
                    length += 1
                    files[ length ] = { fileName, extension }

            for fileName in *files
                addCSLuaFile( filePath .. "/" .. fileName[ 1 ] .. "." .. fileName[ 2 ], false )

            return nil

        if isFolder == nil and not isFile( subPath, luaPath, true )
            error CodeCompileError "Couldn't AddCSLuaFile file '" .. filePath .. "' - File not found", 3

        lib.InternalAddCSLuaFile( subPath )
        return nil

    lib.AddCSLuaFile = ( filePath ) ->
        if not filePath or filePath == ""
            filePath = getFile( getCurrentFile! )

        filePath = resolve( filePath )

        if sub( filePath, 1, 4 ) ~= "/lua"
            error CodeCompileError "Couldn't AddCSLuaFile file '" .. filePath .. "' - Invalid path", 2

        addCSLuaFile( filePath )
        return nil

import efsw from _G

if istable( efsw )
    import Watch, Unwatch from efsw

    observedFiles = lib.ObservedFiles = rawget( environment.file, "ObservedFiles" ) or {}

    hashIdentifier = ( filePath, gamePath ) ->
        return gamePath .. ":///" .. filePath

    watch = lib.Watch = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        identifier = hashIdentifier( filePath, gamePath )

        if observedFiles[ identifier ]
            return false

        observedFiles[ identifier ] = Watch( filePath, gamePath )

        if isDir( filePath, gamePath, true )
            filePath ..= "/"

            files, folders = Find( filePath .. "*", gamePath )
            for fileName in *files
                watch( filePath .. fileName, gamePath )

            for folderName in *folders
                watch( filePath .. folderName, gamePath )

        return true

    unWatch = lib.UnWatch = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        identifier = hashIdentifier( filePath, gamePath )

        watchID = observedFiles[ identifier ]
        unless watchID
            return false

        observedFiles[ identifier ] = nil
        Unwatch( watchID )

        if isDir( filePath, gamePath, true )
            filePath ..= "/"

            files, folders = Find( filePath .. "*", gamePath )
            for fileName in *files
                unWatch( filePath .. fileName, gamePath )

            for folderName in *folders
                unWatch( filePath .. folderName, gamePath )

        return true

else

    lib.Watch = fempty
    lib.Unwatch = fempty

local asyncRead
do

    functions = {
        { "Append", false },
        { "Write", false },
        { "Read", false }
    }

    do

        sources = {
            {
                "Name": "gm_asyncio"
                "Fetch": -> IsBinaryModuleInstalled( "asyncio" )
                "Install": ->
                    require( "asyncio" )

                    return {
                        "Append": asyncio.AsyncAppend
                        "Read": asyncio.AsyncRead
                        "Write": asyncio.AsyncWrite
                    }
            },
            {
                "Name": "async_write"
                "Fetch": -> IsBinaryModuleInstalled( "async_write" )
                "Install": ->
                    require( "async_write" )

                    return {
                        "Append": file.AsyncAppen
                        "Write": file.AsyncWrite
                    }
            },
            {
                "Name": "Garry's Mod Async"
                "Fetch": -> not MENU_DLL
                "Install": ->
                    return {
                        "Read": file.AsyncRead
                    }
            },
            {
                "Name": "Garry's Mod"
                "Install": ->
                    return {
                        "Read": ( fileName, gamePath, func ) ->
                            content = read( fileName, gamePath, nil, true )
                            state = content == nil and -1 or 0
                            func( fileName, gamePath, state, content )
                            return state

                        "Append": ( fileName, content, gamePath, func ) ->
                            state = append( fileName, content, gamePath, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state

                        "Write": ( fileName, content, gamePath, func ) ->
                            state = write( fileName, content, gamePath, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                    }
            }
        }

        functionsNeed = #functions

        for source in *sources
            if not source.Fetch or source.Fetch!
                result = source.Install!

                installed = 0
                for data in *functions
                    if data[ 2 ]
                        continue

                    name = data[ 1 ]
                    unless result[ name ]
                        continue

                    functions[ name ] = result[ name ]
                    functionsNeed -= 1
                    data[ 2 ] = true
                    installed += 1

                if installed > 0
                    Logger\Info( "'%s' was connected as filesystem API.", source.Name )

                if functionsNeed < 1
                    break

    FSASYNC = lib.FSASYNC = {
        [ -8 ]: "Filename not part of the specified file system, try a different one."
        [ -7 ]: "Failure for a reason that might be temporary, you might retry, but not immediately."
        [ -6 ]: "Read parameters invalid for unbuffered IO."
        [ -5 ]: "Hard subsystem failure."
        [ -4 ]: "Read error on file."
        [ -3 ]: "Out of memory for file read."
        [ -2 ]: "Caller's provided id is not recognized."
        [ -1 ]: "Filename could not be opened (bad path, not exist, etc)."
        [  0 ]: "Operation is successful."
        [  1 ]: "File is properly queued, waiting for service."
        [  2 ]: "File is being accessed."
        [  3 ]: "File was aborted by caller."
        [  4 ]: "File is not yet queued."
    }

    do

        import Append from functions

        lib.AsyncAppend = ( filePath, content, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            promise = Promise!

            state = Append( filePath, content, ( iFilePath, iGamePath, iState ) ->
                if iState == 0
                    promise\Resolve( absoluteGamePath( iFilePath, iGamePath ) )
                    return nil

                promise\Reject( FileSystemError FSASYNC[ iState ] )
                return nil
            gamePath )

            if state ~= 0
                promise\Reject( FileSystemError FSASYNC[ state ] )

            return promise

    do

        import Read from functions

        asyncRead = lib.AsyncRead = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            promise = Promise!

            state = Read filePath, gamePath, ( _, __, iState, iContent ) ->
                if iState == 0
                    promise\Resolve( iContent )
                    return nil

                promise\Reject( FileSystemError FSASYNC[ iState ] )
                return nil

            if state ~= 0
                promise\Reject( FileSystemError FSASYNC[ state ] )

            return promise

    do

        import Write from functions

        lib.AsyncWrite = ( filePath, content, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            directoryPath = getDirectory( filePath, true )
            if directoryPath ~= "" and directoryPath ~= "/"
                createDir( directoryPath, true, gamePath, true )

            promise = Promise!

            state = Write( filePath, content, ( iFilePath, iGamePath, iState ) ->
                if iState == 0
                    promise\Resolve( absoluteGamePath( iFilePath, iGamePath ) )
                    return nil

                promise\Reject( FileSystemError FSASYNC[ iState ] )
                return nil

            gamePath )

            if state ~= 0
                promise\Reject( FileSystemError FSASYNC[ state ] )

            return promise

do

    func = async ( promise ) ->
        lines, pointer = ByteSplit( await( promise ), 0xa --[[ \n ]] ), 0
        return ->
            pointer += 1
            return lines[ pointer ], pointer

    lib.AsyncLines = ( filePath, gamePath, skipNormalize ) ->
        return func( asyncRead( filePath, gamePath, skipNormalize ) )

do

    import load from environment
    import Open from file

    asyncCompile = async ( filePath, mode, env, config, gamePath ) ->
        return load( await( asyncRead( filePath, gamePath, true ) ), absoluteGamePath( filePath, gamePath ), mode, env, config )

    lib.AsyncCompile = ( filePath, mode, env, config, gamePath, skipNormalize ) ->
        ArgAssert( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        if CLIENT and isFileMounted( filePath, gamePath, true )
            if luaGamePaths[ gamePath ]
                filePath = "lua/" .. filePath

            gamePath = "WORKSHOP"

        return asyncCompile( filePath, mode, env, config, gamePath )

    lib.Compile = environment.loadfile = ( filePath, mode, env, config, gamePath, skipNormalize ) ->
        ArgAssert( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        if CLIENT and isFileMounted( filePath, gamePath, true )
            if luaGamePaths[ gamePath ]
                filePath = "lua/" .. filePath

            gamePath = "WORKSHOP"

        return load( read( filePath, gamePath, nil, true ), absoluteGamePath( filePath, gamePath ), mode, env, config )

do

    addon = environment.addon = include( "addon.lua" )
    import File, IsFilePathAllowed from addon
    import equal from path
    import pairs from _G

    do

        import Read from lib

        lib.Get = ( filePath ) ->
            if istable( filePath )
                result = {}
                for index = 1, #filePath
                    fileName = filePath[ index ]
                    ArgAssert( fileName, 1, "string" )
                    result[ fileName ] = Read( fileName, nil, nil, false )

                return result

            ArgAssert( filePath, 1, "string" )

            result = {}
            result[ filePath ] = Read( filePath, nil, nil, false )
            return result

    lib.Set = ( filePath, content ) ->
        if istable( filePath )
            title, length = {}, 0

            f = File!
            for fileName, fileContent in pairs( filePath )
                ArgAssert( fileName, 1, "string" )
                ArgAssert( fileContent, 2, "string" )

                if len( fileContent ) == 0
                    error FileSystemError "File '" .. fileName .. "' cannot be empty.", 2

                subPath = fileName
                if byte( subPath, 1 ) == 0x2f --[[/]]
                    subPath = sub( subPath, 2 )

                unless IsFilePathAllowed( subPath )
                    error FileSystemError "File '" .. subPath .. "' cannot be written.", 2

                f\SetFile( subPath, fileContent, false )

                length += 1
                title[ length ] = fileName

            f\SetTitle( concat( title, ";", 1, length ) )
            return f\Mount( false )

        ArgAssert( filePath, 1, "string" )
        ArgAssert( content, 2, "string" )

        if len( content ) == 0
            error FileSystemError "File '" .. filePath .. "' cannot be empty.", 2

        if byte( filePath, 1 ) == 0x2f --[[/]]
            filePath = sub( filePath, 2 )

        unless IsFilePathAllowed( filePath )
            error FileSystemError "File '" .. filePath .. "' cannot be written.", 2

        f = File!
        f\SetTitle( filePath )
        f\SetFile( filePath, content, false )
        return f\Mount( false )

    iterateZipFiles = lib.IterateZipFiles = ( fileHandle, doCRC ) ->
        unless fileHandle
            return fempty

        doCRC = doCRC ~= false

        return ->
            return fileHandle\ReadZipFile( doCRC )

    lib.MountGMAData = async ( data, uniqueName, verifyCRC ) ->
        f = File( data, false )

        if verifyCRC and not f\VerifyCRC!
            error FileSystemError "Invalid CRC checksum for '" .. f\GetTitle! .. "'"

        if uniqueName
            f\SetTitle( uniqueName )

        return f\AsyncMount( false )

    mountZIPData = lib.MountZIPData = async ( data, uniqueName ) ->
        f = File!
        f\SetTitle( uniqueName )

        local isInFolder, last
        temp = {}

        for data in iterateZipFiles( ByteStream( data ), true )
            :content = data
            if content and content ~= ""
                filePath = data.path
                temp[ filePath ] = content

                if isInFolder ~= false
                    current = match( filePath, "^(.-)/" )
                    if last
                        isInFolder = equal( last, current )

                    last = current

        files = temp
        if isInFolder
            files = {}
            endPos = #last + 2
            for fileName, content in pairs( temp )
                files[ sub( fileName, endPos ) ] = content

        for filePath, content in pairs( files )
            if IsFilePathAllowed( filePath )
                f\SetFile( filePath, content )

        return f\AsyncMount( false )

    asyncMount = async ( filePath, gamePath ) ->
        return await mountZIPData( await( asyncRead( filePath, gamePath, true ) ), "file:///" .. filePath )

    lib.MountZIP = ( filePath, gamePath, skipNormalize ) ->
        ArgAssert( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return asyncMount( filePath, gamePath )
