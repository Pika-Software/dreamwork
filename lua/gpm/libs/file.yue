_G = _G
import environment, Logger, sql from _G.gpm
import file, istable, CLIENT, SERVER, MENU_DLL from _G
import async, await, debug, util, path, string, Future, CodeCompileError, FileSystemError, error, argument, tostring from environment
import ByteStream, IsBinaryModuleInstalled, SHA256 from util
import byte, sub, len, match, ByteSplit from string
import resolve, getDirectory, getFile, getCurrentDirectory from path
import concat, Add from environment.table
import Find, Exists, IsDir from file
import get, save from sql.files
import fempty from debug

-- Entropia File System Watcher: https://github.com/Pika-Software/gm_efsw
if SERVER and not _G.efsw and IsBinaryModuleInstalled( "efsw" ) and pcall( require, "efsw" )
    Logger\Info( "gm_efsw is initialized, package auto-reloading are available." )

lib = environment.file

local luaPath
if SERVER
    luaPath = "lsv"
elseif CLIENT
    luaPath = "lcl"
elseif MENU_DLL
    luaPath = "LuaMenu"
else
    luaPath = "LUA"

lib.LuaPath = luaPath

luaGamePaths = lib.LuaGamePaths = {
    "LuaMenu": true
    "lsv": true
    "LUA": true
    "lcl": true
}

luaExtensions = lib.LuaExtensions = {
    lua: true
    yue: true
    moon: true
}

writeAllowedGamePaths = lib.WriteAllowedGamePaths = {
    "DATA": true
}

assertWriteAllowed = ( filePath, gamePath ) ->
    if writeAllowedGamePaths[ gamePath ] or MENU_DLL
        return nil

    error FileSystemError "File '#{filePath}' is not allowed to be written to '#{gamePath}'.", 3
    return nil

local normalizeGamePath, absoluteGamePath
do

    import isurl from environment

    dir2path = {
        lua: luaPath
        data: "DATA"
        download: "DOWNLOAD"
    }

    normalizeGamePath = lib.NormalizeGamePath = ( absolutePath, gamePath ) ->
        if not gamePath and isurl( absolutePath )
            if absolutePath.scheme ~= "file"
                error FileSystemError "Cannot resolve URL '#{absolutePath}' because it is not a file URL."

            absolutePath = absolutePath.pathname

        firstByte = byte( absolutePath )
        if firstByte == 0x2F --[[ / ]]
            absolutePath = sub( absolutePath, 2 ) -- resolve it?
            if gamePath
                return absolutePath, gamePath

        elseif firstByte == 0x2E --[[ . ]]
            secondByte = byte( absolutePath, 2 )

            if secondByte == 0x2F --[[ / ]] or (secondByte == 0x2E --[[ . ]] and byte( absolutePath, 3 ) == 0x2F --[[ / ]])
                currentDir = sub( getCurrentDirectory(), 5 ) -- remove /lua from the beginning
                if currentDir == ""
                    error FileSystemError "Cannot resolve relative path '#{absolutePath}' because main file is unknown."

                absolutePath = sub( resolve( currentDir .. absolutePath ), 2 )
                gamePath = luaPath

        unless gamePath
            for index = 1, len( absolutePath )
                if byte( absolutePath, index ) == 0x2F --[[ / ]]
                    rootDir = sub( absolutePath, 1, index - 1 )
                    gamePath = dir2path[ rootDir ]
                    if gamePath
                        absolutePath = sub( absolutePath, index + 1 )

                    break

        return absolutePath, gamePath or "GAME"

    path2dir = {
        DOWNLOAD: "/download"
        LuaMenu: "/lua"
        DATA: "/data"
        LUA: "/lua"
        lsv: "/lua"
        lcl: "/lua"
    }

    absoluteGamePath = lib.AbsoluteGamePath = ( filePath, gamePath, withoutSlash ) ->
        if gamePath
            filePath = ( path2dir[ gamePath ] or "" ) .. "/" .. filePath

        if withoutSlash and byte( filePath, 1 ) == 0x2F --[[ / ]]
            filePath = sub( filePath, 2 )

        return filePath

do

    import Time from file

    lib.Time = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return Time( filePath, gamePath )

lib.Find = ( filePath, gamePath, skipNormalize ) ->
    unless skipNormalize
        filePath, gamePath = normalizeGamePath( filePath, gamePath )

    files, dirs = Find( filePath, gamePath )
    if CLIENT and luaGamePaths[ gamePath ]
        files2, dirs2 = Find( "lua/" .. filePath, "WORKSHOP" )
        return Add( files, files2, true ), Add( dirs, dirs2, true )

    return files, dirs

do

    import replaceDir, replaceFile from path
    import Rename from file

    lib.Move = ( pathFrom, pathTo, gamePathFrom, gamePathTo, skipNormalize ) ->
        unless skipNormalize
            pathFrom, gamePathFrom = normalizeGamePath( pathFrom, gamePathFrom )

        assertWriteAllowed( pathFrom, gamePathFrom )

        unless skipNormalize
            pathTo, gamePathTo = normalizeGamePath( pathTo, gamePathTo )

        assertWriteAllowed( pathTo, gamePathTo )

        return Rename( pathFrom, replaceDir( pathFrom, pathTo ), gamePathFrom, gamePathTo )

    --[[

        Usage:

            file.Move( fullPathToFile, newFilePath )
            file.Move( "/data/test.txt", "/data/dir/" )

    ]]

    lib.Rename = ( filePath, newName, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        assertWriteAllowed( filePath, gamePath )

        return Rename( filePath, replaceFile( filePath, newName ), gamePath )

    --[[

        Usage:

            file.Rename( fullPathToFile, newFileName )
            file.Rename( "/data/test.txt", "test2.txt" )

    ]]

local isFileMounted, isDirMounted
do

    allowedGamePaths = {
        "LUA": true
        "lsv": true
        "lcl": true
        "GAME": true
        "WORKSHOP": true
        "THIRDPARTY": true
    }

    mountedFiles = lib.MountedFiles = rawget( environment.file, "MountedFiles" ) or {}

    isFileMounted = lib.IsFileMounted = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFiles[ filePath ]

    mountedFolders = lib.MountedFolders = rawget( environment.file, "MountedFolders" ) or {}

    isDirMounted = lib.IsDirMounted = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFolders[ filePath ]

    do

        import MountGMA from environment.game

        lib.MountGMA = ( relativePath ) ->
            success, files = MountGMA( sub( resolve( relativePath ), 2 ) )
            if success
                fileCount = #files
                for index = 1, fileCount
                    filePath = files[ index ]

                    -- mounted files
                    mountedFiles[ filePath ] = true

                    -- mounted dirs
                    segments, segmentCount = ByteSplit( getDirectory( filePath, false ), 0x2F --[[ / ]] )
                    segmentCount -= 1

                    while segmentCount ~= 0
                        mountedFolders[ concat( segments, "/", 1, segmentCount ) ] = true
                        segmentCount -= 1

                Logger\Debug( "GMA file '%s' was mounted to GAME with %d files.", relativePath, fileCount )

            return success, files

local isDir, isFile, createDir
do

    import Delete from file

    lib.Exists = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return ( isFileMounted( filePath, gamePath, true ) or isDirMounted( filePath, gamePath, true ) ) or Exists( filePath, gamePath ) or ( CLIENT and luaGamePaths[ gamePath ] and Exists( "lua/" .. filePath, "WORKSHOP" ) )

    isDir = lib.IsDir = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return isDirMounted( filePath, gamePath, true ) or IsDir( filePath, gamePath ) or ( CLIENT and luaGamePaths[ gamePath ] and IsDir( "lua/" .. filePath, "WORKSHOP" ) )

    isFile = lib.IsFile = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        if isFileMounted( filePath, gamePath, true )
            return true

        if isDirMounted( filePath, gamePath, true )
            return false

        if Exists( filePath, gamePath )
            if IsDir( filePath, gamePath )
                return false

            return true

        if CLIENT and luaGamePaths[ gamePath ] and Exists( "lua/" .. filePath, "WORKSHOP" )
            if IsDir( "lua/" .. filePath, "WORKSHOP" )
                return false

            return true

        return false

    do

        delete = ( filePath, gamePath ) ->
            basePath = getDirectory( filePath, true )
            files, dirs = Find( filePath, gamePath )
            searchable = getFile( filePath )
            successful = true

            for fileName in *files
                unless Delete( basePath .. fileName, gamePath )
                    successful = false

            for directoryName in *dirs
                directoryPath = basePath .. directoryName
                if directoryPath == filePath
                    unless delete( directoryPath .. "/*", gamePath )
                        successful = false

                elseif not delete( directoryPath .. "/" .. searchable, gamePath )
                    successful = false

                unless Delete( directoryPath, gamePath )
                    successful = false

            return successful

        lib.Delete = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            return delete( filePath, gamePath )

    do

        import CreateDir from file

        createDir = lib.CreateDir = ( directoryPath, force, gamePath, skipNormalize ) ->
            unless skipNormalize
                directoryPath, gamePath = normalizeGamePath( directoryPath, gamePath )

            assertWriteAllowed( directoryPath, gamePath )

            if force
                local currentPath
                for directoryName in *ByteSplit( directoryPath, 0x2F --[[ / ]] )
                    if directoryName
                        if currentPath
                            currentPath ..= "/" .. directoryName
                        else
                            currentPath = directoryName

                        if isDir( currentPath, gamePath, true )
                            continue

                        Delete( currentPath, gamePath )
                        CreateDir( currentPath, gamePath )

                return currentPath

            CreateDir( directoryPath, gamePath )
            return directoryPath

    do

        import Size from file

        size = ( filePath, gamePath ) ->
            if isDir( filePath, gamePath )
                bytes = 0

                files, dirs = Find( filePath .. "/*", gamePath )
                for fileName in *files
                    bytes += Size( filePath .. "/" .. fileName, gamePath )

                for directoryName in *dirs
                    bytes += size( filePath .. "/" .. directoryName, gamePath )

                return bytes

            return Size( filePath, gamePath )

        lib.Size = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            return size( filePath, gamePath )

do

    getFolderContents = ( directoryPath, gamePath, result, length ) ->
        files, dirs = Find( directoryPath .. "*", gamePath )
        unless files
            return result, length

        for fileName in *files
            length += 1
            result[ length ] = directoryPath .. fileName

        for directoryName in *dirs
            result, length = getFolderContents( directoryPath .. directoryName .. "/", gamePath, result, length )

        return result, length

    lib.GetFolderContents = ( directoryPath, gamePath, skipNormalize ) ->
        unless skipNormalize
            directoryPath, gamePath = normalizeGamePath( directoryPath, gamePath )

        result, length = {}, 0

        if directoryPath == "" or isDir( directoryPath, gamePath, true )
            if directoryPath ~= ""
                directoryPath ..= "/"

            return getFolderContents( directoryPath, gamePath, result, length )

        return result, length

local append, read, write
do

    legacy = util.FindMetaTable( "File" )
    base = {}

    do

        import getmetatable from _G

        environment.isfile = ( any ) ->
            metatable = getmetatable( any )
            return metatable == base or metatable == legacy

    local fileClass
    do

        import setmetatable from debug
        newClass = environment.class
        import Open from file

        writeModes = {
            ["a"]: true,
            ["w"]: true,
            ["ab"]: true,
            ["wb"]: true
        }

        legacy.new = ( filePath, fileMode, gamePath, skipNormalize ) =>
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            if writeModes[ fileMode ]
                directoryPath = getDirectory( filePath, true )
                if directoryPath ~= "" and directoryPath ~= "/"
                    createDir( directoryPath, true, gamePath, true )

            cls = Open( filePath, fileMode, gamePath )
            if cls
                setmetatable( cls, @.__class.__base )
                return true, cls

            return true, nil

        fileLegacyClass = newClass( "File: Legacy", legacy )
        util.FileLegacy = fileLegacyClass

        fileClass = newClass( "File", base, nil, fileLegacyClass )
        util.File = fileClass

        lib.Open = ( filePath, fileMode, gamePath, skipNormalize ) ->
            return fileClass( filePath, fileMode, gamePath, skipNormalize )

    import Close, Read, Write, EndOfFile from legacy

    do

        import ReadULong, WriteULong, ReadByte, WriteByte, Seek, Skip, Tell from legacy

        base.IsValid = ( fileHandle ) ->
            return tostring( fileHandle ) ~= "File [NULL]"

        base.SeekToBegin = ( fileHandle ) ->
            return Seek( fileHandle, 0 )

        do

            import Size from legacy

            base.SeekToEnd = ( fileHandle ) ->
                return Seek( fileHandle, Size( fileHandle ) )

        base.SkipEmpty = ( fileHandle ) ->
            while not EndOfFile( fileHandle )
                if ReadByte( fileHandle ) ~= 0
                    Skip( fileHandle, -1 )
                    break

        -- String
        base.ReadString = ( fileHandle ) ->
            startPos, length = Tell( fileHandle ), 0
            while not EndOfFile( fileHandle ) and ReadByte( fileHandle ) ~= 0
                length += 1

            Seek( fileHandle, startPos )
            data = Read( fileHandle, length )
            Skip( fileHandle, 1 )
            return data

        base.WriteString = ByteStream.WriteString

        -- Line
        base.WriteLine = ByteStream.WriteLine

        unless base.ReadUInt64
            base.ReadUInt64 = ( fileHandle ) ->
                number = ReadULong( fileHandle )
                Skip( fileHandle, 4 )
                return number

        unless base.WriteUInt64
            base.WriteUInt64 = ( fileHandle, number ) ->
                WriteULong( fileHandle, number )
                WriteULong( fileHandle, 0 )
                return

        base.ReadAll = ( fileHandle ) ->
            Seek( fileHandle, 0 )
            return Read( fileHandle, Size( fileHandle ) )

        -- UnixTime
        base.ReadTime = ByteStream.ReadTime
        base.WriteTime = ByteStream.WriteTime

        -- ZipFile
        base.ReadZipFile = ByteStream.ReadZipFile
        base.WriteZipFile = ByteStream.WriteZipFile

        -- Color
        base.ReadColor = ByteStream.ReadColor
        base.WriteColor = ByteStream.WriteColor

        -- Date
        base.ReadDate = ByteStream.ReadDate
        base.WriteDate = ByteStream.WriteDate

    append = lib.Append = ( filePath, content, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        assertWriteAllowed( filePath, gamePath )

        fileHandle = fileClass( filePath, "ab", gamePath, true )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

    read = lib.Read = ( filePath, gamePath, length, skipNormalize, verifyHash ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        if CLIENT and luaGamePaths[ gamePath ] and not ( Exists( filePath, gamePath ) and not IsDir( filePath, gamePath ) )
            filePath, gamePath = "lua/" .. filePath, "WORKSHOP"

        fileHandle = fileClass( filePath, "rb", gamePath, true )
        if fileHandle
            content = Read( fileHandle, length )
            Close( fileHandle )

            if verifyHash
                cache = get( absoluteGamePath( filePath, gamePath, false ) )
                unless cache and ( not cache.hash or cache.hash == SHA256( content ) ) and cache.size == len( content )
                    return nil

            return content

    write = lib.Write = ( filePath, content, gamePath, skipNormalize, saveHash ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        assertWriteAllowed( filePath, gamePath )

        fileHandle = fileClass( filePath, "wb", gamePath, true )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )

            if saveHash
                save( absoluteGamePath( filePath, gamePath, false ), len( content ), nil, SHA256( content ) )

            return true

        return false

    do

        import ReadLine from legacy
        import gsub from string

        readLines = lib.Lines = ( filePath, gamePath, skipNormalize ) ->
            fileHandle = fileClass( filePath, "rb", gamePath, skipNormalize )
            if fileHandle
                lines, length = {}, 0

                while not EndOfFile( fileHandle )
                    length += 1
                    lines[ length ] = ReadLine( fileHandle )

                Close( fileHandle )
                pointer = 0

                return ->
                    pointer += 1
                    return lines[ pointer ], pointer

            return fempty

        import getinfo from debug

        debug.getfcode = ( location ) ->
            info = getinfo( location )
            :linedefined = info
            if linedefined < 0
                return info.source

            :lastlinedefined = info
            lines, length = {}, 0

            for str, line in readLines( gsub( info.source, "^@", "/" ), nil )
                if line >= linedefined
                    length += 1
                    lines[ length ] = str

                if line >= lastlinedefined
                    break

            if length == 0
                return ""

            spaces = match( lines[ 1 ], "^%s+" )
            if spaces
                spLength = len( spaces )
                spLength1 = spLength + 1

                for index = 1, length
                    str = lines[ index ]
                    if sub( str, 1, spLength ) == spaces
                        lines[ index ] = sub( str, spLength1 )

            return concat( lines, "", 1, length )

import efsw from _G

if istable( efsw )
    import Watch, Unwatch from efsw

    observedFiles = lib.ObservedFiles = rawget( environment.file, "ObservedFiles" ) or {}

    hashIdentifier = ( filePath, gamePath ) ->
        return gamePath .. ":///" .. filePath

    watch = lib.Watch = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        identifier = hashIdentifier( filePath, gamePath )

        if observedFiles[ identifier ]
            return false

        observedFiles[ identifier ] = Watch( filePath, gamePath )

        if isDir( filePath, gamePath, true )
            filePath ..= "/"

            files, dirs = Find( filePath .. "*", gamePath )
            for fileName in *files
                watch( filePath .. fileName, gamePath )

            for directoryName in *dirs
                watch( filePath .. directoryName, gamePath )

        return true

    unWatch = lib.UnWatch = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        identifier = hashIdentifier( filePath, gamePath )

        watchID = observedFiles[ identifier ]
        unless watchID
            return false

        observedFiles[ identifier ] = nil
        Unwatch( watchID )

        if isDir( filePath, gamePath, true )
            filePath ..= "/"

            files, dirs = Find( filePath .. "*", gamePath )
            for fileName in *files
                unWatch( filePath .. fileName, gamePath )

            for directoryName in *dirs
                unWatch( filePath .. directoryName, gamePath )

        return true

else

    lib.Watch = fempty
    lib.Unwatch = fempty

local asyncRead
do

    import captureStack, appendStack, popCallStack, pushCallStack from FileSystemError

    functions = {
        { "Append", false },
        { "Write", false },
        { "Read", false }
    }

    do

        sources = {
            {
                "Name": "gm_asyncio"
                "Fetch": -> IsBinaryModuleInstalled( "asyncio" )
                "Install": ->
                    require( "asyncio" )

                    return {
                        "Append": asyncio.AsyncAppend
                        "Read": asyncio.AsyncRead
                        "Write": asyncio.AsyncWrite
                    }
            },
            {
                "Name": "async_write"
                "Fetch": -> IsBinaryModuleInstalled( "async_write" )
                "Install": ->
                    require( "async_write" )

                    return {
                        "Append": file.AsyncAppen
                        "Write": file.AsyncWrite
                    }
            },
            {
                "Name": "Garry's Mod Async"
                "Fetch": -> not MENU_DLL
                "Install": ->
                    return {
                        "Read": file.AsyncRead
                    }
            },
            {
                "Name": "Garry's Mod"
                "Install": ->
                    return {
                        "Read": ( fileName, gamePath, func ) ->
                            content = read( fileName, gamePath, nil, true, false )
                            state = content == nil and -1 or 0
                            func( fileName, gamePath, state, content )
                            return state

                        "Append": ( fileName, content, gamePath, func ) ->
                            state = append( fileName, content, gamePath, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state

                        "Write": ( fileName, content, gamePath, func ) ->
                            state = write( fileName, content, gamePath, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                    }
            }
        }

        functionsNeed = #functions

        for source in *sources
            if not source.Fetch or source.Fetch!
                result = source.Install!

                installed = 0
                for data in *functions
                    if data[ 2 ]
                        continue

                    name = data[ 1 ]
                    unless result[ name ]
                        continue

                    functions[ name ] = result[ name ]
                    functionsNeed -= 1
                    data[ 2 ] = true
                    installed += 1

                if installed > 0
                    Logger\Info( "'%s' was connected as filesystem API.", source.Name )

                if functionsNeed < 1
                    break

    FSASYNC = lib.FSASYNC = {
        [ -8 ]: "Filename not part of the specified file system, try a different one."
        [ -7 ]: "Failure for a reason that might be temporary, you might retry, but not immediately."
        [ -6 ]: "Read parameters invalid for unbuffered IO."
        [ -5 ]: "Hard subsystem failure."
        [ -4 ]: "Read error on file."
        [ -3 ]: "Out of memory for file read."
        [ -2 ]: "Caller's provided id is not recognized."
        [ -1 ]: "Filename could not be opened (bad path, not exist, etc)."
        [  0 ]: "Operation is successful."
        [  1 ]: "File is properly queued, waiting for service."
        [  2 ]: "File is being accessed."
        [  3 ]: "File was aborted by caller."
        [  4 ]: "File is not yet queued."
    }

    do

        import Append from functions

        lib.AsyncAppend = ( filePath, content, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            fut = Future!

            appendStack( captureStack() )
            stack = popCallStack()

            state = Append( filePath, content, ( iFilePath, iGamePath, iState ) ->
                if iState == 0
                    fut\setResult( absoluteGamePath( iFilePath, iGamePath, false ) )
                    return nil

                pushCallStack( stack )
                fut\setError( FileSystemError FSASYNC[ iState ] )
                popCallStack()
                return nil
            gamePath )

            if state ~= 0
                fut\setError( FileSystemError FSASYNC[ state ] )

            return fut

    do

        import Read from functions

        asyncRead = lib.AsyncRead = ( filePath, gamePath, skipNormalize, verifyHash ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            if CLIENT and luaGamePaths[ gamePath ] and not ( Exists( filePath, gamePath ) and not IsDir( filePath, gamePath ) )
                filePath, gamePath = "lua/" .. filePath, "WORKSHOP"

            fut = Future!

            appendStack( captureStack() )
            stack = popCallStack()

            state = Read filePath, gamePath, ( _, __, iState, iContent ) ->
                if iState == 0
                    if verifyHash
                        cache = get( absoluteGamePath( filePath, gamePath, false ) )
                        unless cache and ( not cache.hash or cache.hash == SHA256( iContent ) ) and cache.size == len( iContent )
                            fut\setError( FileSystemError "File hash mismatch for '" .. absoluteGamePath( filePath, gamePath, false ) .. "'" )
                            return nil

                    fut\setResult( iContent )
                    return nil

                pushCallStack( stack )
                fut\setError( FileSystemError FSASYNC[ iState ] )
                popCallStack()
                return nil

            if state ~= 0
                fut\setError( FileSystemError FSASYNC[ state ] )

            return fut

    do

        import Write from functions

        lib.AsyncWrite = ( filePath, content, gamePath, skipNormalize, saveHash ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            directoryPath = getDirectory( filePath, true )
            if directoryPath ~= "" and directoryPath ~= "/"
                createDir( directoryPath, true, gamePath, true )

            fut = Future!

            appendStack( captureStack() )
            stack = popCallStack()


            state = Write( filePath, content, gamePath, ( iFilePath, iGamePath, iState ) ->
                if iState == 0
                    fullPath = absoluteGamePath( iFilePath, iGamePath, false )
                    if saveHash
                        save( fullPath, len( content ), nil, SHA256( content ) )

                    fut\setResult( fullPath )
                    return nil

                pushCallStack( stack )
                fut\setError( FileSystemError FSASYNC[ iState ] )
                popCallStack()
                return nil

            )

            if state ~= 0
                fut\setError( FileSystemError FSASYNC[ state ] )

            return fut

do

    -- TODO: convert it to async generator (with yield), so it can be used with apairs
    func = async ( task ) ->
        lines, pointer = ByteSplit( await( task ), 0xa --[[ \n ]] ), 0
        return ->
            pointer += 1
            return lines[ pointer ], pointer

    lib.AsyncLines = ( filePath, gamePath, skipNormalize, verifyHash ) ->
        return func( asyncRead( filePath, gamePath, skipNormalize, verifyHash ) )

do

    import stripDirectory, getFileName, getExtension, stripExtension from path
    import load from environment
    -- import CompileFile from _G

    extension2mode = {
        luac: "bt"
        moon: "mt"
        yue: "yt"
        lua: "t"
        lc: "bt"
    }

    mode2type = {
        mt: "moonscript"
        yt: "yuescript"
        bt: "bytecode"
        bt: "bytecode"
        t: "lua"
    }

    asyncCompile = async ( filePath, gamePath, env, config, verifyHash ) ->
        filePath, extension = stripExtension( filePath )
        filePath ..= "."

        extensions = {}
        for fileName in *Find( filePath .. "*", gamePath )
            extensions[ getExtension( fileName, false ) ] = true

        local extension
        if extensions.yue
            extension = "yue"

        elseif extensions.moon
            extension = "moon"

        elseif extensions.luac
            extension = "luac"

        elseif extensions.lc
            extension = "lc"

        elseif extensions.lua
            extension = "lua"

        filePath ..= extension or "lua"

        chunkName = absoluteGamePath( filePath, gamePath, true )

        mode = extension2mode[ extension ]
        unless mode
            error CodeCompileError "Could not determine compile mode for '" .. chunkName .. "'"

        -- if CLIENT and luaGamePaths[ gamePath ] and getExtension( filePath, false ) == "lua"
        --     func = CompileFile( filePath )
        --     unless func
        --         error CodeCompileError "Could not compile '" .. chunkName .. "'"

        --     if env
        --         setfenv( func, env )

        --     return {
        --         :func,
        --         type: mode2type[ mode ],
        --         path: "/" .. chunkName,
        --         content: ""
        --     }

        content = await asyncRead( filePath, gamePath, true, verifyHash )

        return {
            func: load( content, chunkName, mode, env, config ),
            type: mode2type[ mode ],
            path: "/" .. chunkName,
            :content
        }

    lib.AsyncCompile = ( filePath, env, config, gamePath, skipNormalize, verifyHash ) ->
        argument( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return asyncCompile( filePath, gamePath, env, config, verifyHash )

    lib.Compile = ( filePath, env, config, gamePath, skipNormalize, verifyHash ) ->
        argument( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        filePath, extension = stripExtension( filePath )
        filePath ..= "."

        extensions = {}
        for fileName in *Find( filePath .. "*", gamePath )
            extensions[ getExtension( fileName, false ) ] = true

        if extensions.yue
            extension = "yue"

        elseif extensions.moon
            extension = "moon"

        elseif extensions.luac
            extension = "luac"

        elseif extensions.lc
            extension = "lc"

        elseif extensions.lua
            extension = "lua"

        filePath ..= extension or "lua"

        chunkName = absoluteGamePath( filePath, gamePath, true )

        mode = extension2mode[ extension ]
        unless mode
            error CodeCompileError "Could not determine compile mode for '" .. chunkName .. "'"

        -- if CLIENT and luaGamePaths[ gamePath ] and getExtension( filePath, false ) == "lua"
        --     func = CompileFile( filePath )
        --     unless func
        --         error CodeCompileError "Could not compile '" .. chunkName .. "'"

        --     if env
        --         setfenv( func, env )

        --     return {
        --         :func,
        --         type: mode2type[ mode ],
        --         path: "/" .. chunkName,
        --         content: ""
        --     }

        content = read( filePath, gamePath, nil, true, verifyHash )

        return {
            func: load( content, chunkName, mode, env, config ),
            type: mode2type[ mode ],
            path: "/" .. chunkName,
            :content
        }

    environment.loadfile = ( filePath, mode, env, config, gamePath, skipNormalize, verifyHash ) ->
        argument( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        -- if CLIENT and luaGamePaths[ gamePath ] and getExtension( filePath, false ) == "lua"
        --     func = CompileFile( filePath )
        --     unless func
        --         error CodeCompileError "Could not compile '" .. filePath .. "'"

        --     if env
        --         setfenv( func, env )

        --     return func

        return load( read( filePath, gamePath, nil, true, verifyHash ), absoluteGamePath( filePath, gamePath, true ), mode, env, config )

do

    addon = environment.addon = include( "addon.lua" )
    import GMA, IsFilePathAllowed from addon
    import isstring from environment
    import equal from path
    import pairs from _G

    do

        import Read from lib

        lib.Get = ( filePath ) ->
            if istable( filePath )
                result = {}
                for index = 1, #filePath
                    fileName = filePath[ index ]
                    argument( fileName, index, "string" )
                    result[ fileName ] = Read( fileName, nil, nil, false )

                return result

            argument( filePath, 1, "string" )

            return {
                [ filePath ]: Read( filePath, nil, nil, false )
            }

    lib.Set = ( filePath, content, uniqueName ) ->
        if istable( filePath )
            uniqueName = content or uniqueName
            title, length = {}, 0

            gma = GMA!
            for fileName, fileContent in pairs( filePath )
                argument( fileName, 1, "string" )
                argument( fileContent, 2, "string" )

                if len( fileContent ) == 0
                    error FileSystemError "File '" .. fileName .. "' cannot be empty.", 2

                subPath = fileName
                if byte( subPath, 1 ) == 0x2f --[[/]]
                    subPath = sub( subPath, 2 )

                unless IsFilePathAllowed( subPath )
                    error FileSystemError "File '" .. subPath .. "' cannot be written.", 2

                gma\SetFile( subPath, fileContent, false )

                length += 1
                title[ length ] = fileName

            if isstring( uniqueName )
                gma\SetTitle( uniqueName )
            else
                gma\SetTitle( concat( title, ";", 1, length ) )

            return gma\Mount( false )

        argument( filePath, 1, "string" )
        argument( content, 2, "string" )

        if len( content ) == 0
            error FileSystemError "File '" .. filePath .. "' cannot be empty.", 2

        if byte( filePath, 1 ) == 0x2f --[[/]]
            filePath = sub( filePath, 2 )

        unless IsFilePathAllowed( filePath )
            error FileSystemError "File '" .. filePath .. "' cannot be written.", 2

        gma = GMA!
        if isstring( uniqueName )
            gma\SetTitle( uniqueName )
        else
            gma\SetTitle( filePath )

        gma\SetFile( filePath, content, false )
        return gma\Mount( false )

    iterateZipFiles = lib.IterateZipFiles = ( fileHandle, doCRC ) ->
        unless fileHandle
            return fempty

        doCRC = doCRC ~= false

        return ->
            return fileHandle\ReadZipFile( doCRC )

    lib.MountGMAData = async ( data, uniqueName, verifyCRC ) ->
        gma = GMA( data, false )

        if verifyCRC and not gma\VerifyCRC!
            error FileSystemError "Invalid CRC checksum for '" .. gma\GetTitle! .. "'"

        if uniqueName
            gma\SetTitle( uniqueName )

        return await gma\AsyncMount( false )

    mountZIPData = lib.MountZIPData = async ( data, uniqueName ) ->
        gma = GMA!
        gma\SetTitle( uniqueName )

        local isInFolder, last
        temp = {}

        for data in iterateZipFiles( ByteStream( data ), true )
            :content = data
            if content and content ~= ""
                filePath = data.path
                temp[ filePath ] = content

                if isInFolder ~= false
                    current = match( filePath, "^(.-)/" )
                    if last
                        isInFolder = equal( last, current )

                    last = current

        files = temp
        if isInFolder
            files = {}
            endPos = #last + 2
            for fileName, content in pairs( temp )
                files[ sub( fileName, endPos ) ] = content

        for filePath, content in pairs( files )
            if IsFilePathAllowed( filePath )
                gma\SetFile( filePath, content )

        return await gma\AsyncMount( false )

    asyncMount = async ( filePath, gamePath ) ->
        return await mountZIPData( await( asyncRead( filePath, gamePath, true ) ), "file:///" .. filePath )

    lib.MountZIP = ( filePath, gamePath, skipNormalize ) ->
        argument( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return await asyncMount( filePath, gamePath )
