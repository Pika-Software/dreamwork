_G = _G
import file, CLIENT, SERVER from _G
import environment, Logger from _G.gpm

import async, await, debug, util, path, string, Promise, CodeCompileError, FileSystemError, error from environment
import ByteStream, IsBinaryModuleInstalled from util
import sub, len, match, ByteSplit from string
import concat from environment.table
import fempty from debug
import resolve from path
import Find from file

-- Entropia File System Watcher: https://github.com/Pika-Software/gm_efsw
if SERVER and not _G.efsw and IsBinaryModuleInstalled( "efsw" ) and pcall( require, "efsw" )
    Logger\Info( "gm_efsw is initialized, package auto-reloading are available." )

lib = environment.file

local luaPath
if SERVER
    luaPath = "lsv"
elseif CLIENT
    luaPath = "lcl"
elseif MENU_DLL
    luaPath = "LuaMenu"
else
    luaPath = "LUA"

lib.LuaPath = luaPath

luaExtensions = lib.LuaExtensions = {
    ["lua"]: true
    ["yue"]: true
    ["moon"]: true
}

writeAllowedGamePaths = lib.WriteAllowedGamePaths = {
    "DATA": true
}

assertWriteAllowed = ( filePath, gamePath ) ->
    if writeAllowedGamePaths[ gamePath ]
        return nil

    error FileSystemError "File '" .. filePath .. "' is not allowed to be written to '" .. gamePath .. "'.", 3
    return nil

local normalizeGamePath
do

    dir2path = {
        lua: luaPath
        data: "DATA"
        download: "DOWNLOAD"
    }

    normalizeGamePath = lib.NormalizeGamePath = ( absolutePath, gamePath ) ->
        absolutePath = sub( resolve( absolutePath ), 2 )

        if gamePath
            return absolutePath, gamePath

        rootFolder, relativePath = match( absolutePath, "^([^/]+)/?(.*)" )
        if rootFolder
            gamePath = dir2path[ rootFolder ]
            if gamePath
                return relativePath, gamePath

        return absolutePath, "GAME"

do

    import Time from file

    lib.Time = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return Time( filePath, gamePath )

lib.Find = ( filePath, gamePath, skipNormalize ) ->
    unless skipNormalize
        filePath, gamePath = normalizeGamePath( filePath, gamePath )

    return Find( filePath, gamePath )

do

    import replaceDir, replaceFile from path
    import Rename from file

    lib.Move = ( pathFrom, pathTo, gamePathFrom, gamePathTo, skipNormalize ) ->
        unless skipNormalize
            pathFrom, gamePathFrom = normalizeGamePath( pathFrom, gamePathFrom )

        assertWriteAllowed( pathFrom, gamePathFrom )

        unless skipNormalize
            pathTo, gamePathTo = normalizeGamePath( pathTo, gamePathTo )

        assertWriteAllowed( pathTo, gamePathTo )

        return Rename( pathFrom, replaceDir( pathFrom, pathTo ), gamePathFrom, gamePathTo )

    --[[

        Usage:

            file.Move( fullPathToFile, newFilePath )
            file.Move( "/data/test.txt", "/data/folder/" )

    ]]

    lib.Rename = ( filePath, newName, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        assertWriteAllowed( filePath, gamePath )

        return Rename( filePath, replaceFile( filePath, newName ), gamePath )

    --[[

        Usage:

            file.Rename( fullPathToFile, newFileName )
            file.Rename( "/data/test.txt", "test2.txt" )

    ]]

luaGamePaths = {
    "LuaMenu": true
    "lsv": true
    "LUA": true
    "lcl": true
}

local isFileMounted, isDirMounted
do

    allowedGamePaths = {
        "LUA": true
        "lsv": true
        "lcl": true
        "GAME": true
        "WORKSHOP": true
        "THIRDPARTY": true
    }

    mountedFiles = lib.MountedFiles = rawget( environment.file, "MountedFiles" ) or {}

    isFileMounted = lib.IsFileMounted = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFiles[ filePath ]

    mountedFolders = lib.MountedFolders = rawget( environment.file, "MountedFolders" ) or {}

    isDirMounted = lib.IsDirMounted = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFolders[ filePath ]

    do

        import MountGMA from environment.game
        import getDirectory from path

        lib.MountGMA = ( relativePath ) ->
            success, files = MountGMA( sub( resolve( relativePath ), 2 ) )
            if success
                fileCount = #files
                for index = 1, fileCount
                    filePath = files[ index ]

                    -- mounted files
                    mountedFiles[ filePath ] = true

                    -- mounted folders
                    segments, segmentCount = ByteSplit( getDirectory( filePath ), 0x2F --[[ / ]] )
                    segmentCount -= 1

                    while segmentCount ~= 0
                        mountedFolders[ concat( segments, "/", 1, segmentCount ) ] = true
                        segmentCount -= 1

                Logger\Debug( "GMA file '%s' was mounted to GAME with %d files.", relativePath, fileCount )

            return success, files

local isDir, isFile
do

    import Delete, Exists, IsDir from file

    lib.Exists = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return Exists( filePath, gamePath ) or isFileMounted( filePath, gamePath ) or isDirMounted( filePath, gamePath )

    isDir = lib.IsDir = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return IsDir( filePath, gamePath ) or isDirMounted( filePath, gamePath )

    isFile = lib.IsFile = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return ( Exists( filePath, gamePath ) and not IsDir( filePath, gamePath ) ) or isFileMounted( filePath, gamePath, true )

    do

        delete = ( filePath, gamePath ) ->
            if isDir( filePath, gamePath )
                files, folders = Find( filePath .. "/*", gamePath )
                for folderName in *folders
                    delete( filePath .. "/" .. folderName, gamePath )

                for fileName in *files
                    Delete( filePath .. "/" .. fileName, gamePath )

                return Delete( filePath, gamePath )

            return Delete( filePath, gamePath )

        lib.Delete = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            return delete( filePath, gamePath )

    do

        import CreateDir from file

        lib.CreateDir = ( folderPath, force, gamePath, skipNormalize ) ->
            unless skipNormalize
                folderPath, gamePath = normalizeGamePath( folderPath, gamePath )

            assertWriteAllowed( folderPath, gamePath )

            if force
                local currentPath
                for folderName in *ByteSplit( folderPath, 0x2F --[[ / ]] )
                    if folderName
                        if currentPath
                            currentPath ..= "/" .. folderName
                        else
                            currentPath = folderName

                        if IsDir( currentPath, gamePath )
                            continue

                        Delete( currentPath, gamePath )
                        CreateDir( currentPath, gamePath )

                return currentPath

            CreateDir( folderPath, gamePath )
            return folderPath

    do

        import Size from file

        size = ( filePath, gamePath ) ->
            if isDir( filePath, gamePath )
                bytes = 0

                files, folders = Find( filePath .. "/*", gamePath )
                for fileName in *files
                    bytes += Size( filePath .. "/" .. fileName, gamePath )

                for folderName in *folders
                    bytes += size( filePath .. "/" .. folderName, gamePath )

                return bytes

            return Size( filePath, gamePath )

        lib.Size = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            return size( filePath, gamePath )

do

    getFolderContents = ( folderPath, gamePath, result, length ) ->
        files, folders = Find( folderPath .. "*", gamePath )
        unless files
            return result, length

        for fileName in *files
            length += 1
            result[ length ] = folderPath .. fileName

        for folderName in *folders
            result, length = getFolderContents( folderPath .. folderName .. "/", gamePath, result, length )

        return result, length

    lib.GetFolderContents = ( folderPath, gamePath, skipNormalize ) ->
        unless skipNormalize
            folderPath, gamePath = normalizeGamePath( folderPath, gamePath )

        result, length = {}, 0

        if folderPath == "" or isDir( folderPath, gamePath, true )
            if folderPath ~= ""
                folderPath ..= "/"

            return getFolderContents( folderPath, gamePath, result, length )

        return result, length

local append, read, write
do

    local open
    do

        import Open from file

        open = lib.Open = ( filePath, fileMode, gamePath, skipNormalize ) ->
            unless skipNormalize
                if filePath == "memory" and not gamePath
                    return ByteStream!

                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            return Open( filePath, fileMode, gamePath )

    File = util.FindMetaTable( "File" )

    do

        import getmetatable from _G

        environment.isfile = ( any ) ->
            return getmetatable( any ) == File

    import Close, Read, Write, EndOfFile from File

    do

        import ReadULong, WriteULong, ReadByte, WriteByte, Seek, Skip, Tell from File

        do

            import tostring from _G

            File.IsValid = ( fileHandle ) ->
                return tostring( fileHandle ) ~= "File [NULL]"

        File.SeekToBegin = ( fileHandle ) ->
            return Seek( fileHandle, 0 )

        do

            import ArgAssert, load from environment
            import Size from File

            File.SeekToEnd = ( fileHandle ) ->
                return Seek( fileHandle, Size( fileHandle ) )

            environment.loadfile = ( filePath, mode, env ) ->
                ArgAssert( filePath, 1, "string" )

                handler = open( filePath, "rb" )
                unless handler
                    error "File '" .. filePath .. "' can't be opened!", 2
                    return nil

                chunk = Read( handler, Size( handler ) )
                Close( handler )

                return load( chunk, filePath, mode, env )

        File.SkipEmpty = ( fileHandle ) ->
            while not EndOfFile( fileHandle )
                if ReadByte( fileHandle ) ~= 0
                    Skip( fileHandle, -1 )
                    break

        -- String
        File.ReadString = ( fileHandle ) ->
            startPos, length = Tell( fileHandle ), 0
            while not EndOfFile( fileHandle ) and ReadByte( fileHandle ) ~= 0
                length += 1

            Seek( fileHandle, startPos )
            data = Read( fileHandle, length )
            Skip( fileHandle, 1 )
            return data

        File.WriteString = ByteStream.WriteString

        -- Line
        File.WriteLine = ByteStream.WriteLine

        unless File.ReadUInt64
            File.ReadUInt64 = ( fileHandle ) ->
                number = ReadULong( fileHandle )
                Skip( fileHandle, 4 )
                return number

        unless File.WriteUInt64
            File.WriteUInt64 = ( fileHandle, number ) ->
                WriteULong( fileHandle, number )
                WriteULong( fileHandle, 0 )
                return

        -- UnixTime
        File.ReadTime = ByteStream.ReadTime
        File.WriteTime = ByteStream.WriteTime

        -- ZipFile
        File.ReadZipFile = ByteStream.ReadZipFile
        File.WriteZipFile = ByteStream.WriteZipFile

    append = lib.Append = ( filePath, content, gamePath, skipNormalize ) ->
        fileHandle = open( filePath, "ab", gamePath, skipNormalize )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

    read = lib.Read = ( filePath, gamePath, length, skipNormalize ) ->
        fileHandle = open( filePath, "rb", gamePath, skipNormalize )
        if fileHandle
            return Read( fileHandle, length ), Close( fileHandle )

    write = lib.Write = ( filePath, content, gamePath, skipNormalize ) ->
        fileHandle = open( filePath, "wb", gamePath, skipNormalize )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

    do

        import ReadLine from File
        import gsub from string

        readLines = lib.Lines = ( filePath, gamePath, skipNormalize ) ->
            fileHandle = open( filePath, "rb", gamePath, skipNormalize )
            if fileHandle
                lines, length = {}, 0

                while not EndOfFile( fileHandle )
                    length += 1
                    lines[ length ] = ReadLine( fileHandle )

                Close( fileHandle )
                pointer = 0

                return ->
                    pointer += 1
                    return lines[ pointer ], pointer

            return fempty

        import getinfo from debug

        debug.getfcode = ( location ) ->
            info = getinfo( location )
            :linedefined = info
            if linedefined < 0
                return info.source

            :lastlinedefined = info
            lines, length = {}, 0

            for str, line in readLines( gsub( info.source, "^@", "/" ), nil )
                if line >= linedefined
                    length += 1
                    lines[ length ] = str

                if line >= lastlinedefined
                    break

            if length == 0
                return ""

            spaces = match( lines[ 1 ], "^%s+" )
            if spaces
                spLength = len( spaces )
                spLength1 = spLength + 1

                for index = 1, length
                    str = lines[ index ]
                    if sub( str, 1, spLength ) == spaces
                        lines[ index ] = sub( str, spLength1 )

            return concat( lines, "", 1, length )

if SERVER

    import getCurrentFile, getFile, stripExtension from path
    import byte from string

    -- For future overrides by plugins
    lib.InternalAddCSLuaFile = _G.AddCSLuaFile

    addCSLuaFile = ( filePath, isFolder ) ->
        if byte( filePath, len( filePath ) ) == 0x2f --[[/]]
            filePath = sub( filePath, 1, len( filePath ) - 1 )

        subPath = sub( filePath, 6 )

        if isFolder or isDir( subPath, luaPath, true )
            findFiles, findFolders = Find( subPath .. "/*", luaPath )

            foldersCount = #findFolders
            filesCount = #findFiles

            if foldersCount == 0 and filesCount == 0
                error CodeCompileError "Couldn't AddCSLuaFile folder '" .. filePath .. "/' - Folder is empty", 3

            for index = 1, foldersCount
                addCSLuaFile( filePath .. "/" .. findFolders[ index ], true )

            files, length = {}, 0

            for index = 1, filesCount
                fileName, extension = stripExtension( findFiles[ index ] )

                isValidFile = luaExtensions[ extension ]
                if isValidFile
                    for j = length, 1, -1
                        if files[ j ][ 1 ] == fileName
                            isValidFile = false
                            break

                if isValidFile
                    length += 1
                    files[ length ] = { fileName, extension }

            for fileName in *files
                addCSLuaFile( filePath .. "/" .. fileName[ 1 ] .. "." .. fileName[ 2 ], false )

            return nil

        if isFolder == nil and not isFile( subPath, luaPath, true )
            error CodeCompileError "Couldn't AddCSLuaFile file '" .. filePath .. "' - File not found", 3

        lib.InternalAddCSLuaFile( subPath )
        return nil

    lib.AddCSLuaFile = ( filePath ) ->
        if not filePath or filePath == ""
            filePath = getFile( getCurrentFile! )

        filePath = resolve( filePath )

        if sub( filePath, 1, 4 ) ~= "/lua"
            error CodeCompileError "Couldn't AddCSLuaFile file '" .. filePath .. "' - Invalid path", 2

        addCSLuaFile( filePath )
        return nil

import efsw from _G

if istable( efsw )
    import Watch, Unwatch from efsw

    observedFiles = lib.ObservedFiles = rawget( environment.file, "ObservedFiles" ) or {}

    hashIdentifier = ( filePath, gamePath ) ->
        return gamePath .. ":///" .. filePath

    watch = lib.Watch = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        identifier = hashIdentifier( filePath, gamePath )

        if observedFiles[ identifier ]
            return false

        observedFiles[ identifier ] = Watch( filePath, gamePath )

        if isDir( filePath, gamePath, true )
            filePath ..= "/"

            files, folders = Find( filePath .. "*", gamePath )
            for fileName in *files
                watch( filePath .. fileName, gamePath )

            for folderName in *folders
                watch( filePath .. folderName, gamePath )

        return true

    unWatch = lib.UnWatch = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        identifier = hashIdentifier( filePath, gamePath )

        watchID = observedFiles[ identifier ]
        unless watchID
            return false

        observedFiles[ identifier ] = nil
        Unwatch( watchID )

        if isDir( filePath, gamePath, true )
            filePath ..= "/"

            files, folders = Find( filePath .. "*", gamePath )
            for fileName in *files
                unWatch( filePath .. fileName, gamePath )

            for folderName in *folders
                unWatch( filePath .. folderName, gamePath )

        return true

else

    lib.Watch = fempty
    lib.Unwatch = fempty

local asyncRead
do

    functions = {
        { "Append", false },
        { "Write", false },
        { "Read", false }
    }

    do

        sources = {
            {
                "Name": "gm_asyncio"
                "Fetch": -> IsBinaryModuleInstalled( "asyncio" )
                "Install": ->
                    require( "asyncio" )

                    return {
                        "Append": asyncio.AsyncAppend
                        "Read": asyncio.AsyncRead
                        "Write": asyncio.AsyncWrite
                    }
            },
            {
                "Name": "async_write"
                "Fetch": -> IsBinaryModuleInstalled( "async_write" )
                "Install": ->
                    require( "async_write" )

                    return {
                        "Append": file.AsyncAppen
                        "Write": file.AsyncWrite
                    }
            },
            {
                "Name": "Garry's Mod Async"
                "Fetch": -> not MENU_DLL
                "Install": ->
                    return {
                        "Read": file.AsyncRead
                    }
            },
            {
                "Name": "Garry's Mod"
                "Install": ->
                    return {
                        "Append": ( fileName, content, gamePath, func ) ->
                            state = append( fileName, content, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state

                        "Read": ( fileName, gamePath, func ) ->
                            content = read( fileName, gamePath )
                            state = content == nil and -1 or 0
                            func( fileName, gamePath, state, content )
                            return state

                        "Write": ( fileName, content, gamePath, func ) ->
                            state = write( fileName, content, "wb", true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                    }
            }
        }

        functionsNeed = #functions

        for source in *sources
            if not source.Fetch or source.Fetch!
                result = source.Install!

                installed = 0
                for data in *functions
                    if data[ 2 ]
                        continue

                    name = data[ 1 ]
                    unless result[ name ]
                        continue

                    functions[ name ] = result[ name ]
                    functionsNeed -= 1
                    data[ 2 ] = true
                    installed += 1

                if installed > 0
                    Logger\Info( "'%s' was connected as filesystem API.", source.Name )

                if functionsNeed < 1
                    break

    FSASYNC = lib.FSASYNC = {
        [ -8 ]: "Filename not part of the specified file system, try a different one."
        [ -7 ]: "Failure for a reason that might be temporary, you might retry, but not immediately."
        [ -6 ]: "Read parameters invalid for unbuffered IO."
        [ -5 ]: "Hard subsystem failure."
        [ -4 ]: "Read error on file."
        [ -3 ]: "Out of memory for file read."
        [ -2 ]: "Caller's provided id is not recognized."
        [ -1 ]: "Filename could not be opened (bad path, not exist, etc)."
        [  0 ]: "Operation is successful."
        [  1 ]: "File is properly queued, waiting for service."
        [  2 ]: "File is being accessed."
        [  3 ]: "File was aborted by caller."
        [  4 ]: "File is not yet queued."
    }

    do

        import Append from functions

        lib.AsyncAppend = ( filePath, content, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            promise = Promise!

            state = Append( filePath, content, ( iFilePath, iGamePath, iState ) ->
                if iState == 0
                    promise\Resolve( { fileName: iFilePath, gamePath: iGamePath } )
                    return

                promise\Reject( FileSystemError FSASYNC[ iState ] )
                return
            gamePath )

            if state ~= 0
                promise\Reject( FileSystemError FSASYNC[ state ] )

            return promise

    do

        import Read from functions

        asyncRead = lib.AsyncRead = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            promise = Promise!

            state = Read filePath, gamePath, ( _, __, iState, iContent ) ->
                if iState == 0
                    promise\Resolve( iContent )
                    return

                promise\Reject( FileSystemError FSASYNC[ iState ] )
                return

            if state ~= 0
                promise\Reject( FileSystemError FSASYNC[ state ] )

            return promise

    do

        import Write from functions

        lib.AsyncWrite = ( filePath, content, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            promise = Promise!

            state = Write( filePath, content, ( iFilePath, iGamePath, iState ) ->
                if iState == 0
                    promise\Resolve( { fileName: iFilePath, gamePath: iGamePath } )
                    return

                promise\Reject( FileSystemError FSASYNC[ iState ] )
                return
            gamePath )

            if state ~= 0
                promise\Reject( FileSystemError FSASYNC[ state ] )

            return promise

do

    func = async ( promise ) ->
        lines, pointer = ByteSplit( await( promise ), 0xa --[[ \n ]] ), 0
        return ->
            pointer += 1
            return lines[ pointer ], pointer

    lib.AsyncLines = ( filePath, gamePath, skipNormalize ) ->
        return func( asyncRead( filePath, gamePath, skipNormalize ) )

local compileLua
do

    import CompileLuaString, CompileLuaFile from util

    asyncCompile = async ( filePath, gamePath, handleError ) ->
        if CLIENT and isFileMounted( filePath, gamePath, true )
            if luaGamePaths[ gamePath ]
                filePath = "lua/" .. filePath

            gamePath = "WORKSHOP"

        content = await asyncRead( filePath, gamePath, true )
        unless content
            error CodeCompileError "File '" .. filePath .. "' cannot be read."

        local func
        func = CompileLuaString( content, filePath, handleError, false )
        if not func and luaGamePaths[ gamePath ]
            func = CompileLuaFile( filePath )

        if func
            return func

        error CodeCompileError "File '" .. filePath .. "' cannot be compiled."
        return

    compileLua = lib.CompileLua = ( filePath, gamePath, handleError, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return asyncCompile( filePath, gamePath, handleError )

local compileMoon
do

    import CompileMoonString from util

    asyncCompile = async ( filePath, gamePath, handleError ) ->
        content = await asyncRead( filePath, gamePath, true )
        unless content
            error CodeCompileError "File '" .. filePath .. "' cannot be read."

        func = CompileMoonString( content, filePath, handleError )
        if func
            return func

        error CodeCompileError "File '" .. filePath .. "' cannot be compiled."
        return

    compileMoon = lib.CompileMoon = ( filePath, gamePath, handleError, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return asyncCompile( filePath, gamePath, handleError )

local compileYue
do

    import CompileYueString from util

    asyncCompile = async ( filePath, gamePath, handleError, yueConfig ) ->
        content = await asyncRead( filePath, gamePath, true )
        unless content
            error CodeCompileError "File '" .. filePath .. "' cannot be read."

        func = CompileYueString( content, filePath, handleError, yueConfig )
        if func
            return func

        error CodeCompileError "File '" .. filePath .. "' cannot be compiled."
        return

    compileYue = lib.CompileYue = ( filePath, gamePath, handleError, yueConfig, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return asyncCompile( filePath, gamePath, handleError, yueConfig )

do

    import stripExtension from path

    lib.Compile = ( filePath, gamePath, handleError, yueConfig, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        withoutExtension, extension = stripExtension( filePath )
        if extension ~= "" and not luaExtensions[ extension ]
            return compileLua( filePath, gamePath, handleError, true )

        compilePath = withoutExtension .. ".yue"
        if isFile( compilePath, gamePath, true )
            return compileYue( compilePath, gamePath, handleError, yueConfig, true )

        compilePath = withoutExtension .. ".moon"
        if isFile( compilePath, gamePath, true )
            return compileMoon( compilePath, gamePath, handleError, true )

        compilePath = withoutExtension .. ".lua"
        if isFile( compilePath, gamePath, true )
            return compileLua( compilePath, gamePath, handleError, true )

        error CodeCompileError "File '" .. filePath .. "' cannot be compiled."
        return

do

    addon = environment.addon = include( "addon.lua" )
    import File, IsFilePathAllowed from addon
    import equal from path
    import pairs from _G

    do

        import Read from lib

        lib.Get = ( filePath ) ->
            return Read( filePath, nil, nil, false )

    lib.Set = ( filePath, content ) ->
        unless IsFilePathAllowed( filePath )
            error FileSystemError "File '" .. filePath .. "' cannot be written."

        f = File!
        f\SetTitle( filePath )
        f\SetFile( filePath, content, false )
        f\Mount( false )

        return lib.InternalAddCSLuaFile( filePath )

    iterateZipFiles = lib.IterateZipFiles = ( fileHandle, doCRC ) ->
        unless fileHandle
            return fempty

        doCRC = doCRC ~= false

        return ->
            return fileHandle\ReadZipFile( doCRC )

    lib.MountGMAData = async ( data, uniqueName, verifyCRC ) ->
        f = File( data, false )

        if verifyCRC and not f\VerifyCRC!
            error FileSystemError "Invalid CRC checksum for '" .. f\GetTitle! .. "'"

        if uniqueName
            f\SetTitle( uniqueName )

        return f\AsyncMount( false )

    mountZIPData = lib.MountZIPData = async ( data, uniqueName ) ->
        f = File!
        f\SetTitle( uniqueName )

        local isInFolder, last
        temp = {}

        for data in iterateZipFiles( ByteStream( data ), true )
            :content = data
            if content and content ~= ""
                filePath = data.path
                temp[ filePath ] = content

                if isInFolder ~= false
                    current = match( filePath, "^(.-)/" )
                    if last
                        isInFolder = equal( last, current )

                    last = current

        files = temp
        if isInFolder
            files = {}
            endPos = #last + 2
            for fileName, content in pairs( temp )
                files[ sub( fileName, endPos ) ] = content

        for filePath, content in pairs( files )
            if IsFilePathAllowed( filePath )
                f\SetFile( filePath, content )

        return f\AsyncMount( false )

    asyncMount = async ( filePath, gamePath ) ->
        return await mountZIPData( await( asyncRead( filePath, gamePath, true ) ), "file:///" .. filePath )

    lib.MountZIP = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return asyncMount( filePath, gamePath )
