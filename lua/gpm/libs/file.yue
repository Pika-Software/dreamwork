_G = _G
import environment, Logger from _G.gpm
import file, istable, CLIENT, SERVER, MENU_DLL from _G
import async, await, debug, util, path, string, Promise, CodeCompileError, FileSystemError, error, ArgAssert from environment
import ByteStream, IsBinaryModuleInstalled from util
import byte, sub, len, match, ByteSplit from string
import resolve, getDirectory, getFile from path
import concat from environment.table
import fempty from debug
import Find from file

-- Entropia File System Watcher: https://github.com/Pika-Software/gm_efsw
if SERVER and not _G.efsw and IsBinaryModuleInstalled( "efsw" ) and pcall( require, "efsw" )
    Logger\Info( "gm_efsw is initialized, package auto-reloading are available." )

lib = environment.file

local luaPath
if SERVER
    luaPath = "lsv"
elseif CLIENT
    luaPath = "lcl"
elseif MENU_DLL
    luaPath = "LuaMenu"
else
    luaPath = "LUA"

lib.LuaPath = luaPath

luaExtensions = lib.LuaExtensions = {
    lua: true
    yue: true
    moon: true
}

writeAllowedGamePaths = lib.WriteAllowedGamePaths = {
    "DATA": true
}

assertWriteAllowed = ( filePath, gamePath ) ->
    if writeAllowedGamePaths[ gamePath ] or MENU_DLL
        return nil

    error FileSystemError "File '" .. filePath .. "' is not allowed to be written to '" .. gamePath .. "'.", 3
    return nil

local normalizeGamePath, absoluteGamePath
do

    import isurl from environment

    dir2path = {
        lua: luaPath
        data: "DATA"
        download: "DOWNLOAD"
    }

    normalizeGamePath = lib.NormalizeGamePath = ( absolutePath, gamePath ) ->
        if isurl( absolutePath )
            absolutePath = absolutePath.pathname

        absolutePath = sub( resolve( absolutePath ), 2 )

        if gamePath
            return absolutePath, gamePath

        rootFolder, relativePath = match( absolutePath, "^([^/]+)/?(.*)" )
        if rootFolder
            gamePath = dir2path[ rootFolder ]
            if gamePath
                return relativePath, gamePath

        return absolutePath, "GAME"

    path2dir = {
        DOWNLOAD: "/download"
        LuaMenu: "/lua"
        DATA: "/data"
        LUA: "/lua"
        lsv: "/lua"
        lcl: "/lua"
    }

    absoluteGamePath = lib.AbsoluteGamePath = ( filePath, gamePath, withoutSlash ) ->
        if gamePath
            filePath = ( path2dir[ gamePath ] or "" ) .. "/" .. filePath

        if withoutSlash and byte( filePath, 1 ) == 0x2F --[[ / ]]
            filePath = sub( filePath, 2 )

        return filePath

do

    import Time from file

    lib.Time = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return Time( filePath, gamePath )

lib.Find = ( filePath, gamePath, skipNormalize ) ->
    unless skipNormalize
        filePath, gamePath = normalizeGamePath( filePath, gamePath )

    return Find( filePath, gamePath )

do

    import replaceDir, replaceFile from path
    import Rename from file

    lib.Move = ( pathFrom, pathTo, gamePathFrom, gamePathTo, skipNormalize ) ->
        unless skipNormalize
            pathFrom, gamePathFrom = normalizeGamePath( pathFrom, gamePathFrom )

        assertWriteAllowed( pathFrom, gamePathFrom )

        unless skipNormalize
            pathTo, gamePathTo = normalizeGamePath( pathTo, gamePathTo )

        assertWriteAllowed( pathTo, gamePathTo )

        return Rename( pathFrom, replaceDir( pathFrom, pathTo ), gamePathFrom, gamePathTo )

    --[[

        Usage:

            file.Move( fullPathToFile, newFilePath )
            file.Move( "/data/test.txt", "/data/dir/" )

    ]]

    lib.Rename = ( filePath, newName, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        assertWriteAllowed( filePath, gamePath )

        return Rename( filePath, replaceFile( filePath, newName ), gamePath )

    --[[

        Usage:

            file.Rename( fullPathToFile, newFileName )
            file.Rename( "/data/test.txt", "test2.txt" )

    ]]

luaGamePaths = lib.LuaGamePaths = {
    "LuaMenu": true
    "lsv": true
    "LUA": true
    "lcl": true
}

local isFileMounted, isDirMounted
do

    allowedGamePaths = {
        "LUA": true
        "lsv": true
        "lcl": true
        "GAME": true
        "WORKSHOP": true
        "THIRDPARTY": true
    }

    mountedFiles = lib.MountedFiles = rawget( environment.file, "MountedFiles" ) or {}

    isFileMounted = lib.IsFileMounted = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFiles[ filePath ]

    mountedFolders = lib.MountedFolders = rawget( environment.file, "MountedFolders" ) or {}

    isDirMounted = lib.IsDirMounted = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFolders[ filePath ]

    do

        import MountGMA from environment.game

        lib.MountGMA = ( relativePath ) ->
            success, files = MountGMA( sub( resolve( relativePath ), 2 ) )
            if success
                fileCount = #files
                for index = 1, fileCount
                    filePath = files[ index ]

                    -- mounted files
                    mountedFiles[ filePath ] = true

                    -- mounted dirs
                    segments, segmentCount = ByteSplit( getDirectory( filePath, false ), 0x2F --[[ / ]] )
                    segmentCount -= 1

                    while segmentCount ~= 0
                        mountedFolders[ concat( segments, "/", 1, segmentCount ) ] = true
                        segmentCount -= 1

                Logger\Debug( "GMA file '%s' was mounted to GAME with %d files.", relativePath, fileCount )

            return success, files

local isDir, isFile, createDir
do

    import Delete, Exists, IsDir from file

    lib.Exists = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return Exists( filePath, gamePath ) or isFileMounted( filePath, gamePath, true ) or isDirMounted( filePath, gamePath, true )

    isDir = lib.IsDir = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return IsDir( filePath, gamePath ) or isDirMounted( filePath, gamePath, true )

    isFile = lib.IsFile = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return ( Exists( filePath, gamePath ) and not IsDir( filePath, gamePath ) ) or isFileMounted( filePath, gamePath, true )

    do

        delete = ( filePath, gamePath ) ->
            basePath = getDirectory( filePath, true )
            files, dirs = Find( filePath, gamePath )
            searchable = getFile( filePath )
            successful = true

            for fileName in *files
                unless Delete( basePath .. fileName, gamePath )
                    successful = false

            for directoryName in *dirs
                directoryPath = basePath .. directoryName
                if directoryPath == filePath
                    unless delete( directoryPath .. "/*", gamePath )
                        successful = false

                elseif not delete( directoryPath .. "/" .. searchable, gamePath )
                    successful = false

                unless Delete( directoryPath, gamePath )
                    successful = false

            return successful

        lib.Delete = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            return delete( filePath, gamePath )

    do

        import CreateDir from file

        createDir = lib.CreateDir = ( directoryPath, force, gamePath, skipNormalize ) ->
            unless skipNormalize
                directoryPath, gamePath = normalizeGamePath( directoryPath, gamePath )

            assertWriteAllowed( directoryPath, gamePath )

            if force
                local currentPath
                for directoryName in *ByteSplit( directoryPath, 0x2F --[[ / ]] )
                    if directoryName
                        if currentPath
                            currentPath ..= "/" .. directoryName
                        else
                            currentPath = directoryName

                        if isDir( currentPath, gamePath, true )
                            continue

                        Delete( currentPath, gamePath )
                        CreateDir( currentPath, gamePath )

                return currentPath

            CreateDir( directoryPath, gamePath )
            return directoryPath

    do

        import Size from file

        size = ( filePath, gamePath ) ->
            if isDir( filePath, gamePath )
                bytes = 0

                files, dirs = Find( filePath .. "/*", gamePath )
                for fileName in *files
                    bytes += Size( filePath .. "/" .. fileName, gamePath )

                for directoryName in *dirs
                    bytes += size( filePath .. "/" .. directoryName, gamePath )

                return bytes

            return Size( filePath, gamePath )

        lib.Size = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            return size( filePath, gamePath )

do

    getFolderContents = ( directoryPath, gamePath, result, length ) ->
        files, dirs = Find( directoryPath .. "*", gamePath )
        unless files
            return result, length

        for fileName in *files
            length += 1
            result[ length ] = directoryPath .. fileName

        for directoryName in *dirs
            result, length = getFolderContents( directoryPath .. directoryName .. "/", gamePath, result, length )

        return result, length

    lib.GetFolderContents = ( directoryPath, gamePath, skipNormalize ) ->
        unless skipNormalize
            directoryPath, gamePath = normalizeGamePath( directoryPath, gamePath )

        result, length = {}, 0

        if directoryPath == "" or isDir( directoryPath, gamePath, true )
            if directoryPath ~= ""
                directoryPath ..= "/"

            return getFolderContents( directoryPath, gamePath, result, length )

        return result, length

local append, read, write
do

    legacy = util.FindMetaTable( "File" )
    base = {}

    do

        import getmetatable from _G

        environment.isfile = ( any ) ->
            metatable = getmetatable( any )
            return metatable == base or metatable == legacy

    local fileClass
    do

        import setmetatable from debug
        newClass = environment.class
        import Open from file

        writeModes = {
            ["a"]: true,
            ["w"]: true,
            ["ab"]: true,
            ["wb"]: true
        }

        legacy.new = ( filePath, fileMode, gamePath, skipNormalize ) =>
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            if writeModes[ fileMode ]
                directoryPath = getDirectory( filePath, true )
                if directoryPath ~= "" and directoryPath ~= "/"
                    createDir( directoryPath, true, gamePath, true )

            f = Open( filePath, fileMode, gamePath )
            if f
                setmetatable( f, @.__class.__base )
                return true, f

            return true, nil

        fileLegacyClass = newClass( "File: Legacy", legacy )
        util.FileLegacy = fileLegacyClass

        fileClass = newClass( "File", base, nil, fileLegacyClass )
        util.File = fileClass

        lib.Open = ( filePath, fileMode, gamePath, skipNormalize ) ->
            return fileClass( filePath, fileMode, gamePath, skipNormalize )

    import Close, Read, Write, EndOfFile from legacy

    do

        import ReadULong, WriteULong, ReadByte, WriteByte, Seek, Skip, Tell from legacy

        do

            import tostring from _G

            base.IsValid = ( fileHandle ) ->
                return tostring( fileHandle ) ~= "File [NULL]"

        base.SeekToBegin = ( fileHandle ) ->
            return Seek( fileHandle, 0 )

        do

            import Size from legacy

            base.SeekToEnd = ( fileHandle ) ->
                return Seek( fileHandle, Size( fileHandle ) )

        base.SkipEmpty = ( fileHandle ) ->
            while not EndOfFile( fileHandle )
                if ReadByte( fileHandle ) ~= 0
                    Skip( fileHandle, -1 )
                    break

        -- String
        base.ReadString = ( fileHandle ) ->
            startPos, length = Tell( fileHandle ), 0
            while not EndOfFile( fileHandle ) and ReadByte( fileHandle ) ~= 0
                length += 1

            Seek( fileHandle, startPos )
            data = Read( fileHandle, length )
            Skip( fileHandle, 1 )
            return data

        base.WriteString = ByteStream.WriteString

        -- Line
        base.WriteLine = ByteStream.WriteLine

        unless base.ReadUInt64
            base.ReadUInt64 = ( fileHandle ) ->
                number = ReadULong( fileHandle )
                Skip( fileHandle, 4 )
                return number

        unless base.WriteUInt64
            base.WriteUInt64 = ( fileHandle, number ) ->
                WriteULong( fileHandle, number )
                WriteULong( fileHandle, 0 )
                return

        base.ReadAll = ( fileHandle ) ->
            Seek( fileHandle, 0 )
            return Read( fileHandle, Size( fileHandle ) )

        -- UnixTime
        base.ReadTime = ByteStream.ReadTime
        base.WriteTime = ByteStream.WriteTime

        -- ZipFile
        base.ReadZipFile = ByteStream.ReadZipFile
        base.WriteZipFile = ByteStream.WriteZipFile

        -- Color
        base.ReadColor = ByteStream.ReadColor
        base.WriteColor = ByteStream.WriteColor

    append = lib.Append = ( filePath, content, gamePath, skipNormalize ) ->
        fileHandle = fileClass( filePath, "ab", gamePath, skipNormalize )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

    read = lib.Read = ( filePath, gamePath, length, skipNormalize ) ->
        fileHandle = fileClass( filePath, "rb", gamePath, skipNormalize )
        if fileHandle
            return Read( fileHandle, length ), Close( fileHandle )

    write = lib.Write = ( filePath, content, gamePath, skipNormalize ) ->
        fileHandle = fileClass( filePath, "wb", gamePath, skipNormalize )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

    do

        import ReadLine from legacy
        import gsub from string

        readLines = lib.Lines = ( filePath, gamePath, skipNormalize ) ->
            fileHandle = fileClass( filePath, "rb", gamePath, skipNormalize )
            if fileHandle
                lines, length = {}, 0

                while not EndOfFile( fileHandle )
                    length += 1
                    lines[ length ] = ReadLine( fileHandle )

                Close( fileHandle )
                pointer = 0

                return ->
                    pointer += 1
                    return lines[ pointer ], pointer

            return fempty

        import getinfo from debug

        debug.getfcode = ( location ) ->
            info = getinfo( location )
            :linedefined = info
            if linedefined < 0
                return info.source

            :lastlinedefined = info
            lines, length = {}, 0

            for str, line in readLines( gsub( info.source, "^@", "/" ), nil )
                if line >= linedefined
                    length += 1
                    lines[ length ] = str

                if line >= lastlinedefined
                    break

            if length == 0
                return ""

            spaces = match( lines[ 1 ], "^%s+" )
            if spaces
                spLength = len( spaces )
                spLength1 = spLength + 1

                for index = 1, length
                    str = lines[ index ]
                    if sub( str, 1, spLength ) == spaces
                        lines[ index ] = sub( str, spLength1 )

            return concat( lines, "", 1, length )

import efsw from _G

if istable( efsw )
    import Watch, Unwatch from efsw

    observedFiles = lib.ObservedFiles = rawget( environment.file, "ObservedFiles" ) or {}

    hashIdentifier = ( filePath, gamePath ) ->
        return gamePath .. ":///" .. filePath

    watch = lib.Watch = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        identifier = hashIdentifier( filePath, gamePath )

        if observedFiles[ identifier ]
            return false

        observedFiles[ identifier ] = Watch( filePath, gamePath )

        if isDir( filePath, gamePath, true )
            filePath ..= "/"

            files, dirs = Find( filePath .. "*", gamePath )
            for fileName in *files
                watch( filePath .. fileName, gamePath )

            for directoryName in *dirs
                watch( filePath .. directoryName, gamePath )

        return true

    unWatch = lib.UnWatch = ( filePath, gamePath, skipNormalize ) ->
        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        identifier = hashIdentifier( filePath, gamePath )

        watchID = observedFiles[ identifier ]
        unless watchID
            return false

        observedFiles[ identifier ] = nil
        Unwatch( watchID )

        if isDir( filePath, gamePath, true )
            filePath ..= "/"

            files, dirs = Find( filePath .. "*", gamePath )
            for fileName in *files
                unWatch( filePath .. fileName, gamePath )

            for directoryName in *dirs
                unWatch( filePath .. directoryName, gamePath )

        return true

else

    lib.Watch = fempty
    lib.Unwatch = fempty

local asyncRead
do

    functions = {
        { "Append", false },
        { "Write", false },
        { "Read", false }
    }

    do

        sources = {
            {
                "Name": "gm_asyncio"
                "Fetch": -> IsBinaryModuleInstalled( "asyncio" )
                "Install": ->
                    require( "asyncio" )

                    return {
                        "Append": asyncio.AsyncAppend
                        "Read": asyncio.AsyncRead
                        "Write": asyncio.AsyncWrite
                    }
            },
            {
                "Name": "async_write"
                "Fetch": -> IsBinaryModuleInstalled( "async_write" )
                "Install": ->
                    require( "async_write" )

                    return {
                        "Append": file.AsyncAppen
                        "Write": file.AsyncWrite
                    }
            },
            {
                "Name": "Garry's Mod Async"
                "Fetch": -> not MENU_DLL
                "Install": ->
                    return {
                        "Read": file.AsyncRead
                    }
            },
            {
                "Name": "Garry's Mod"
                "Install": ->
                    return {
                        "Read": ( fileName, gamePath, func ) ->
                            content = read( fileName, gamePath, nil, true )
                            state = content == nil and -1 or 0
                            func( fileName, gamePath, state, content )
                            return state

                        "Append": ( fileName, content, gamePath, func ) ->
                            state = append( fileName, content, gamePath, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state

                        "Write": ( fileName, content, gamePath, func ) ->
                            state = write( fileName, content, gamePath, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                    }
            }
        }

        functionsNeed = #functions

        for source in *sources
            if not source.Fetch or source.Fetch!
                result = source.Install!

                installed = 0
                for data in *functions
                    if data[ 2 ]
                        continue

                    name = data[ 1 ]
                    unless result[ name ]
                        continue

                    functions[ name ] = result[ name ]
                    functionsNeed -= 1
                    data[ 2 ] = true
                    installed += 1

                if installed > 0
                    Logger\Info( "'%s' was connected as filesystem API.", source.Name )

                if functionsNeed < 1
                    break

    FSASYNC = lib.FSASYNC = {
        [ -8 ]: "Filename not part of the specified file system, try a different one."
        [ -7 ]: "Failure for a reason that might be temporary, you might retry, but not immediately."
        [ -6 ]: "Read parameters invalid for unbuffered IO."
        [ -5 ]: "Hard subsystem failure."
        [ -4 ]: "Read error on file."
        [ -3 ]: "Out of memory for file read."
        [ -2 ]: "Caller's provided id is not recognized."
        [ -1 ]: "Filename could not be opened (bad path, not exist, etc)."
        [  0 ]: "Operation is successful."
        [  1 ]: "File is properly queued, waiting for service."
        [  2 ]: "File is being accessed."
        [  3 ]: "File was aborted by caller."
        [  4 ]: "File is not yet queued."
    }

    do

        import Append from functions

        lib.AsyncAppend = ( filePath, content, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            promise = Promise!

            state = Append( filePath, content, ( iFilePath, iGamePath, iState ) ->
                if iState == 0
                    promise\Resolve( absoluteGamePath( iFilePath, iGamePath, false ) )
                    return nil

                promise\Reject( FileSystemError FSASYNC[ iState ] )
                return nil
            gamePath )

            if state ~= 0
                promise\Reject( FileSystemError FSASYNC[ state ] )

            return promise

    do

        import Read from functions

        asyncRead = lib.AsyncRead = ( filePath, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            promise = Promise!

            state = Read filePath, gamePath, ( _, __, iState, iContent ) ->
                if iState == 0
                    promise\Resolve( iContent )
                    return nil

                promise\Reject( FileSystemError FSASYNC[ iState ] )
                return nil

            if state ~= 0
                promise\Reject( FileSystemError FSASYNC[ state ] )

            return promise

    do

        import Write from functions

        lib.AsyncWrite = ( filePath, content, gamePath, skipNormalize ) ->
            unless skipNormalize
                filePath, gamePath = normalizeGamePath( filePath, gamePath )

            assertWriteAllowed( filePath, gamePath )

            directoryPath = getDirectory( filePath, true )
            if directoryPath ~= "" and directoryPath ~= "/"
                createDir( directoryPath, true, gamePath, true )

            promise = Promise!

            state = Write( filePath, content, ( iFilePath, iGamePath, iState ) ->
                if iState == 0
                    promise\Resolve( absoluteGamePath( iFilePath, iGamePath, false ) )
                    return nil

                promise\Reject( FileSystemError FSASYNC[ iState ] )
                return nil

            gamePath )

            if state ~= 0
                promise\Reject( FileSystemError FSASYNC[ state ] )

            return promise

do

    func = async ( promise ) ->
        lines, pointer = ByteSplit( await( promise ), 0xa --[[ \n ]] ), 0
        return ->
            pointer += 1
            return lines[ pointer ], pointer

    lib.AsyncLines = ( filePath, gamePath, skipNormalize ) ->
        return func( asyncRead( filePath, gamePath, skipNormalize ) )

do

    import stripDirectory, getFileName, getExtension from path
    import load from environment

    extension2mode = {
        luac: "bt"
        moon: "mt"
        yue: "yt"
        lua: "t"
        lc: "bt"
    }

    extension2type = {
        moon: "moonscript"
        yue: "yuescript"
        luac: "bytecode"
        lc: "bytecode"
        lua: "lua"
    }

    asyncCompile = async ( filePath, gamePath, env, config ) ->
        filePath, directoryPath = stripDirectory( filePath, true )
        filePath = directoryPath .. getFileName( filePath, false )

        extensions = {}
        for fileName in *Find( filePath .. ".*", gamePath )
            extensions[ getExtension( fileName, false ) ] = true

        local extension
        if extensions.yue
            extension = "yue"

        elseif extensions.moon
            extension = "moon"

        elseif extensions.luac
            extension = "luac"

        elseif extensions.lc
            extension = "lc"

        elseif extensions.lua
            extension = "lua"

        filePath ..= "." .. ( extension or "lua" )

        unless extension
            error CodeCompileError "Could not determine compile mode for '" .. filePath .. "'"

        content = await asyncRead( filePath, gamePath, true )
        chunkName = absoluteGamePath( filePath, gamePath, true )

        return {
            func: load( content, chunkName, extension2mode[ extension ] or "t", env, config ),
            type: extension2type[ extension ] or "lua",
            path: "/" .. chunkName,
            :content
        }

    lib.AsyncCompile = ( filePath, env, config, gamePath, skipNormalize ) ->
        ArgAssert( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        if CLIENT and isFileMounted( filePath, gamePath, true )
            if luaGamePaths[ gamePath ]
                filePath = "lua/" .. filePath

            gamePath = "WORKSHOP"

        return asyncCompile( filePath, gamePath, env, config )

    lib.Compile = ( filePath, env, config, gamePath, skipNormalize ) ->
        ArgAssert( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        if CLIENT and isFileMounted( filePath, gamePath, true )
            if luaGamePaths[ gamePath ]
                filePath = "lua/" .. filePath

            gamePath = "WORKSHOP"

        filePath, directoryPath = stripDirectory( filePath, true )
        filePath = directoryPath .. getFileName( filePath, false )

        extensions = {}
        for fileName in *Find( filePath .. ".*", gamePath )
            extensions[ getExtension( fileName, false ) ] = true

        local extension
        if extensions.yue
            extension = "yue"

        elseif extensions.moon
            extension = "moon"

        elseif extensions.luac
            extension = "luac"

        elseif extensions.lc
            extension = "lc"

        elseif extensions.lua
            extension = "lua"

        filePath ..= "." .. ( extension or "lua" )

        unless mode
            error CodeCompileError "Could not determine compile mode for '" .. filePath .. "'"

        content = read( filePath, gamePath, nil, true )
        chunkName = absoluteGamePath( filePath, gamePath, true )

        return {
            func: load( content, chunkName, extension2mode[ extension ] or "t", env, config ),
            path: "/" .. chunkName,
            :content,
            :type
        }

    environment.loadfile = ( filePath, mode, env, config, gamePath, skipNormalize ) ->
        ArgAssert( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        if CLIENT and isFileMounted( filePath, gamePath, true )
            if luaGamePaths[ gamePath ]
                filePath = "lua/" .. filePath

            gamePath = "WORKSHOP"

        return load( read( filePath, gamePath, nil, true ), absoluteGamePath( filePath, gamePath, true ), mode, env, config )

do

    addon = environment.addon = include( "addon.lua" )
    import GMA, IsFilePathAllowed from addon
    import isstring from environment
    import equal from path
    import pairs from _G

    do

        import Read from lib

        lib.Get = ( filePath ) ->
            if istable( filePath )
                result = {}
                for index = 1, #filePath
                    fileName = filePath[ index ]
                    ArgAssert( fileName, index, "string" )
                    result[ fileName ] = Read( fileName, nil, nil, false )

                return result

            ArgAssert( filePath, 1, "string" )

            return {
                [ filePath ]: Read( filePath, nil, nil, false )
            }

    lib.Set = ( filePath, content, uniqueName ) ->
        if istable( filePath )
            uniqueName = content or uniqueName
            title, length = {}, 0

            gma = GMA!
            for fileName, fileContent in pairs( filePath )
                ArgAssert( fileName, 1, "string" )
                ArgAssert( fileContent, 2, "string" )

                if len( fileContent ) == 0
                    error FileSystemError "File '" .. fileName .. "' cannot be empty.", 2

                subPath = fileName
                if byte( subPath, 1 ) == 0x2f --[[/]]
                    subPath = sub( subPath, 2 )

                unless IsFilePathAllowed( subPath )
                    error FileSystemError "File '" .. subPath .. "' cannot be written.", 2

                gma\SetFile( subPath, fileContent, false )

                length += 1
                title[ length ] = fileName

            if isstring( uniqueName )
                gma\SetTitle( uniqueName )
            else
                gma\SetTitle( concat( title, ";", 1, length ) )

            return gma\Mount( false )

        ArgAssert( filePath, 1, "string" )
        ArgAssert( content, 2, "string" )

        if len( content ) == 0
            error FileSystemError "File '" .. filePath .. "' cannot be empty.", 2

        if byte( filePath, 1 ) == 0x2f --[[/]]
            filePath = sub( filePath, 2 )

        unless IsFilePathAllowed( filePath )
            error FileSystemError "File '" .. filePath .. "' cannot be written.", 2

        gma = GMA!
        if isstring( uniqueName )
            gma\SetTitle( uniqueName )
        else
            gma\SetTitle( filePath )

        gma\SetFile( filePath, content, false )
        return gma\Mount( false )

    iterateZipFiles = lib.IterateZipFiles = ( fileHandle, doCRC ) ->
        unless fileHandle
            return fempty

        doCRC = doCRC ~= false

        return ->
            return fileHandle\ReadZipFile( doCRC )

    lib.MountGMAData = async ( data, uniqueName, verifyCRC ) ->
        gma = GMA( data, false )

        if verifyCRC and not gma\VerifyCRC!
            error FileSystemError "Invalid CRC checksum for '" .. gma\GetTitle! .. "'"

        if uniqueName
            gma\SetTitle( uniqueName )

        return gma\AsyncMount( false )

    mountZIPData = lib.MountZIPData = async ( data, uniqueName ) ->
        gma = GMA!
        gma\SetTitle( uniqueName )

        local isInFolder, last
        temp = {}

        for data in iterateZipFiles( ByteStream( data ), true )
            :content = data
            if content and content ~= ""
                filePath = data.path
                temp[ filePath ] = content

                if isInFolder ~= false
                    current = match( filePath, "^(.-)/" )
                    if last
                        isInFolder = equal( last, current )

                    last = current

        files = temp
        if isInFolder
            files = {}
            endPos = #last + 2
            for fileName, content in pairs( temp )
                files[ sub( fileName, endPos ) ] = content

        for filePath, content in pairs( files )
            if IsFilePathAllowed( filePath )
                gma\SetFile( filePath, content )

        return gma\AsyncMount( false )

    asyncMount = async ( filePath, gamePath ) ->
        return await mountZIPData( await( asyncRead( filePath, gamePath, true ) ), "file:///" .. filePath )

    lib.MountZIP = ( filePath, gamePath, skipNormalize ) ->
        ArgAssert( filePath, 1, "string" )

        unless skipNormalize
            filePath, gamePath = normalizeGamePath( filePath, gamePath )

        return asyncMount( filePath, gamePath )
