import gsub, sub, find, format, len, lower, match, Extract from gpm.string
import Empty, Merge, RemoveByIValue from gpm.table
import Encode, Decode, ParseQuery, Query from gpm.http
import isv4, isv6 from gpm.ip
import Resolve from gpm.path

setmetatable = setmetatable
tostring = tostring
isstring = isstring
istable = istable
rawget = rawget
rawset = rawset
error = error
pairs = pairs
next = next

--[[

    URL Object by Unknown Developer

    References:
        https://developer.mozilla.org/en-US/docs/Web/API/URL
        https://github.com/nodejs/node/blob/main/doc/api/url.md
        https://github.com/golgote/neturl/blob/master/lib/net/url.lua

--]]

local encodeFilePathPart
do

    pathSymbols = "%!%$%&%'%(%)%*%,%-%.%:%;%=%@%_%~"

    encodeFilePathPart = ( str ) ->
        return Encode( Decode( str ), pathSymbols )

services = {
    ftp: "21"
    ssh: "22"
    sftp: "22"
    telnet: "23"
    smtp: "25"
    tftp: "69"
    gopher: "70"
    http: "80"
    ws: "80"
    nntp: "119"
    snmp: "161"
    imap: "143"
    prospero: "191"
    ldap: "389"
    https: "443"
    wss: "443"
    smtps: "465"
    videotex: "516"
    rtsp: "554"
    vemmi: "575"
    starttls: "587"
    ipp: "631"
    acap: "674"
    rsync: "873"
    cap: "1026"
    mtqp: "1038"
    icap: "1344"
    afs: "1483"
    news: "2009"
    nfs: "2049"
    dict: "2628"
    mupdate: "3905"
    iax: "4569"
    sip: "5060"
    jms: "5673"
}

meta = {
    VERSION: "1.0.0"
    Services: services
    __tostring: =>
        return @href
}

do

    getmetatable = getmetatable

    meta.__eq = ( a, b ) ->
        return getmetatable( b ) == meta and b.href == a.href

meta.__index = ( key ) =>
    return meta[ key ] or rawget( @, "metadata" )[ key ]

build = =>
    metadata = rawget( @, "metadata" )
    url = metadata.protocol .. "//"

    username = metadata.username
    if len( username ) ~= 0
        url ..= username

        password = metadata.password
        if len( password ) ~= 0
            url ..= ":" .. password

        url ..= "@"

    hostname = metadata.hostname
    if len( hostname ) ~= 0
        url ..= hostname

        port = metadata.port
        if len( port ) ~= 0 and port ~= services[ metadata.scheme ]
            url ..= ":" .. port

    return format( "%s%s%s%s", url, metadata.pathname, @searchParams\toString!, metadata.hash )

meta.build = build

parse = ( url, ... ) =>
    metadata = rawget( @, "metadata" )
    Empty( metadata )

    -- replace backslashes with slashes
    url = gsub( url, "\\", "/" )

    -- protocol & scheme
    url, protocol = Extract( url, "^(.-:)" )

    unless protocol
        error "URL protocol is missing!", 4

    protocol = lower( protocol )
    metadata.protocol = protocol

    scheme = sub( protocol, 1, -2 )

    unless find( scheme, "^[a-z].*%w$" )
        error format( "Invalid URL scheme: \"%s\"", scheme ), 4

    metadata.scheme = scheme

    -- hash
    url, metadata.hash = Extract( url, "(#.*)$" )

    -- search
    url, search = Extract( url, "(%?.*)$", "" )
    metadata.search = search

    if search
        @searchParams\parse( sub( search, 2 ), @, true )
    else
        @searchParams\clear( true )

    -- '//' formatter
    url = gsub( url, "^//+", "//" )

    -- 'data' like schemes
    if match( url, "^(.-:)//" )
        metadata.pathname = url
        metadata.href = protocol .. url .. search .. metadata.hash
        return

    -- authority
    url, authority = Extract( url, "^//([^/]+)" )
    if authority
        -- host & auth
        host, auth = Extract( authority, "^([^@]*)@" )
        if len( host ) == 0
            error "URL host is missing!", 4

        -- username & password
        if auth
            if len( auth ) == 0
                error "Invalid URL username!", 4

            usernameEnd = find( auth, ":" )
            if usernameEnd
                metadata.username = Encode( Decode( sub( auth, 1, usernameEnd - 1 ) ) )
                metadata.password = Encode( Decode( sub( auth, usernameEnd + 1 ) ) )
            else
                metadata.username = Encode( Decode( auth ) )

        -- host & origin
        metadata.origin = protocol .. "//" .. host
        metadata.host = host

        -- hostname
        hostname, port = Extract( host, ":(.+)", "" )
        if len( hostname ) == 0
            error "URL hostname is missing!", 4

        if isv4( hostname )
            ok, msg = isv4( hostname, true )
            unless ok
                error format( "Invalid IPv4 hostname address: \"%s\", %s.", hostname, msg ), 4

        if isv6( hostname )
            ok, msg = isv6( hostname, true )
            unless ok
                error format( "Invalid IPv6 hostname address: \"%s\", %s.", hostname, msg ), 4

        metadata.hostname = hostname

        -- port
        if len( port ) ~= 0 and not find( port, "^[0-9]+$" )
            error format( "Invalid URL port: \"%s\"", port ), 4

        metadata.port = port

    -- pathname & href
    metadata.pathname = gsub( "/" .. Resolve( url, ... ), "([^/]+)", encodeFilePathPart )
    metadata.href = build( @ )
    return

meta.parse = parse

rebuild = =>
    parse( @, build( @ ) )
    return @

meta.rebuild = rebuild

class URLSearchParams
    new: ( queryData, urlObject ) =>
        @query = {}
        @parse( queryData, urlObject, true )

    __tostring: =>
        return Query( @query )

    toString: =>
        return Query( @query )

    parse: ( queryData, urlObject, noFullUpdate ) =>
        @urlObject = urlObject
        query = @query

        for key in pairs( query )
            query[ key ] = nil

        if istable( queryData )
            for key, value in pairs( queryData )
                query[ key ] = value

        elseif isstring( queryData )
            for key, value in pairs( ParseQuery( queryData ) )
                query[ key ] = value

        @update( noFullUpdate )

    update: ( noFullUpdate ) =>
        unless noFullUpdate
            urlObject = @urlObject
            if urlObject
                rebuild( urlObject )

        size = 0
        for _ in pairs( @query )
            size += 1

        @size = size

    has: ( ... ) =>
        query = @query
        for key in *{ ... }
            unless query[ key ]
                return false

        return true

    keys: =>
        query, key = @query, nil
        return ->
            key = next( query, key )
            return key

    values: =>
        query, key = @query, nil
        return ->
            key, value = next( query, key )
            return value

    entries: =>
        return next, @query

    get: ( key ) =>
        return @query[ key ]

    set: ( key, value, noFullUpdate ) =>
        @query[ tostring( key ) ] = tostring( value )
        @update( noFullUpdate )

    merge: ( tbl, noFullUpdate ) =>
        Merge( @query, tbl )
        @update( noFullUpdate )

    getAll: ( key ) =>
        query = @query
        if istable( query[ key ] )
            return query[ key ]

        return {}

    append: ( key, value, noFullUpdate ) =>
        @query[] = key .. "=" .. value
        @update( noFullUpdate )

    delete: ( key, value, noFullUpdate ) =>
        query = @query
        if value == nil or not istable( query[ key ] )
            query[ key ] = nil
        else
            RemoveByIValue( query[ key ], value )

        @update( noFullUpdate )

    clear: ( noFullUpdate ) =>
        query = @query
        for key in pairs( query )
            query[ key ] = nil

        @update( noFullUpdate )

gpm.URLSearchParams = URLSearchParams

metadataMeta = {
    __index: ->
        return ""
}

URL = setmetatable {
    __name: "URL"
    __base: meta
    __init: ( ... ) =>
        rawset( @, "metadata", setmetatable( {}, metadataMeta ) )
        rawset( @, "searchParams", URLSearchParams( "", @ ) )
        parse( @, ... )
        return
}, {
    __index: meta
    __call: ( cls, ... ) ->
        obj = setmetatable( {}, meta )
        cls.__init( obj, ... )
        return obj
}

meta.__class = URL
gpm.URL = URL

do

    changeableValues = {
        protocol: true
        scheme: true

        hash: true

        search: true

        username: true
        password: true

        host: true

        hostname: true
        port: true

        pathname: true

        href: true
    }

    meta.__newindex = ( key, value ) =>
        unless changeableValues[ key ]
            return

        metadata = rawget( @, "metadata" )
        value = tostring( value )

        if key == "protocol"
            scheme = lower( match( value, "(.*):?" ) )
            metadata.port = services[ scheme ] or metadata.port
            metadata.scheme = scheme
            value = scheme .. ":"

        elseif key == "scheme"
            value = lower( value )
            metadata.protocol = value .. ":"

        elseif key == "hash"
            value = "#" .. match( value, "#?(.*)" )

        elseif key == "search"
            value = "?" .. match( value, "%??(.*)" )
            @searchParams\parse( sub( value, 2 ), @, true )

        elseif key == "username" or key == "password"
            value = Encode( Decode( value ) )

        elseif key == "host"
            if len( value ) == 0
                error "URL host is missing!", 2

            -- origin
            metadata.origin = @protocol .. "//" .. value

            -- hostname & port
            hostname, port = Extract( value, ":(.+)" )
            if len( hostname ) == 0
                error "URL hostname is missing!", 2

            if isv4( hostname )
                ok, msg = isv4( hostname, true )
                unless ok
                    error format( "Invalid IPv4 hostname address: \"%s\", %s.", hostname, msg ), 2

            if isv6( hostname )
                ok, msg = isv6( hostname, true )
                unless ok
                    error format( "Invalid IPv6 hostname address: \"%s\", %s.", hostname, msg ), 2

            metadata.hostname = hostname

            -- port
            if port
                if find( port, "^[0-9]+$" )
                    metadata.port = port
                else
                    error format( "Invalid URL port: \"%s\"", port ), 2
            else
                metadata.port = services[ scheme ]

        elseif key == "pathname"
            value = gsub( "/" .. Resolve( value ), "([^/]+)", encodeFilePathPart )

        elseif key == "href"
            return parse( @, value )

        metadata[ key ] = value
        return rebuild( @ )

--// Tests //-->

-- url = URL( "http://google.com/index.html" )

-- url.protocol = "https"
-- url.scheme = "yep"

-- url.hash = "#tag"
-- url.hash = "tag"

-- url.search = "?query=123&a=1&b=2"
-- url.searchParams = nil

-- url.username = "cool-guy"
-- url.password = "secret"

-- url.host = "hell.com"

-- url.hostname = "localhost"
-- url.port = 27015

-- url.pathname = "garrysmod/lua/autorun/../init.lua"

-- url.href = "http://localhost:27015/garrysmod/lua/autorun/../init.lua"

-- url.searchParams\replace( { a: 1, b: 2 } )
-- url.searchParams\delete "a"
-- url.searchParams\set "a", 5

-- url.searchParams\merge { c: 3, d: 4 }
-- print url.searchParams\get "a"

-- url.searchParams\set "a", { 1, 2, 3, 4 }

-- PrintTable url

-- PrintTable URL( "lua:/path/to/my/little/lua.file", "yue.file" ), nil
-- PrintTable gpm.url.parse "lua:/path/to/my/little/lua.file", "yue.file"

export default URL
