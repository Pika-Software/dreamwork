import gsub, sub, find, len, lower, match, Extract from gpm.string
import Encode, Decode, ParseQuery, Query from gpm.http
import remove, sort, Empty from gpm.table
import isv4, isv6 from gpm.ip
import Resolve from gpm.path

setmetatable = setmetatable
tostring = tostring
isstring = isstring
istable = istable
rawget = rawget
rawset = rawset
error = error
pairs = pairs

--[[

    URL Object by Unknown Developer

    References:
        https://developer.mozilla.org/en-US/docs/Web/API/URL
        https://github.com/nodejs/node/blob/main/doc/api/url.md
        https://github.com/golgote/neturl/blob/master/lib/net/url.lua

--]]

local encodeFilePathPart
do

    pathSymbols = "%!%$%&%'%(%)%*%,%-%.%:%;%=%@%_%~"

    encodeFilePathPart = ( str ) ->
        return Encode( Decode( str ), pathSymbols )

services = {
    ftp: "21"
    ssh: "22"
    sftp: "22"
    telnet: "23"
    smtp: "25"
    tftp: "69"
    gopher: "70"
    http: "80"
    ws: "80"
    nntp: "119"
    snmp: "161"
    imap: "143"
    prospero: "191"
    ldap: "389"
    https: "443"
    wss: "443"
    smtps: "465"
    videotex: "516"
    rtsp: "554"
    vemmi: "575"
    starttls: "587"
    ipp: "631"
    acap: "674"
    rsync: "873"
    cap: "1026"
    mtqp: "1038"
    icap: "1344"
    afs: "1483"
    news: "2009"
    nfs: "2049"
    dict: "2628"
    mupdate: "3905"
    iax: "4569"
    sip: "5060"
    jms: "5673"
}

meta = {
    Services: services
}

do

    getmetatable = getmetatable

    meta.__eq = ( a, b ) ->
        return getmetatable( b ) == meta and b.href == a.href

meta.__index = ( key ) =>
    return meta[ key ] or rawget( @, "metadata" )[ key ]

build = =>
    metadata = rawget( @, "metadata" )
    url = metadata.protocol

    if len( metadata.host ) ~= 0
        url ..= "//"

    username = metadata.username
    if len( username ) ~= 0
        url ..= username

        password = metadata.password
        if len( password ) ~= 0
            url ..= ":" .. password

        url ..= "@"

    hostname = metadata.hostname
    if len( hostname ) ~= 0
        url ..= hostname

        port = metadata.port
        if len( port ) ~= 0 and port ~= services[ metadata.scheme ]
            url ..= ":" .. port

    return url .. metadata.pathname .. @searchParams\toString! .. metadata.hash

meta.__tostring = build
meta.build = build

parse = ( url, ... ) =>
    metadata = rawget( @, "metadata" )
    Empty( metadata )

    -- protocol & scheme
    url, protocol = Extract( url, "^(.-:)" )

    unless protocol
        metadata.pathname = gsub( Resolve( url, ... ), "([^/]+)", encodeFilePathPart )
        metadata.href = build( @ )
        metadata.origin = "null"
        return

    protocol = lower( protocol )
    metadata.protocol = protocol

    scheme = sub( protocol, 1, -2 )

    unless find( scheme, "^[a-z].*%w$" )
        error "Invalid URL scheme: \"" .. scheme .. "\"", 4

    metadata.scheme = scheme

    -- hash
    url, metadata.hash = Extract( url, "(#.*)$" )

    -- search
    url, search = Extract( url, "(%?.*)$", "" )
    metadata.search = search

    if search
        @searchParams\parse( sub( search, 2 ) )
    else
        @searchParams\clear!

    -- '//' formatter
    if services[ scheme ]
        url = gsub( url, "^/*", "//" )
    else
        url = gsub( url, "^//+", "//" )

    -- 'data' like schemes
    if match( url, "^(.-:)//" )
        metadata.pathname = url
        metadata.origin = "null"
        metadata.href = protocol .. url .. search .. metadata.hash
        return

    -- authority
    url, authority = Extract( url, "^//([^/]+)" )
    if authority
        -- host & auth
        host, auth = Extract( authority, "^([^@]*)@" )
        if len( host ) == 0
            error "URL host is missing!", 4

        -- username & password
        if auth and len( auth ) ~= 0
            usernameEnd = find( auth, ":" )
            if usernameEnd
                metadata.username = Encode( Decode( sub( auth, 1, usernameEnd - 1 ) ) )
                metadata.password = Encode( Decode( sub( auth, usernameEnd + 1 ) ) )
            else
                metadata.username = Encode( Decode( auth ) )

        -- hostname
        hostname, port = Extract( host, ":(.+)" )

        length = len( hostname )
        if length == 0
            error "URL hostname is missing!", 4

        elseif length < 2
            error "URL hostname is too short!", 4

        elseif length > 63
            error "URL hostname is too long!", 4

        if isv4( hostname )
            unless isv4( hostname, true )
                error "Invalid IPv4 hostname address: \"" .. hostname .. "\".", 4

        elseif isv6( hostname )
            unless isv6( hostname, true )
                error "Invalid IPv6 hostname address: \"" .. hostname .. "\".", 4

        else
            hostname = Encode( Decode( hostname ), "%-%." )

        metadata.hostname = hostname

        -- port
        if port
            if find( port, "^[0-9]+$" )
                host = hostname .. ":" .. port
            else
                error "Invalid URL port: \"" .. port .. "\"", 4
        else
            host = hostname

        metadata.port = port

        -- host & origin
        if services[ scheme ]
            metadata.origin = protocol .. "//" .. host
        else
            metadata.origin = "null"

        metadata.host = host
    else
        metadata.origin = "null"

    -- pathname & href
    metadata.pathname = gsub( Resolve( url, ... ), "([^/]+)", encodeFilePathPart )
    metadata.href = build( @ )
    return

meta.parse = parse

rebuild = =>
    parse( @, build( @ ) )
    return @

meta.rebuild = rebuild

local URLSearchParams
do

    abcSort = ( a, b ) ->
        return a[ 1 ] < b[ 1 ]

    class URLSearchParams
        new: ( queryData ) =>
            @query, @size = {}, 0

            if queryData
                @parse( queryData )

            return

        __tostring: =>
            return @toString!

        toString: =>
            return Query( @query, @size )

        append: ( key, value ) =>
            size = @size + 1
            @query[ size ] = { key, value }
            @size = size

        delete: ( key ) =>
            query, size = @query, @size
            ::back::

            for index = 1, size
                if query[ index ][ 1 ] == key
                    remove( query, index )
                    size -= 1
                    goto back

            @size = size

        set: ( key, value ) =>
            @delete( key )
            @append( key, value )
            return

        merge: ( tbl ) =>
            for key, value in pairs( tbl )
                @set( key, value )

        get: ( key ) =>
            query = @query
            for index = 1, @size
                if query[ index ][ 1 ] == key
                    return query[ index ][ 2 ]

        getAll: ( key ) =>
            buffer, length = {}, 0
            query = @query

            for index = 1, @size
                if query[ index ][ 1 ] == key
                    length += 1
                    buffer[ length ] = query[ index ][ 2 ]

            return buffer, length

        clear: =>
            query = @query
            for index = 1, @size
                query[ index ] = nil

            @size = 0

        parse: ( queryData ) =>
            @clear!

            if istable( queryData )
                for key, value in pairs( queryData )
                    @append( key, value )

            elseif isstring( queryData )
                for _, data in ipairs( ParseQuery( queryData ) )
                    @append( data[ 1 ], data[ 2 ] )

        has: ( ... ) =>
            for key in *{ ... }
                if @get( key ) == nil
                    return false

            return true

        entries: =>
            query, size = @query, @size
            index = 0

            return ->
                index += 1
                if index > size
                    return

                data = query[ index ]
                return data[ 1 ], data[ 2 ]

        keys: =>
            query, size = @query, @size
            index = 0

            return ->
                index += 1
                if index > size
                    return

                return query[ index ][ 1 ]

        values: =>
            query, size = @query, @size
            index = 0

            return ->
                index += 1
                if index > size
                    return

                return query[ index ][ 2 ]

        forEach: ( callback, thisArg ) =>
            query = @query
            if thisArg == nil
                for index = 1, @size
                    data = query[ index ]
                    callback( data[ 1 ], data[ 2 ], @ )

                return

            for index = 1, @size
                data = query[ index ]
                callback( thisArg, data[ 1 ], data[ 2 ], @ )

        sort: ( sortFunc ) =>
            return sort( @query, sortFunc or abcSort )

gpm.URLSearchParams = URLSearchParams

metadataMeta = {
    __index: ->
        return ""
}

URL = setmetatable {
    __name: "URL"
    __base: meta
    __init: ( ... ) =>
        rawset( @, "metadata", setmetatable( {}, metadataMeta ) )
        rawset( @, "searchParams", URLSearchParams( "" ) )
        parse( @, ... )
        return
}, {
    __index: meta
    __call: ( cls, ... ) ->
        obj = setmetatable( {}, meta )
        cls.__init( obj, ... )
        return obj
}

meta.__class = URL
gpm.URL = URL

do

    changeableValues = {
        protocol: true
        scheme: true

        hash: true

        search: true

        username: true
        password: true

        host: true

        hostname: true
        port: true

        pathname: true

        href: true
    }

    meta.__newindex = ( key, value ) =>
        unless changeableValues[ key ]
            return

        metadata = rawget( @, "metadata" )
        value = tostring( value )

        if key == "protocol"
            scheme = lower( match( value, "(.*):?" ) )
            metadata.port = services[ scheme ] or ( len( metadata.port ) ~= 0 and metadata.port )
            metadata.scheme = scheme
            value = scheme .. ":"

        elseif key == "scheme"
            value = lower( value )
            metadata.protocol = value .. ":"

        elseif key == "hash"
            value = "#" .. match( value, "#?(.*)" )

        elseif key == "search"
            value = "?" .. match( value, "%??(.*)" )
            @searchParams\parse( sub( value, 2 ) )

        elseif key == "username" or key == "password"
            if len( metadata.host ) == 0
                return

            value = Encode( Decode( value ) )

        elseif key == "host"
            if len( value ) == 0
                metadata.origin = "null"
                metadata.hostname = ""
                metadata.port = ""
            else

                -- hostname
                hostname, port = Extract( value, ":(.+)" )

                length = len( hostname )
                if length == 0
                    error "URL hostname is missing!", 2

                elseif length < 2
                    error "URL hostname is too short!", 2

                elseif length > 63
                    error "URL hostname is too long!", 2

                if isv4( hostname )
                    unless isv4( hostname, true )
                        error "Invalid IPv4 hostname address: \"" .. hostname .. "\".", 2

                elseif isv6( hostname )
                    unless isv6( hostname, true )
                        error "Invalid IPv6 hostname address: \"" .. hostname .. "\".", 2

                else
                    hostname = Encode( Decode( hostname ), "%-%." )

                metadata.hostname = hostname

                -- port
                if port
                    if find( port, "^[0-9]+$" )
                        value = hostname .. ":" .. port
                    else
                        error "Invalid URL port: \"" .. port .. "\"", 2
                else
                    value = hostname

                metadata.port = port

                -- origin
                if services[ metadata.scheme ]
                    metadata.origin = metadata.protocol .. "//" .. value
                else
                    metadata.origin = "null"

        elseif key == "pathname"
            value = gsub( Resolve( value ), "([^/]+)", encodeFilePathPart )

        elseif key == "hostname"
            if len( metadata.port ) == 0
                @host = value
            else
                @host = value .. ":" .. metadata.port

            return

        elseif key == "port"
            if not find( value, "^[0-9]+$" )
                error "Invalid URL port: \"" .. value .. "\"", 2

            @host = metadata.hostname .. ":" .. value
            return

        elseif key == "href"
            return parse( @, value )

        metadata[ key ] = value
        -- return rebuild( @ )
        return @

export default URL
