import gsub, sub, find, format, len, lower, match, Extract from gpm.string
import Encode, Decode, ParseQuery, Query from gpm.http
import remove, sort, Empty from gpm.table
import isv4, isv6 from gpm.ip
import Resolve from gpm.path

setmetatable = setmetatable
tostring = tostring
isstring = isstring
istable = istable
rawget = rawget
rawset = rawset
error = error
pairs = pairs

--[[

    URL Object by Unknown Developer

    References:
        https://developer.mozilla.org/en-US/docs/Web/API/URL
        https://github.com/nodejs/node/blob/main/doc/api/url.md
        https://github.com/golgote/neturl/blob/master/lib/net/url.lua

--]]

local encodeFilePathPart
do

    pathSymbols = "%!%$%&%'%(%)%*%,%-%.%:%;%=%@%_%~"

    encodeFilePathPart = ( str ) ->
        return Encode( Decode( str ), pathSymbols )

services = {
    ftp: "21"
    ssh: "22"
    sftp: "22"
    telnet: "23"
    smtp: "25"
    tftp: "69"
    gopher: "70"
    http: "80"
    ws: "80"
    nntp: "119"
    snmp: "161"
    imap: "143"
    prospero: "191"
    ldap: "389"
    https: "443"
    wss: "443"
    smtps: "465"
    videotex: "516"
    rtsp: "554"
    vemmi: "575"
    starttls: "587"
    ipp: "631"
    acap: "674"
    rsync: "873"
    cap: "1026"
    mtqp: "1038"
    icap: "1344"
    afs: "1483"
    news: "2009"
    nfs: "2049"
    dict: "2628"
    mupdate: "3905"
    iax: "4569"
    sip: "5060"
    jms: "5673"
}

meta = {
    VERSION: "1.0.0"
    Services: services
    __tostring: =>
        return @href
}

do

    getmetatable = getmetatable

    meta.__eq = ( a, b ) ->
        return getmetatable( b ) == meta and b.href == a.href

meta.__index = ( key ) =>
    return meta[ key ] or rawget( @, "metadata" )[ key ]

build = =>
    metadata = rawget( @, "metadata" )
    url = metadata.protocol

    if len( metadata.host ) ~= 0
        url ..= "//"

    username = metadata.username
    if len( username ) ~= 0
        url ..= username

        password = metadata.password
        if len( password ) ~= 0
            url ..= ":" .. password

        url ..= "@"

    hostname = metadata.hostname
    if len( hostname ) ~= 0
        url ..= hostname

        port = metadata.port
        if len( port ) ~= 0 and port ~= services[ metadata.scheme ]
            url ..= ":" .. port

    return format( "%s%s%s%s", url, metadata.pathname, @searchParams\toString!, metadata.hash )

meta.build = build

parse = ( url, ... ) =>
    metadata = rawget( @, "metadata" )
    Empty( metadata )

    -- replace backslashes with slashes
    url = gsub( url, "\\", "/" )

    -- protocol & scheme
    url, protocol = Extract( url, "^(.-:)" )

    unless protocol
        error "URL protocol is missing!", 4

    protocol = lower( protocol )
    metadata.protocol = protocol

    scheme = sub( protocol, 1, -2 )

    unless find( scheme, "^[a-z].*%w$" )
        error format( "Invalid URL scheme: \"%s\"", scheme ), 4

    metadata.scheme = scheme

    -- hash
    url, metadata.hash = Extract( url, "(#.*)$" )

    -- search
    url, search = Extract( url, "(%?.*)$", "" )
    metadata.search = search

    if search
        @searchParams\parse( sub( search, 2 ), @, true )
    else
        @searchParams\clear( true )

    -- '//' formatter
    if services[ scheme ]
        url = gsub( url, "^/*", "//" )
    else
        url = gsub( url, "^//+", "//" )

    -- 'data' like schemes
    if match( url, "^(.-:)//" )
        metadata.pathname = url
        metadata.origin = "null"
        metadata.href = protocol .. url .. search .. metadata.hash
        return

    -- authority
    url, authority = Extract( url, "^//([^/]+)" )
    if authority
        -- host & auth
        host, auth = Extract( authority, "^([^@]*)@" )
        if len( host ) == 0
            error "URL host is missing!", 4

        -- username & password
        if auth and len( auth ) ~= 0
            usernameEnd = find( auth, ":" )
            if usernameEnd
                metadata.username = Encode( Decode( sub( auth, 1, usernameEnd - 1 ) ) )
                metadata.password = Encode( Decode( sub( auth, usernameEnd + 1 ) ) )
            else
                metadata.username = Encode( Decode( auth ) )

        -- host & origin
        if services[ scheme ]
            metadata.origin = protocol .. "//" .. host
        else
            metadata.origin = "null"

        metadata.host = host

        -- hostname
        hostname, port = Extract( host, ":(.+)" )
        if len( hostname ) == 0
            error "URL hostname is missing!", 4

        if isv4( hostname )
            ok, msg = isv4( hostname, true )
            unless ok
                error format( "Invalid IPv4 hostname address: \"%s\", %s.", hostname, msg ), 4

        if isv6( hostname )
            ok, msg = isv6( hostname, true )
            unless ok
                error format( "Invalid IPv6 hostname address: \"%s\", %s.", hostname, msg ), 4

        metadata.hostname = hostname

        -- port
        if port and not find( port, "^[0-9]+$" )
            error format( "Invalid URL port: \"%s\"", port ), 4

        metadata.port = port
    else
        metadata.origin = "null"

    -- pathname & href
    if len( metadata.host ) == 0
        metadata.pathname = gsub( Resolve( url, ... ), "([^/]+)", encodeFilePathPart )
    else
        metadata.pathname = gsub( "/" .. Resolve( url, ... ), "([^/]+)", encodeFilePathPart )

    metadata.href = build( @ )
    return

meta.parse = parse

rebuild = =>
    parse( @, build( @ ) )
    return @

meta.rebuild = rebuild

local URLSearchParams
do

    abcSort = ( a, b ) ->
        return a[ 1 ] < b[ 1 ]

    class URLSearchParams
        new: ( queryData, urlObject ) =>
            @query, @size = {}, 0
            @parse( queryData, urlObject, true )

        __tostring: =>
            return @toString!

        toString: =>
            return Query( @query, @size )

        updateURL: =>
            urlObject = @urlObject
            if urlObject
                rebuild( urlObject )

            return

        append: ( key, value, dontUpdate ) =>
            size = @size + 1
            @query[ size ] = { key, value }
            @size = size

            unless dontUpdate
                @updateURL!

            return

        delete: ( key, dontUpdate ) =>
            query, size = @query, @size
            ::back::

            for index = 1, size
                if query[ index ][ 1 ] == key
                    remove( query, index )
                    size -= 1
                    goto back
                    break

            @size = size

            unless dontUpdate
                @updateURL!

            return

        set: ( key, value, dontUpdate ) =>
            @delete( key, true )
            @append( key, value, dontUpdate )
            return

        merge: ( tbl, dontUpdate ) =>
            for key, value in pairs( tbl )
                @set( key, value, true )

            unless dontUpdate
                @updateURL!

            return

        get: ( key ) =>
            query = @query
            for index = 1, @size
                if query[ index ][ 1 ] == key
                    return query[ index ][ 2 ]

        getAll: ( key ) =>
            buffer, length = {}, 0
            query = @query

            for index = 1, @size
                if query[ index ][ 1 ] == key
                    length += 1
                    buffer[ length ] = query[ index ][ 2 ]

            return buffer, length

        clear: ( dontUpdate ) =>
            query = @query
            for index = 1, @size
                query[ index ] = nil

            @size = 0

            unless dontUpdate
                @updateURL!

            return

        parse: ( queryData, urlObject, dontUpdate ) =>
            @urlObject = urlObject
            @clear( true )

            if istable( queryData )
                for key, value in pairs( queryData )
                    @append( key, value, true )

            elseif isstring( queryData )
                for _, data in ipairs( ParseQuery( queryData ) )
                    @append( data[ 1 ], data[ 2 ], true )

            unless dontUpdate
                @updateURL!

            return

        has: ( ... ) =>
            for key in *{ ... }
                if @get( key ) == nil
                    return false

            return true

        entries: =>
            query, size = @query, @size
            index = 0

            return ->
                index += 1
                if index > size
                    return

                data = query[ index ]
                return data[ 1 ], data[ 2 ]

        keys: =>
            query, size = @query, @size
            index = 0

            return ->
                index += 1
                if index > size
                    return

                return query[ index ][ 1 ]

        values: =>
            query, size = @query, @size
            index = 0

            return ->
                index += 1
                if index > size
                    return

                return query[ index ][ 2 ]

        forEach: ( callback, thisArg ) =>
            query = @query
            if thisArg == nil
                for index = 1, @size
                    data = query[ index ]
                    callback( data[ 1 ], data[ 2 ], @ )

                return

            for index = 1, @size
                data = query[ index ]
                callback( thisArg, data[ 1 ], data[ 2 ], @ )

            return

        sort: ( dontUpdate, sortFunc ) =>
            sort( @query, sortFunc or abcSort )

            unless dontUpdate
                @updateURL!

            return

gpm.URLSearchParams = URLSearchParams

metadataMeta = {
    __index: ->
        return ""
}

URL = setmetatable {
    __name: "URL"
    __base: meta
    __init: ( ... ) =>
        rawset( @, "metadata", setmetatable( {}, metadataMeta ) )
        rawset( @, "searchParams", URLSearchParams( "", @ ) )
        parse( @, ... )
        return
}, {
    __index: meta
    __call: ( cls, ... ) ->
        obj = setmetatable( {}, meta )
        cls.__init( obj, ... )
        return obj
}

meta.__class = URL
gpm.URL = URL

do

    changeableValues = {
        protocol: true
        scheme: true

        hash: true

        search: true

        username: true
        password: true

        host: true

        hostname: true
        port: true

        pathname: true

        href: true
    }

    meta.__newindex = ( key, value ) =>
        unless changeableValues[ key ]
            return

        metadata = rawget( @, "metadata" )
        value = tostring( value )

        if key == "protocol"
            scheme = lower( match( value, "(.*):?" ) )
            metadata.port = services[ scheme ] or ( len( metadata.port ) ~= 0 and metadata.port )
            metadata.scheme = scheme
            value = scheme .. ":"

        elseif key == "scheme"
            value = lower( value )
            metadata.protocol = value .. ":"

        elseif key == "hash"
            value = "#" .. match( value, "#?(.*)" )

        elseif key == "search"
            value = "?" .. match( value, "%??(.*)" )
            @searchParams\parse( sub( value, 2 ), @, true )

        elseif key == "username" or key == "password"
            value = Encode( Decode( value ) )

        elseif key == "host"
            if len( value ) == 0
                error "URL host is missing!", 2

            -- origin
            if services[ metadata.scheme ]
                metadata.origin = metadata.protocol .. "//" .. value
            else
                metadata.origin = "null"

            -- hostname
            hostname, port = Extract( value, ":(.+)" )
            if len( hostname ) == 0
                error "URL hostname is missing!", 2

            if isv4( hostname )
                ok, msg = isv4( hostname, true )
                unless ok
                    error format( "Invalid IPv4 hostname address: \"%s\", %s.", hostname, msg ), 2

            if isv6( hostname )
                ok, msg = isv6( hostname, true )
                unless ok
                    error format( "Invalid IPv6 hostname address: \"%s\", %s.", hostname, msg ), 2

            metadata.hostname = hostname

            -- port
            if port and not find( port, "^[0-9]+$" )
                error format( "Invalid URL port: \"%s\"", port ), 2

            metadata.port = port

        elseif key == "pathname"
            if len( metadata.host ) == 0
                value = gsub( Resolve( value ), "([^/]+)", encodeFilePathPart )
            else
                value = gsub( "/" .. Resolve( value ), "([^/]+)", encodeFilePathPart )

        elseif key == "href"
            return parse( @, value )

        metadata[ key ] = value
        return rebuild( @ )

--// Tests //-->

-- url = URL( "http://google.com/index.html" )

-- url.protocol = "https"
-- url.scheme = "yep"

-- url.hash = "#tag"
-- url.hash = "tag"

-- url.search = "?query=123&a=1&b=2"
-- url.searchParams = nil

-- url.username = "cool-guy"
-- url.password = "secret"

-- url.host = "hell.com"

-- url.hostname = "localhost"
-- url.port = 27015

-- url.pathname = "garrysmod/lua/autorun/../init.lua"

-- url.href = "http://localhost:27015/garrysmod/lua/autorun/../init.lua"

-- url.searchParams\replace( { a: 1, b: 2 } )
-- url.searchParams\delete "a"
-- url.searchParams\set "a", 5

-- url.searchParams\merge { c: 3, d: 4 }
-- print url.searchParams\get "a"

-- url.searchParams\set "a", { 1, 2, 3, 4 }

-- PrintTable url

-- PrintTable URL( "lua:/path/to/my/little/lua.file", "yue.file" ), nil
-- PrintTable gpm.url.parse "lua:/path/to/my/little/lua.file", "yue.file"

export default URL
