import gsub, sub, find, format, len, lower, match from gpm.string
import Encode, Decode, ParseQuery, Query from gpm.http
import insert, Merge from gpm.table
import isv4, isv6 from gpm.ip
import Resolve from gpm.path

setmetatable = setmetatable
tostring = tostring
rawget = rawget
rawset = rawset
error = error
pairs = pairs

--[[

    URL Object by Unknown Developer

    References:
        https://developer.mozilla.org/en-US/docs/Web/API/URL
        https://github.com/nodejs/node/blob/main/doc/api/url.md
        https://github.com/golgote/neturl/blob/master/lib/net/url.lua

--]]

pathSymbols = "%!%$%&%'%(%)%*%,%-%.%:%;%=%@%_%~"

services = {
    ftp: "21"
    ssh: "22"
    sftp: "22"
    telnet: "23"
    smtp: "25"
    tftp: "69"
    gopher: "70"
    http: "80"
    ws: "80"
    nntp: "119"
    snmp: "161"
    imap: "143"
    prospero: "191"
    ldap: "389"
    https: "443"
    wss: "443"
    smtps: "465"
    videotex: "516"
    rtsp: "554"
    vemmi: "575"
    starttls: "587"
    ipp: "631"
    acap: "674"
    rsync: "873"
    cap: "1026"
    mtqp: "1038"
    icap: "1344"
    afs: "1483"
    news: "2009"
    nfs: "2049"
    dict: "2628"
    mupdate: "3905"
    iax: "4569"
    sip: "5060"
    jms: "5673"
}

local parse, build

rebuild = ( data ) ->
    parse( data, build( data ) )
    return

class URLSearchParams
    new: ( str, data ) =>
        rawset( @, "__query", {} )
        @parse( str, data, true )

    __tostring: =>
        return Query( @__query )

    toString: =>
        return Query( rawget( @, "__query" ) )

    parse: ( str, data, ignoreData ) =>
        query = rawget( @, "__query" )
        for key in pairs( query )
            rawset( query, key, nil )

        for key, value in pairs( ParseQuery( str ) )
            rawset( query, key, value )

        if data
            rawset( @, "__data", data )

        @update( ignoreData )
        return

    update: ( ignoreData ) =>
        unless ignoreData
            data = rawget( @, "__data" )
            if data
                rebuild( data )

        size = 0
        for _ in pairs( rawget( @, "__query" ) )
            size += 1

        rawset( @, "size", size )
        return

    has: ( ... ) =>
        query = rawget( @, "__query" )
        for key in *{ ... }
            unless query[ key ]
                return false

        return true

    keys: =>
        query, key = rawget( @, "__query" ), nil
        return ->
            key = next( query, key )
            return key

    values: =>
        query, key = rawget( @, "__query" ), nil
        return ->
            key, value = next( query, key )
            return value

    entries: =>
        return next, rawget( @, "__query" )

    get: ( key ) =>
        return rawget( rawget( @, "__query" ), key )

    set: ( key, value ) =>
        rawset( rawget( @, "__query" ), key, value )
        @update!

    merge: ( tbl ) =>
        Merge( rawget( @, "__query" ), tbl )
        @update!

    replace: ( tbl ) =>
        query = rawget( @, "__query" )
        for key in pairs( tbl )
            rawset( query, key, nil )

        for key, value in pairs( tbl )
            rawset( query, key, value )

        @update!

    getAll: ( key ) =>
        query = rawget( @, "__query" )
        if istable( query[ key ] )
            return query[ key ]

        return { query[ key ] }

    append: ( key, value ) =>
        query = rawget( @, "__query" )
        tbl = query[ key ]
        unless istable( tbl )
            query[ key ] = { tbl }

        if istable( value )
            query[ key ] = Merge( tbl, value )
        else
            insert( tbl, 1, value )

        @update!

    delete: ( key ) =>
        rawset( rawget( @, "__query" ), key, nil )
        @update!

    clear: =>
        query = rawget( @, "__query" )
        for key in pairs( query )
            rawset( query, key, nil )

        @update!

build = ( data ) ->
    url = data.protocol .. "//"

    username = data.username
    if username and len( username ) ~= 0
        url ..= username

        password = data.password
        if password and len( password ) ~= 0
            url ..= ":" .. password

        url ..= "@"

    hostname = data.hostname
    if hostname and len( hostname ) ~= 0
        url ..= hostname

        port = data.port
        if port and len( port ) ~= 0
            if port ~= services[ data.scheme ]
                url ..= ":" .. port

    url ..= data.pathname or "/"

    if data.searchParams
        url ..= tostring( data.searchParams )

    if data.hash
        url ..= data.hash

    return url

parse = ( data, url, ... ) ->
    for key in pairs( data )
        if key ~= "searchParams"
            data[ key ] = nil

    -- protocol & scheme
    local protocol, scheme
    url = gsub url, "^(.-:)", ( str ) ->
        str = lower( str )
        scheme = sub( str, 1, -2 )
        protocol = str
        return ""

    unless protocol
        error "URL protocol is missing!", 3

    data.protocol = protocol

    unless find( scheme, "^[a-z].*%w$" )
        error format( "Invalid URL scheme: \"%s\"", scheme ), 3

    data.scheme = scheme

    -- hash
    url = gsub url, "(#.*)$", ( hash ) ->
        data.hash = hash
        return ""

    -- search & searchParams
    unless data.searchParams
        data.searchParams = URLSearchParams( "", data )

    url = gsub url, "(%?.*)$", ( str ) ->
        data.search = str
        return ""

    if data.search
        data.searchParams\parse( sub( data.search, 2 ), data, true )
    else
        data.searchParams\parse( "", data, true )

    -- specific schemes
    if services[ scheme ]
        unless sub( url, 1, 2 ) == "//"
            url = "//" .. url

    elseif match( url, "^(.-:)/*" )
        data.pathname = url

        if data.search
            url ..= data.search

        if data.hash
            url ..= data.hash

        data.href = protocol .. url
        return

    -- host
    url = gsub url, "^//([^/]+)", ( host ) ->
        -- username & password
        host = gsub host, "^([^@]*)@", ( auth ) ->
            usernameEnd = find( auth, ":" )
            if usernameEnd
                data.username = Decode( sub( auth, 1, usernameEnd - 1 ) )
                data.password = Decode( sub( auth, usernameEnd + 1 ) )
            else
                data.username = Decode( auth )

            return ""

        if len( host ) == 0
            error "URL host is missing!", 6

        -- host & origin
        data.origin = protocol .. "//" .. host
        data.host = host

        -- hostname
        local port
        hostname = gsub host, ":(.+)", ( str ) ->
            port = str
            return ""

        if len( hostname ) == 0
            error "URL hostname is missing!", 6

        if isv4( hostname )
            ok, msg = isv4( hostname, true )
            unless ok
                error format( "Invalid IPv4 hostname address: \"%s\", %s.", hostname, msg ), 6

        if isv6( hostname )
            ok, msg = isv6( hostname, true )
            unless ok
                error format( "Invalid IPv6 hostname address: \"%s\", %s.", hostname, msg ), 6

        data.hostname = hostname

        -- port
        if port
            if find( port, "^[0-9]+$" )
                data.port = port
            else
                error format( "Invalid URL port: \"%s\"", port ), 6
        else
            data.port = services[ scheme ]

        return ""

    -- pathname
    data.pathname = gsub "/" .. Resolve( url, ... ), "([^/]+)", ( part ) ->
        return Encode( Decode( part ), pathSymbols )

    data.href = build( data )
    return

changeableValues = {
    protocol: true
    scheme: true

    hash: true

    search: true

    username: true
    password: true

    host: true

    hostname: true
    port: true

    pathname: true

    href: true
}

class URL
    VERSION: "1.0.0"
    Services: services

    new: ( ... ) =>
        data = {}
        parse( data, ... )
        rawset( @, "__data", data )
        return

    __index: ( key ) =>
        return rawget( rawget( @, "__data" ), key ) or ( changeableValues[ key ] and "" )

    __newindex: ( key, value ) =>
        unless changeableValues[ key ]
            return

        value = tostring( value )

        data = @__data
        switch key
            when "protocol"
                scheme = lower( match( value, "(.*):?" ) )
                data.scheme = scheme
                value = scheme .. ":"

            when "scheme"
                value = lower( value )
                data.protocol = value .. ":"

            when "hash"
                value = "#" .. match( value, "#?(.*)" )

            when "search"
                value = "?" .. match( value, "%??(.*)" )
                data.searchParams\parse( sub( value, 2 ), data, true )

            when "username"
                value = Encode( value )

            when "password"
                value = Encode( value )

            when "host"
                if len( value ) == 0
                    error "URL host is missing!", 2

                data.origin = data.protocol .. "//" .. value

                -- hostname
                local port
                hostname = gsub value, ":(.+)", ( str ) ->
                    port = str
                    return ""

                if len( hostname ) == 0
                    error "URL hostname is missing!", 2

                if isv4( hostname )
                    ok, msg = isv4( hostname, true )
                    unless ok
                        error format( "Invalid IPv4 hostname address: \"%s\", %s.", hostname, msg ), 2

                if isv6( hostname )
                    ok, msg = isv6( hostname, true )
                    unless ok
                        error format( "Invalid IPv6 hostname address: \"%s\", %s.", hostname, msg ), 2

                data.hostname = hostname

                -- port
                if port
                    if find( port, "^[0-9]+$" )
                        data.port = port
                    else
                        error format( "Invalid URL port: \"%s\"", port ), 2
                else
                    data.port = services[ scheme ]

            when "pathname"
                value = gsub "/" .. Resolve( value ), "([^/]+)", ( part ) ->
                    return Encode( Decode( part ), pathSymbols )

            when "href"
                return parse( data, value )

        data[ key ] = value
        return rebuild( data )

    __tostring: =>
        return @href

    __eq: ( other ) =>
        return other and @href == other.href

--// Tests //-->

-- url = URL( "http://google.com/index.html" )

-- url.protocol = "https"
-- url.scheme = "yep"

-- url.hash = "#tag"
-- url.hash = "tag"

-- url.search = "?query=123&a=1&b=2"
-- url.searchParams = nil

-- url.username = "cool-guy"
-- url.password = "secret"

-- url.host = "hell.com"

-- url.hostname = "localhost"
-- url.port = 27015

-- url.pathname = "garrysmod/lua/autorun/../init.lua"

-- url.href = "http://localhost:27015/garrysmod/lua/autorun/../init.lua"

-- url.searchParams\replace( { a: 1, b: 2 } )
-- url.searchParams\delete "a"
-- url.searchParams\set "a", 5

-- url.searchParams\merge { c: 3, d: 4 }
-- print url.searchParams\get "a"

-- PrintTable url

-- PrintTable URL( "lua:/path/to/my/little/lua.file", "yue.file" ), nil
-- PrintTable gpm.url.parse "lua:/path/to/my/little/lua.file", "yue.file"

export default URL
