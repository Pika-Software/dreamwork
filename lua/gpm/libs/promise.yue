--[[
    MIT License

    Copyright (c) 2023 Retro

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
--]]
import create, resume, running, yield from coroutine
import TypeError, RuntimeError, iscallable from gpm
import format, match, rep from string
import Simple from timer
isstring = isstring
tostring = tostring
istable = istable
pcall = pcall

getThenable = ( obj ) ->
    thenFunc = obj.Then or obj.next
    return iscallable( thenFunc ) and thenFunc

getAwaitable = ( obj ) ->
    awaitable = obj.Await or obj.await
    return iscallable( awaitable ) and awaitable

once = ->
    wasCalled = false

    return ( wrapped_fn ) ->
        return ( ... ) ->
            if wasCalled
                return ...

            wasCalled = true
            return wrapped_fn( ... )

local captureStack
do

    import getinfo from debug

    captureStack = ( startPos ) ->
        stack, length = {}, 0

        for level = 1 + ( startPos or 1 ), 16
            info = getinfo( level, "Snl" )
            unless info
                break

            length += 1
            stack[ length ] = info

        return stack, length

local errorWithCustomStack
do

    import concat from table

    errorWithCustomStack = ( err, stack ) ->
        lines, length = { "[gm_promise] Unhandled rejected promise: " .. tostring( err ) }, 1

        for index = 1, #stack
            length += 1
            info = stack[ index ]
            lines[ length ] = format( "%s%d. %s - %s:%d", rep( " ", index * 2 ), index, info.name or "unknown", info.short_src, info.currentline )

        return concat( lines, "\n", 1, length ) .. "\n\n"

-- Promise state constants
STATE_PENDING = 1
STATE_FULFILLED = 2
STATE_REJECTED = 3

local Promise

isPromise = ( obj ) ->
    return istable( obj ) and obj.__class == Promise

local finalize

reject = ( reason ) =>
    if @state ~= STATE_PENDING
        return

    @state = STATE_REJECTED
    @reason = reason

    -- @reject_stack = captureStack!
    -- if @stack[#@stack].currentline == @reject_stack[#@reject_stack].currentline
    --     @reject_stack = {}

    finalize( @ )
    return

local finalizePromise, fulfill, resolveThenable

resolve = ( value ) =>
    if @state ~= STATE_PENDING
        return

    if value == @
        reject( @, TypeError "Cannot resolve a promise with itself" )
        return

    @on_fulfilled = nil
    @on_rejected = nil
    @on_finally = nil

    @resolving = true

    if istable( value )
        if value.__class == Promise
            if value.state == STATE_PENDING
                :queue = value
                unless queue
                    queue = {}
                    value.queue = queue

                queue[] = @
                return

            finalizePromise( value, @ )
            return

        ok, thenable = pcall( getThenable, value )
        unless ok
            reject( @, thenable )
            return

        if thenable
            resolveThenable( @, value, thenable )
            return

    fulfill( @, value )
    return

do

    finalizeFunc = ( p ) =>
        switch @state
            when STATE_FULFILLED
                :on_fulfilled = p
                if on_fulfilled
                    resolve( p, on_fulfilled( @value ) )
                else
                    resolve( p, @value )

            when STATE_REJECTED
                :on_rejected = p
                if on_rejected
                    resolve( p, on_rejected( @reason ) )
                else
                    reject( p, @reason )

        :on_finally = p
        if on_finally
            on_finally!

        return

    finalizePromise = ( p ) =>
        success, err = pcall( finalizeFunc, @, p )
        if success
            return

        reject( p, err )
        return

finalize = =>
    if @state == STATE_PENDING
        return

    Simple 0, ->
        :queue = @
        if queue
            index = 1
            while queue[ index ]
                finalizePromise( @, queue[ index ] )
                queue[ index ] = nil
                index += 1

        -- elseif @state == STATE_REJECTED
        --     final_stack = table.Add {}, @reject_stack
        --     ErrorNoHalt errorWithCustomStack( @reason, table.Add final_stack, @stack )

        return

    return

fulfill = ( value ) =>
    @state = STATE_FULFILLED
    @value = value
    finalize( @ )
    return

resolveThenable = ( obj, thenable ) =>
    once_wrapper = once!

    onFulfill = once_wrapper ( value ) ->
        resolve( @, value )
        return

    onReject = once_wrapper ( reason ) ->
        reject( @, reason )
        return

    ok, err = pcall( thenable, obj, onFulfill, onReject )
    if ok
        return

    onReject( err )
    return

resolvedPromise = ( value ) ->
    p = Promise!
    p\Resolve( value )
    return p

rejectedPromise = ( reason ) ->
    p = Promise!
    p\Reject( reason )
    return p

thenFunc = ( on_fulfilled, on_rejected, on_finally ) =>
    p = Promise!

    if iscallable( on_fulfilled )
        p.on_fulfilled = on_fulfilled

    if iscallable( on_rejected )
        p.on_rejected = on_rejected

    if iscallable( on_finally )
        p.on_finally = on_finally

    :queue = @
    unless queue
        queue = {}
        @queue = queue

    queue[] = p
    finalize( @ )
    return p

all = ( promises ) ->
    p = Promise!
    results = {}

    count = #promises
    if count == 0
        p\Resolve( results )
        return p

    failed = false

    failFunc = ( reason ) ->
        if failed
            return

        p\Reject( reason )
        failed = true
        return

    for index = 1, count
        if failed
            break

        promise = promises[ index ]
        if isPromise( promise )
            thenFunc( promise, ( value ) ->
                results[ index ] = value
                count -= 1

                if count == 0
                    p\Resolve( results )

                return

            failFunc )
        else
            results[ index ] = promise
            count -= 1

            if count == 0
                p\Resolve( results )

    return p

allSettled = ( promises ) ->
    p = Promise!
    results = {}

    count = #promises
    if count == 0
        p\Resolve( results )
        return p

    for index = 1, count
        thenFunc( promises[ index ],
            ( value ) ->
                results[ index ] = { status: "fulfilled", :value }
                count -= 1

                if count == 0
                    p\Resolve( results )

                return

            ( reason ) ->
                results[ index ] = { status: "rejected", :reason }
                count -= 1

                if count == 0
                    p\Resolve( results )

                return
        )

    return p

any = ( promises ) ->
    p = Promise!

    count = #promises
    if count == 0
        p\Reject( "No promises to resolve" )
        return p

    reasons = {}

    for index = 1, count
        thenFunc promises[ index ], ( value ) ->
            p\Resolve value, ( reason ) ->
                reasons[ index ] = reason
                count -= 1

                if count == 0
                    p\Resolve( reasons )

                return

            return

    return p

race = ( promises ) ->
    p = Promise!

    count = #promises
    if count == 0
        return p

    raceFunc = ( value ) ->
        p\Resolve value, ( reason ) ->
            p\Reject( reason )
            return

        return

    for index = 1, count
        thenFunc( promises[ index ], raceFunc )

    return p

async = ( func ) ->
    return ( ... ) ->
        p = Promise!

        resume( create( ( ... ) ->
            success, result = pcall( func, ... )
            if success
                p\Resolve( result )
                return

            -- TODO: save stacktrace and pass it to reject
            if isstring( result )
                file, line, message = match( result, "^([A-Za-z0-9%-_/.]+):(%d+): (.*)" )
                if file and line
                    result = RuntimeError( message, file, line, 5 )

            p\Reject( result )
            return
        ), ... )

        return p

safeAwait = ( p ) ->
    co = running!
    unless co
        return false, "Cannot await in main thread"

    once_wrapper = once!

    onResolve = once_wrapper ( value ) ->
        resume( co, true, value )
        return

    onReject = once_wrapper ( reason ) ->
        resume( co, false, reason )
        return

    if isPromise( p )
        switch p.state
            when STATE_FULFILLED
                return true, p.value

            when STATE_REJECTED
                return false, p.reason

        thenFunc( p, onResolve, onReject )
        return yield!

    thenable = istable( p ) and getThenable( p )
    if iscallable( thenable )
        pcall( thenable, p, onResolve, onReject )
        return yield!

    return true, p

await = ( p ) ->
    awaitable = istable( p ) and getAwaitable( p )
    if awaitable and not isPromise( p )
        return awaitable( p )

    ok, result = safeAwait( p )
    if ok
        return result

    error( result )
    return

delay = ( seconds, value ) ->
    p = Promise!

    Simple seconds, ->
        p\Resolve( value )
        return

    return p

class Promise
    @VERSION: "2.1.0"
    @AUTHOR: "Retro"
    @URL: "https://github.com/dankmolot/gm_promise"

    :STATE_PENDING
    :STATE_FULFILLED
    :STATE_REJECTED

    IsPromise: isPromise

    new: ( executor ) =>
        @state = STATE_PENDING
        @resolving = false
        -- @value = nil
        -- @reason = nil
        -- @queue = nil -- Queue is created only if then called in pending state
        -- @stack = captureStack( 3 )

        if iscallable( executor )
            @resolving = true

            once_wrapper = once!

            onFulfill = once_wrapper ( value ) ->
                resolve( @, value )
                return

            onReject = once_wrapper ( reason ) ->
                reject( @, reason )
                return

            success, err = pcall( executor, onFulfill, onReject )
            if success
                return

            onReject( err )

        return

    __tostring: =>
        return switch @state
            when STATE_PENDING
                format "Promise %p { <state>: \"pending\" }", @
            when STATE_FULFILLED
                format "Promise %p { <state>: \"fulfilled\", <value>: %s }", @, @value
            when STATE_REJECTED
                format "Promise %p { <state>: \"rejected\", <reason>: %s }", @, @reason
            else
                format "Promise %p { <state>: \"invalid\" }", @

    Resolve: ( value ) =>
        if @resolving
            return

        resolve( @, value )
        return

    Reject: ( reason ) =>
        if @resolving
            return

        reject( @, reason )
        return

    Then: thenFunc

    Catch: ( on_rejected ) =>
        thenFunc( @, nil, on_rejected, nil )
        return

    Finally: ( on_finally ) =>
        thenFunc( @, nil, nil, on_finally )
        return

    @Resolve: resolvedPromise

    @Reject: rejectedPromise

    @All: all

    @AllSettled: allSettled

    @Any: any

    @Race: race

    @Async: async

    SafeAwait: safeAwait

    Await: await

    @Delay: delay

    -- Methods alt names ( lower case )
    @__base.resolve = @__base.Resolve
    @__base.reject = @__base.Reject
    @__base.then = thenFunc
    @__base.next = thenFunc
    @__base.andThen = thenFunc
    @__base.catch = @__base.Catch
    @__base.finally = @__base.Finally
    @__base.saveAwait = safeAwait
    @__base.await = await
    @resolve: resolvedPromise
    @reject: rejectedPromise
    @all: all
    @allSettled: allSettled
    @any: any
    @race: race
    @async: async
    @delay: delay

export default Promise
