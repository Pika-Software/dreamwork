--[[
    MIT License

    Copyright (c) 2023-2024 Retro

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
--]]
_G = _G
import pcall, xpcall from _G
import environment from _G.gpm
import PromiseError, iscallable from environment
import create, resume, yield, running from coroutine
import format, match from _G.string
import Simple from timer

once = ->
    wasCalled = false
    return ( wrappedFn ) ->
        return ( ... ) ->
            if wasCalled
                return ...

            wasCalled = true
            return wrappedFn( ... )

local Promise, isPromise

do

    import getmetatable from _G

    isPromise = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Promise

    environment.ispromise = isPromise

-- Promise states
STATE_PENDING = 1
STATE_FULFILLED = 2
STATE_REJECTED = 3

-- Internal functions
local resolve, reject, finalizePromise
do

    finalizePromiseUnsafe = ( promise, other ) ->
        :state = promise
        if state == STATE_FULFILLED
            if onFulfilled := other.onFulfilled
                resolve( other, onFulfilled( promise.value ) )
            else
                resolve( other, promise.value )

        elseif state == STATE_REJECTED
            if onRejected := other.onRejected
                resolve( other, onRejected( promise.reason ) )
            else
                reject( other, promise.reason )

        if onFinally := other.onFinally
            onFinally!

        return nil

    finalizePromise = ( promise, other ) ->
        success, err = try finalizePromiseUnsafe( promise, other )
        unless success
            reject( other, err )

        return nil

finalize = ( promise ) ->
    if promise.state == STATE_PENDING
        return nil

    Simple 0, ->
        :queue = promise
        if queue
            index = 1

            value = queue[ index ]
            while value
                finalizePromise( promise, value )
                queue[ index ] = nil

                index += 1
                value = queue[ index ]

        return nil

    return nil

reject = ( promise, reason ) ->
    if promise.state ~= STATE_PENDING
        return

    promise.state = STATE_REJECTED
    promise.reason = reason
    finalize( promise )
    return nil

fulfill = ( promise, value ) ->
    promise.state = STATE_FULFILLED
    promise.value = value
    finalize( promise )
    return nil

do

    import TypeError from environment

    resolve = ( promise, value ) ->
        if promise.state ~= STATE_PENDING
            return nil

        if value == promise
            return reject promise, TypeError "Cannot resolve a promise with itself"

        promise.resolving = true
        promise.onFulfilled = nil
        promise.onRejected = nil
        promise.onFinally = nil

        if isPromise( value )
            if value.state == STATE_PENDING
                value.queue = {} unless value.queue
                value.queue[] = promise
            else
                finalizePromise( value, promise )
        else
            fulfill( promise, value )

        return nil

try2resolve = ( promise, value ) ->
    unless promise.resolving
        resolve( promise, value )

    return promise

try2reject = ( promise, reason ) ->
    unless promise.resolving
        reject( promise, reason )

    return promise

__then = ( promise, onFulfilled, onRejected, onFinally ) ->
    p = Promise!
    if iscallable( onFulfilled )
        p.onFulfilled = onFulfilled

    if iscallable( onRejected )
        p.onRejected = onRejected

    if iscallable( onFinally )
        p.onFinally = onFinally

    unless promise.queue
        promise.queue = {}

    promise.queue[] = p
    finalize( promise )
    return p

-- Promise class
class Promise
    new: ( executor ) =>
        @state = STATE_PENDING

        if iscallable( executor )
            @resolving = true
            once_wrapper = once!
            onReject = once_wrapper( ( reason ) -> reject( @, reason ) )
            xpcall( executor, onReject, once_wrapper( ( value ) -> resolve( @, value ) ), onReject )
        else
            @resolving = false

        return nil

    __tostring: =>
        return switch @state
            when STATE_PENDING
                format "Promise %p { <state>: \"pending\" }", @
            when STATE_FULFILLED
                format "Promise %p { <state>: \"fulfilled\", <value>: %s }", @, @value
            when STATE_REJECTED
                format "Promise %p { <state>: \"rejected\", <reason>: %s }", @, @reason
            else
                format "Promise %p { <state>: \"invalid\" }", @

    -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then
    Then: __then

    -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch
    Catch: ( onRejected ) =>
        return __then( @, nil, onRejected )

    -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally
    Finally: ( onFinally ) =>
        return __then( @, nil, nil, onFinally )

-- Promise version information
Promise.VERSION = "2.1.1-gpm"
Promise.AUTHOR = "Pika-Software"
Promise.URL = "https://github.com/dankmolot/gm_promise"

-- Setting locals to class
Promise.STATE_PENDING = STATE_PENDING
Promise.STATE_FULFILLED = STATE_FULFILLED
Promise.STATE_REJECTED = STATE_REJECTED

-- is promise object check function
Promise.IsPromise = isPromise

-- Promise error alias
Promise.PromiseError = PromiseError

-- global call stack
CALL_STACK, STACK_SIZE = {}, 0

-- instance data
do

    base = Promise.__base

    -- Aliases for instance methods
    base.then = base.next = base.andThen = __then
    base.finally = base.Finally
    base.catch = base.Catch

    -- Await functions
    do

        import error from _G

        safeAwait = ( promise ) ->
            co = running!
            unless co
                return false, PromiseError "Cannot await in main thread"

            local _success, _value, waiting, stack

            finish = ( success, value ) ->
                if waiting
                    STACK_SIZE += 1
                    CALL_STACK[ STACK_SIZE ] = stack -- push previous stack
                    resume( co, success, value )
                else
                    _success, _value = success, value

            wait = ->
                if _success ~= nil
                    return _success, _value

                waiting = true
                stack = CALL_STACK[ STACK_SIZE ] -- pop current stack
                CALL_STACK[ STACK_SIZE ] = nil
                STACK_SIZE -= 1
                return yield!

            if isPromise( promise )
                :state = promise
                if state == STATE_FULFILLED
                    return true, promise.value

                elseif state == STATE_REJECTED
                    return false, promise.reason

                else
                    once_wrapper = once!
                    __then( promise, once_wrapper( ( value ) -> finish( true, value ) ), once_wrapper( ( reason ) -> finish( false, reason ) ) )
                    return wait!

            return true, promise

        base.SafeAwait = safeAwait
        base.safeAwait = safeAwait
        environment.safeAwait = safeAwait

        environment.await = base.Await = base.await = ( promise ) ->
            ok, result = safeAwait( promise )
            if ok
                return result

            return error( result )

    -- Resolve functions
    Promise.Resolve = Promise.resolve = ( value ) -> return try2resolve( Promise!, value )
    base.Resolve = base.resolve = try2resolve

    -- Reject functions
    Promise.Reject = Promise.reject = ( reason ) -> return try2reject( Promise!, reason )
    base.Reject = base.reject = try2reject

    environment.util.RegisterMetaTable( "Promise", base )

-- Async function
do

    import isstring, iserror, RuntimeError from environment
    import captureStack from environment.Error

    transformError = (err) ->
        if isstring( err )
            file, line, message = match( err, "^([A-Za-z0-9%-_/.]+):(%d+): (.*)" )
            if file and line
                err = RuntimeError( message, file, line, 4 )

        if iserror( err )
            stack = err.stack
            stackSize = #stack

            if stackSize >= 2 and stack[ stackSize - 1 ].name == "xpcall"
                stack[ stackSize - 1 ] = nil -- remove xpcall stack
                stack[ stackSize ] = nil -- remove promise wrapper stack

            stackSize = #stack
            if stackSize == 0 -- if stack is empty, remove debug information
                err.fileName = nil
                err.lineNumber = nil

            lastStack = CALL_STACK[ STACK_SIZE ] -- peek current stack
            if lastStack
                if stackSize > 0 and not stack[ stackSize ].name
                    stack[ stackSize ].name = lastStack[ 1 ].name -- set previous stack name since it's the name of the function

                -- Append previous stack to the current stack
                for entry in *lastStack[2,]
                    stackSize += 1
                    stack[ stackSize ] = entry

            if first := stack[ 1 ]
                err.fileName or= first.short_src
                err.lineNumber or= first.currentline

        return err

    environment.async = Promise.Async = Promise.async = ( fn ) ->
        return ( ... ) ->
            promise = Promise!
            STACK_SIZE += 1
            CALL_STACK[ STACK_SIZE ] = captureStack! -- push stack

            resume( create( ( ... ) ->
                success, result = xpcall( fn, transformError, ... )
                if success
                    try2resolve( promise, result )
                else
                    try2reject( promise, result )

                CALL_STACK[ STACK_SIZE ] = nil -- pop stack
                return nil
            ), ... )

            return promise

-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
Promise.All = Promise.all = ( promises ) ->
    promise = Promise!

    count = #promises
    if count == 0
        try2resolve( promise, {} )
        return promise

    failed = false
    onReject = ( reason ) ->
        try2reject( promise, reason )
        failed = true
        return nil

    values = {}
    takeValue = ->
        count -= 1
        if count == 0
            try2resolve( promise, values )

        return nil

    for index = 1, count
        other = promises[ index ]
        if isPromise( other )
            __then(
                other,
                ( value ) ->
                    values[ index ] = value
                    takeValue!,
                onReject
            )
        else
            values[ index ] = other
            takeValue!

        if failed
            break

    return promise

-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled
Promise.AllSettled = Promise.allSettled = ( promises ) ->
    promise = Promise!

    count = #promises
    if count == 0
        try2resolve( promise, {} )
        return promise

    results = {}
    takeValue = ->
        count -= 1
        if count == 0
            try2resolve( promise, results )

        return nil

    for index = 1, count
        __then(
            promises[ index ],
            ( value ) ->
                results[ index ] = { status: "fulfilled", :value }
                takeValue!,
            ( reason ) ->
                results[ index ] = { status: "rejected", :reason }
                takeValue!
        )

    return promise

-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any
Promise.Any = Promise.any = ( promises ) ->
    promise = Promise!

    count = #promises
    if count == 0
        return try2reject( promise, PromiseError "No promises to resolve" )

    fulfilled = false
    onSuccess = ( value ) ->
        try2resolve( promise, value )
        fulfilled = true
        return nil

    reasons = {}
    takeValue = ->
        count -= 1
        if count == 0
            try2reject( promise, reasons )

        return nil

    for index = 1, count
        __then( promises[ index ], onSuccess, ( reason ) ->
            reasons[ index ] = reason
            takeValue!
        )

        if fulfilled
            break

    return promise

-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race
Promise.Race = Promise.race = ( promises ) ->
    promise = Promise!

    count = #promises
    if count == 0
        return promise

    onResolve = ( value ) ->
        try2resolve( promise, value )
        return nil

    onReject = ( reason ) ->
        try2reject( promise, reason )
        return nil

    for index = 1, count
        __then( promises[ index ], onResolve, onReject )

    return promise

-- A custom delay feature that stops the promise chain for a specified amount of time
Promise.Delay = Promise.delay = ( time, value ) ->
    promise = Promise!
    Simple time, -> resolve( promise, value )
    return promise

environment.Promise = Promise
gpm.Logger\Loaded( "gm_promise v%s", Promise.VERSION )
