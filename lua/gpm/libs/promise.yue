--[[
    MIT License

    Copyright (c) 2023-2024 Retro

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
--]]
_G = _G
import pcall, xpcall from _G -- renaming xpcall in code will result in breaking transformError
import environment from _G.gpm
import PromiseError, iscallable, table from environment
import create, resume, yield, running from coroutine
import captureStack, appendStack, pushCallStack, popCallStack from environment.Error
import format, match from _G.string
import Simple from timer

once = ->
    wasCalled = false
    return ( wrappedFn ) ->
        return ( ... ) ->
            if wasCalled
                return ...

            wasCalled = true
            return wrappedFn( ... )

local promiseClass, isPromise

do

    import getmetatable from _G

    isPromise = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == promiseClass

    environment.ispromise = isPromise

-- Promise states
STATE_PENDING = 1
STATE_FULFILLED = 2
STATE_REJECTED = 3

-- Internal functions
local resolve, reject, finalizePromise
do

    finalizePromiseUnsafe = ( promise, other ) ->
        :state = promise
        if state == STATE_FULFILLED
            if onFulfilled := other.onFulfilled
                resolve( other, onFulfilled( promise.value ) )
            else
                resolve( other, promise.value )

        elseif state == STATE_REJECTED
            if onRejected := other.onRejected
                resolve( other, onRejected( promise.reason ) )
            else
                reject( other, promise.reason )

        if onFinally := other.onFinally
            onFinally!

        return nil

    finalizePromise = ( promise, other ) ->
        success, err = try finalizePromiseUnsafe( promise, other )
        unless success
            reject( other, err )

        return nil

finalize = ( promise ) ->
    if promise.state == STATE_PENDING
        return nil

    Simple 0, ->
        :queue = promise
        if queue
            index = 1

            value = queue[ index ]
            while value
                finalizePromise( promise, value )
                queue[ index ] = nil

                index += 1
                value = queue[ index ]

        return nil

    return nil

reject = ( promise, reason ) ->
    if promise.state ~= STATE_PENDING
        return

    promise.state = STATE_REJECTED
    promise.reason = reason
    finalize( promise )
    return nil

fulfill = ( promise, value ) ->
    promise.state = STATE_FULFILLED
    promise.value = value
    finalize( promise )
    return nil

do

    import TypeError from environment

    resolve = ( promise, value ) ->
        if promise.state ~= STATE_PENDING
            return nil

        if value == promise
            return reject promise, TypeError "Cannot resolve a promise with itself"

        promise.resolving = true
        promise.onFulfilled = nil
        promise.onRejected = nil
        promise.onFinally = nil

        if isPromise( value )
            if value.state == STATE_PENDING
                value.queue = {} unless value.queue
                value.queue[] = promise
            else
                finalizePromise( value, promise )
        else
            fulfill( promise, value )

        return nil

try2resolve = ( promise, value ) ->
    unless promise.resolving
        resolve( promise, value )

    return promise

try2reject = ( promise, reason ) ->
    unless promise.resolving
        reject( promise, reason )

    return promise

__then = ( promise, onFulfilled, onRejected, onFinally ) ->
    p = promiseClass!
    if iscallable( onFulfilled )
        p.onFulfilled = onFulfilled

    if iscallable( onRejected )
        p.onRejected = onRejected

    if iscallable( onFinally )
        p.onFinally = onFinally

    unless promise.queue
        promise.queue = {}

    promise.queue[] = p
    finalize( promise )
    return p

-- global call stack
CALL_STACK, STACK_SIZE = {}, 0

local transformError
do

    import isstring, iserror, RuntimeError from environment

    transformError = ( err ) ->
        if isstring( err )
            file, line, message = match( err, "^([A-Za-z0-9%-_/.]+):(%d+): (.*)" )
            if file and line
                err = RuntimeError( message, file, line, 4 )
            else
                err = RuntimeError( err, nil, nil, 4 )
                err.fileName = nil
                err.lineNumber = nil

        if iserror( err ) and not err._transformed
            err._transformed = true

            -- detect promise stack entries
            pos, size = 1, #err.stack
            while pos <= size
                entry = err.stack[ pos ]
                if entry.name == "xpcall"
                    entry = err.stack[ pos + 2 ]
                    if entry and entry._asyncEntry
                        table.remove( err.stack, pos ) -- remove xpcall
                        table.remove( err.stack, pos ) -- remove async coroutine entry
                        table.remove( err.stack, pos ) -- remove async function entry
                        size -= 3

                        pos -= 1
                        funcEntry = err.stack[ pos ]
                        if funcEntry and not funcEntry.name
                            funcEntry.name = entry.name

                pos += 1

        return err

-- safe await
safeAwait = ( promise ) ->
    co = running!
    unless co
        return false, PromiseError "Cannot await in main thread"

    local _success, _value, waiting, stack

    finish = ( success, value ) ->
        if waiting
            pushCallStack( stack ) -- Error.pushCallStack( stack )
            resume( co, success, value )
        else
            _success, _value = success, value

    wait = ->
        if _success ~= nil
            return _success, _value

        waiting = true
        stack = popCallStack() -- Error.popCallStack()
        return yield!

    if isPromise( promise )
        :state = promise
        if state == STATE_FULFILLED
            return true, promise.value

        elseif state == STATE_REJECTED
            return false, promise.reason

        else
            once_wrapper = once!
            __then( promise, once_wrapper( ( value ) -> finish( true, value ) ), once_wrapper( ( reason ) -> finish( false, reason ) ) )
            return wait!

    return true, promise

local await
do

    import error from _G

    await = ( promise ) ->
        ok, result = safeAwait( promise )
        if ok
            return result

        return error( result )

-- Promise class
promiseClass = environment.class(
    "Promise",
    {
        new: ( executor ) =>
            @state = STATE_PENDING

            if iscallable( executor )
                @resolving = true
                once_wrapper = once!
                onReject = once_wrapper( ( reason ) -> reject( @, reason ) )
                xpcall( executor, onReject, once_wrapper( ( value ) -> resolve( @, value ) ), onReject )
            else
                @resolving = false

            return nil

        __tostring: =>
            return switch @state
                when STATE_PENDING
                    format "Promise %p { <state>: \"pending\" }", @
                when STATE_FULFILLED
                    format "Promise %p { <state>: \"fulfilled\", <value>: %s }", @, @value
                when STATE_REJECTED
                    format "Promise %p { <state>: \"rejected\", <reason>: %s }", @, @reason
                else
                    format "Promise %p { <state>: \"invalid\" }", @

        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then
        Then: __then
        then: __then
        next: __then
        andThen: __then

        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch
        Catch: ( onRejected ) =>
            return __then( @, nil, onRejected )

        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally
        Finally: ( onFinally ) =>
            return __then( @, nil, nil, onFinally )

        -- resolve
        Resolve: try2resolve
        resolve: try2resolve

        -- reject
        Reject: try2reject
        reject: try2reject

        -- safe await
        SafeAwait: safeAwait
        :safeAwait

        -- await
        Await: await
        :await
    },
    {
        -- Promise version information
        VERSION: "2.1.1-gpm",
        AUTHOR: "Pika-Software",
        URL: "https://github.com/dankmolot/gm_promise",

        -- Setting locals to class
        :STATE_PENDING,
        :STATE_FULFILLED,
        :STATE_REJECTED,

        -- is promise object check function
        IsPromise: isPromise,

        -- Promise error alias
        :PromiseError

        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve
        Resolve: ( value ) ->
            return try2resolve( promiseClass!, value )

        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject
        Reject: ( reason ) ->
            return try2reject( promiseClass!, reason )

        -- Async function
        Async: ( fn ) ->
            if not iscallable( fn )
                return PromiseError "Async function must be a function"

            return ( ... ) ->
                promise = promiseClass!

                -- save previous stack so later it will be appended to the error stack
                stack = captureStack()
                stack[ 1 ]._asyncEntry = true
                appendStack( stack ) -- Error.appendStack(...)

                resume( create( ( ... ) ->
                    success, result = xpcall( fn, transformError, ... )
                    if success
                        try2resolve( promise, result )
                    else
                        try2reject( promise, result )

                    -- Remove previosly added stack since this coroutine thread is done
                    popCallStack() -- Error.popCallStack()
                    return nil
                ), ... )

                return promise

        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
        All: ( promises ) ->
            promise = promiseClass!

            count = #promises
            if count == 0
                try2resolve( promise, {} )
                return promise

            failed = false
            onReject = ( reason ) ->
                try2reject( promise, reason )
                failed = true
                return nil

            values = {}
            takeValue = ->
                count -= 1
                if count == 0
                    try2resolve( promise, values )

                return nil

            for index = 1, count
                other = promises[ index ]
                if isPromise( other )
                    __then(
                        other,
                        ( value ) ->
                            values[ index ] = value
                            takeValue!,
                        onReject
                    )
                else
                    values[ index ] = other
                    takeValue!

                if failed
                    break

            return promise

        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled
        AllSettled: ( promises ) ->
            promise = promiseClass!

            count = #promises
            if count == 0
                try2resolve( promise, {} )
                return promise

            results = {}
            takeValue = ->
                count -= 1
                if count == 0
                    try2resolve( promise, results )

                return nil

            for index = 1, count
                __then(
                    promises[ index ],
                    ( value ) ->
                        results[ index ] = { status: "fulfilled", :value }
                        takeValue!,
                    ( reason ) ->
                        results[ index ] = { status: "rejected", :reason }
                        takeValue!
                )

            return promise

        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any
        Any: ( promises ) ->
            promise = promiseClass!

            count = #promises
            if count == 0
                return try2reject( promise, PromiseError "No promises to resolve" )

            fulfilled = false
            onSuccess = ( value ) ->
                try2resolve( promise, value )
                fulfilled = true
                return nil

            reasons = {}
            takeValue = ->
                count -= 1
                if count == 0
                    try2reject( promise, reasons )

                return nil

            for index = 1, count
                __then( promises[ index ], onSuccess, ( reason ) ->
                    reasons[ index ] = reason
                    takeValue!
                )

                if fulfilled
                    break

            return promise

        -- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race
        Race: ( promises ) ->
            promise = promiseClass!

            count = #promises
            if count == 0
                return promise

            onResolve = ( value ) ->
                try2resolve( promise, value )
                return nil

            onReject = ( reason ) ->
                try2reject( promise, reason )
                return nil

            for index = 1, count
                __then( promises[ index ], onResolve, onReject )

            return promise

        -- A custom delay feature that stops the promise chain for a specified amount of time
        Delay: ( time, value ) ->
            promise = promiseClass!
            Simple time, -> resolve( promise, value )
            return promise
    }
)

do

    -- Few aliases for instance methods
    base = promiseClass.__base
    base.finally = base.Finally
    base.catch = base.Catch

-- Lower case aliases for static methods
environment.async = promiseClass.async = promiseClass.Async
promiseClass.resolve = promiseClass.Resolve
promiseClass.reject = promiseClass.Reject
promiseClass.all = promiseClass.All
promiseClass.allSettled = promiseClass.AllSettled
promiseClass.any = promiseClass.Any
promiseClass.race = promiseClass.Race
promiseClass.delay = promiseClass.Delay

environment.Promise = promiseClass
environment.safeAwait = safeAwait
environment.await = await

gpm.Logger\Info( "gm_promise v%s loaded", promiseClass.VERSION )
