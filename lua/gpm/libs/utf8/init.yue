_G = _G
import concat, unpack from _G.gpm.environment.table
import char, byte, sub, gsub, gmatch, len from _G.string
import band, bor, lshift, rshift from _G.bit
import min, max from _G.math
import tonumber from _G

charpattern = "[%z\x01-\x7F\xC2-\xF4][\x80-\xBF]*"
_module_0 = { :charpattern }

utf8byte2char = _module_0.byte2char = ( byte0 ) ->
	-- Single-byte sequence
	if byte0 < 0x80
		return char( byte0 )

	-- Two-byte sequence
	if byte0 < 0x800
		return char(
			bor( 0xC0, band( rshift( byte0, 6 ), 0x1F ) ),
			bor( 0x80, band( byte0, 0x3F ) )
		)

	-- Three-byte sequence
	if byte0 < 0x10000
		return char(
			bor( 0xE0, band( rshift( byte0, 12 ), 0x0F ) ),
			bor( 0x80, band( rshift( byte0, 6 ), 0x3F ) ),
			bor( 0x80, band( byte0, 0x3F ) )
		)

	-- Four-byte sequence
	return char(
		bor( 0xF0, band( rshift( byte0, 18 ), 0x07 ) ),
		bor( 0x80, band( rshift( byte0, 12 ), 0x3F ) ),
		bor( 0x80, band( rshift( byte0, 6 ), 0x3F ) ),
		bor( 0x80, band( byte0, 0x3F ) )
	)

utf8char = _module_0.char = ( ... ) ->
	buffer, length = {}, 0

	for byte0 in *{ ... }
		length += 1
		buffer[ length ] = utf8byte2char( byte0 )

	return concat( buffer, "", 1, length )

stringPosition = ( number, stringLength ) ->
	if number > 0
		return min( number, stringLength )

	if number == 0
		return 1

	return max( stringLength + number + 1, 1 )

decode = ( str, stringStart, stringLength ) ->
	stringStart = stringPosition( stringStart or 1, stringLength )

	byte1 = byte( str, stringStart )
	unless byte1
		return nil

	-- Single-byte sequence
	if byte1 < 0x80
		return stringStart, stringStart, byte1

	-- Validate first byte of multi-byte sequence
	if byte1 > 0xF4 or byte1 < 0xC2
		return nil

	-- Get 'supposed' amount of continuation bytes from primary byte
	contByteCount = byte1 >= 0xF0 and 3 or byte1 >= 0xE0 and 2 or byte1 >= 0xC0 and 1
	stringEnd = stringStart + contByteCount

	-- The string doesn't have enough data for this many continutation bytes
	if stringLength < stringEnd
		return nil

	codePoint = 0

	-- Validate our continuation bytes
	for byte0 in *{ byte( str, stringStart + 1, stringEnd ) }
		-- Invalid continuation byte hit
		if bit.band( byte0, 0xC0 ) ~= 0x80
			return nil

		codePoint = bor( lshift( codePoint, 6 ), band( byte0, 0x3F ) )
		byte1 = lshift( byte1, 1 )

	return stringStart, stringEnd, bor( codePoint, lshift( band( byte1, 0x7F ), contByteCount * 5 ) )

_module_0.codes = ( str ) ->
	index, stringLength = 1, len( str )

	return ->
		if index > stringLength
			return nil

		stringStart, stringEnd, codePoint = decode( str, index, stringLength )
		unless stringStart
			error "invalid UTF-8 code", 2

		index = stringEnd + 1

		return stringStart, codePoint

utf8codepoint = _module_0.codepoint = _module_0.byte = ( str, stringStart, stringEnd ) ->
	stringLength = len( str )
	stringStart = stringPosition( stringStart or 1, stringLength )
	stringEnd = stringPosition( stringEnd or stringStart, stringLength )

	buffer, length = {}, 0

	repeat
		sequenceStart, sequenceEnd, codePoint = decode( str, stringStart, stringLength )
		unless sequenceStart
			error "invalid UTF-8 code", 2

		stringStart = sequenceEnd + 1

		length += 1
		buffer[ length ] = codePoint
	until sequenceEnd >= stringEnd

	return unpack( buffer, 1, length )

utf8len = _module_0.len = ( str, stringStart, stringEnd ) ->
	stringLength = len( str )

	stringStart = stringPosition( stringStart or 1, stringLength )
	stringEnd = stringPosition( stringEnd or -1, stringLength )

	length = 0

	if stringStart == 1 and stringEnd == stringLength
		for _ in gmatch( str, charpattern )
			length += 1

		return length

	while stringEnd >= stringStart and stringStart <= stringLength
		sequenceStart, sequenceEnd = decode( str, stringStart, stringLength )
		unless sequenceStart
			return false, stringStart

		stringStart = sequenceEnd + 1
		length += 1

	return length

utf8offset = _module_0.offset = ( str, offset, stringStart ) ->
	stringLength = len( str )
	position = stringPosition( stringStart or ( ( offset >= 0 ) and 1 or stringLength ), stringLength )

	-- Back up to the start of this byte sequence
	if offset == 0
		while position > 0 and not decode( str, position, stringLength )
			position -= 1

		return position

	unless decode( str, position, stringLength )
		error "initial position is a continuation byte", 2

	-- Back up to (-offset) byte sequences
	if offset < 0
		for i = 1, -offset
			position -= 1

			while position > 0 and not decode( str, position, stringLength )
				position -= 1

		if position < 1
			return nil

		return position

	-- Jump forward (offset) byte sequences
	if offset > 0
		for i = 1, offset
			position += 1

			while position <= stringLength and not decode( str, position, stringLength )
				position += 1

		if position > stringLength
			return nil

		return position

_module_0.force = ( str ) ->
	stringLength = len( str )
	if stringLength == 0
		return str

	buffer, length = {}, 0
	pointer = 1

	repeat
		seqStartPos, seqEndPos = decode( str, pointer, stringLength )

		if seqStartPos
			length += 1
			buffer[ length ] = sub( str, seqStartPos, seqEndPos )
			pointer = seqEndPos + 1

		else
			length += 1
			buffer[ length ] = utf8char( 0xFFFD )
			pointer += 1

	until pointer > stringLength

	return concat( buffer, "", 1, length )

stringOffset = ( position, utf8Length ) ->
	if position < 0
		position = max( utf8Length + position + 1, 0 )

	return position

utf8get = _module_0.get = ( str, index, utf8Length = utf8len( str ) ) ->
	index = stringOffset( index or 1, utf8Length )
	if index == 0
		return ""

	if index > utf8Length
		return ""

	return utf8char( utf8codepoint( str, utf8offset( str, index - 1 ) ) )

_module_0.sub = ( str, charStart, charEnd ) ->
	utf8Length = utf8len( str )
	buffer, length = {}, 0

	for index = stringOffset( charStart or 1, utf8Length ), stringOffset( charEnd or -1, utf8Length )
		length += 1
		buffer[ length ] = utf8get( str, index, utf8Length )

	return concat( buffer, "", 1, length )

do

	import lower2upper, upper2lower from include( "casemap.lua" )

	metatable = {
		__index: ( tbl, key ) ->
			return key
	}

	setmetatable( lower2upper, metatable )
	setmetatable( upper2lower, metatable )

	_module_0.lower = ( str ) ->
		utf8Length = utf8len( str )
		buffer, length = {}, 0

		for index = 1, utf8Length
			length += 1
			buffer[ length ] = upper2lower[ utf8get( str, index, utf8Length ) ]

		return concat( buffer, "", 1, length )

	_module_0.upper = ( str ) ->
		utf8Length = utf8len( str )
		buffer, length = {}, 0

		for index = 1, utf8Length
			length += 1
			buffer[ length ] = lower2upper[ utf8get( str, index, utf8Length ) ]

		return concat( buffer, "", 1, length )

utf8hex2char = _module_0.hex2char = ( str ) ->
	return utf8byte2char( tonumber( str, 16 ) )

do

	escapeChars = {
		["\\n"]: "\n"
		["\\t"]: "\t"
		["\\0"]: "\0"
	}

	escapeToChar = ( str ) ->
		return escapeChars[ str ] or sub( str, 2, 2 )

	_module_0.unicode = ( str, isSequence = false ) ->
		return gsub( gsub( str, isSequence and "\\[uU]([0-9a-fA-F]+)" or "[uU]%+([0-9a-fA-F]+)", utf8hex2char ), "\\.", escapeToChar ), nil

_module_0.reverse = ( str ) ->
	utf8Length = utf8len( str )
	position = utf8Length

	buffer, length = {}, 0

	while position > 0
		length += 1
		buffer[ length ] = utf8get( str, position, utf8Length )
		position -= 1

	return concat( buffer, "", 1, length )

return _module_0
