_G = _G
import gpm, isstring, istable, error, tostring, tonumber from _G
import environment from gpm

import Open, Find, GetFilePaths from environment.file
import HasValue, Empty from environment.table
import lower, gsub, find from string
import ArgAssert from environment
import CRC from util

class AddonError extends environment.Error
environment.AddonError = AddonError

export GetAll = engine.GetAddons

export Get = ( wsid ) ->
    for data in *GetAll!
        if data.wsid == wsid
            return data

export FileFind = ( filePath, wsid ) ->
    data = Get( wsid )
    if data
        return Find( filePath, data.title )

export GetFiles = ( wsid, filePath ) ->
    data = Get( wsid )
    if data
        return GetFilePaths( filePath or "", data.title )

-- Addon types
export Types = {
    "gamemode",
    "map",
    "weapon",
    "vehicle",
    "npc",
    "entity",
    "tool",
    "effects",
    "model",
    "servercontent"
}

export TypeExists = ( str ) ->
    return HasValue( Types, str, true )

-- Addon tags
export Tags = {
    "fun",
    "roleplay",
    "scenic",
    "movie",
    "realism",
    "cartoon",
    "water",
    "comic",
    "build"
}

export TagExists = ( str ) ->
    return HasValue( Tags, str, true )

-- https://github.com/Facepunch/gmad/blob/master/include/AddonWhiteList.h
wildcard = {
    "lua/*.lua",
    "scenes/*.vcd",
    "particles/*.pcf",
    "resource/fonts/*.ttf",
    "scripts/vehicles/*.txt",
    "resource/localization/*/*.properties",
    "maps/*.bsp",
    "maps/*.lmp",
    "maps/*.nav",
    "maps/*.ain",
    "maps/thumb/*.png",
    "sound/*.wav",
    "sound/*.mp3",
    "sound/*.ogg",
    "materials/*.vmt",
    "materials/*.vtf",
    "materials/*.png",
    "materials/*.jpg",
    "materials/*.jpeg",
    "materials/colorcorrection/*.raw",
    "models/*.mdl",
    "models/*.vtx",
    "models/*.phy",
    "models/*.ani",
    "models/*.vvd",
    "gamemodes/*/*.txt",
    "gamemodes/*/*.fgd",
    "gamemodes/*/logo.png",
    "gamemodes/*/icon24.png",
    "gamemodes/*/gamemode/*.lua",
    "gamemodes/*/entities/effects/*.lua",
    "gamemodes/*/entities/weapons/*.lua",
    "gamemodes/*/entities/entities/*.lua",
    "gamemodes/*/backgrounds/*.png",
    "gamemodes/*/backgrounds/*.jpg",
    "gamemodes/*/backgrounds/*.jpeg",
    "gamemodes/*/content/models/*.mdl",
    "gamemodes/*/content/models/*.vtx",
    "gamemodes/*/content/models/*.phy",
    "gamemodes/*/content/models/*.ani",
    "gamemodes/*/content/models/*.vvd",
    "gamemodes/*/content/materials/*.vmt",
    "gamemodes/*/content/materials/*.vtf",
    "gamemodes/*/content/materials/*.png",
    "gamemodes/*/content/materials/*.jpg",
    "gamemodes/*/content/materials/*.jpeg",
    "gamemodes/*/content/materials/colorcorrection/*.raw",
    "gamemodes/*/content/scenes/*.vcd",
    "gamemodes/*/content/particles/*.pcf",
    "gamemodes/*/content/resource/fonts/*.ttf",
    "gamemodes/*/content/scripts/vehicles/*.txt",
    "gamemodes/*/content/resource/localization/*/*.properties",
    "gamemodes/*/content/maps/*.bsp",
    "gamemodes/*/content/maps/*.nav",
    "gamemodes/*/content/maps/*.ain",
    "gamemodes/*/content/maps/thumb/*.png",
    "gamemodes/*/content/sound/*.wav",
    "gamemodes/*/content/sound/*.mp3",
    "gamemodes/*/content/sound/*.ogg",

    -- static version of the data/ folder
    -- (because you wouldn't be able to modify these)
    "data_static/*.txt",
    "data_static/*.dat",
    "data_static/*.json",
    "data_static/*.xml",
    "data_static/*.csv",
    "data_static/*.dem",
    "data_static/*.vcd",

    "data_static/*.vtf",
    "data_static/*.vmt",
    "data_static/*.png",
    "data_static/*.jpg",
    "data_static/*.jpeg",

    "data_static/*.mp3",
    "data_static/*.wav",
    "data_static/*.ogg"
}

-- Formatting wildcard to lua patterns
for index = 1, #wildcard
    wildcard[ index ] = "^" .. gsub( gsub( wildcard[ index ], "%.", "%." ), "%*", ".+" ) .. "$"

export IsFilePathAllowed = ( filePath ) ->
    for pattern in *wildcard
        if find( filePath, pattern )
            return true

    return false

export class Addon
    Identity: "GMAD"
    Version: 3

    __tostring: =>
        return "Garry's Mod Addon File '" .. title .. "'"

    new: =>
        @title = "unknown"
        @author = "unknown"
        @description = "unknown"
        @version = 1
        @timestamp = 0
        @required = {}
        @steam_id = ""
        @real_crc = 0
        @files = {}
        @stored_crc = 0

    GetTitle: =>
        return @title

    SetTitle: ( str ) =>
        ArgAssert( str, 1, "string" )
        @title = str

    GetAuthor: =>
        return @author

    SetAuthor: ( str ) =>
        ArgAssert( str, 1, "string" )
        @author = str

    GetDescription: =>
        return @description

    SetDescription: ( str ) =>
        ArgAssert( str, 1, "string" )
        @description = str

    GetAddonVersion: =>
        return @version

    SetAddonVersion: ( int32 ) =>
        ArgAssert( int32, 1, "number" )
        @version = int32

    GetTimestamp: =>
        return @timestamp

    SetTimestamp: ( uint64 ) =>
        ArgAssert( uint64, 1, "number" )
        @timestamp = uint64

    GetSteamID: =>
        return @steam_id

    SetSteamID: ( str ) =>
        ArgAssert( str, 1, "string" )
        @steam_id = str

    Open: ( filePath, gamePath, fileMode ) =>
        @Close!

        if istable( filePath )
            @file_path = "memory"
            @game_path = "unknown"
            @file_handler = filePath
            return filePath

        unless filePath
            filePath = @file_path

        unless gamePath
            gamePath = @game_path

        ArgAssert( filePath, 1, "string" )
        ArgAssert( gamePath, 2, "string" )

        fileHandle = Open( filePath, fileMode or "rb", gamePath )
        unless fileHandle
            error AddonError "file read handler is missing, opening is impossible"

        @file_path = filePath
        @game_path = gamePath
        @file_handler = fileHandle

        return fileHandle

    Close: =>
        fileHandle = @file_handler
        if fileHandle
            fileHandle\Close!
            @file_handler = nil
            return true

        return false

    Parse: ( doCRCs ) =>
        fileHandle = @file_handler
        unless fileHandle
            error AddonError "file read handler is missing, parsing is impossible"

        fileHandle\Seek( 0 )
        doCRCs = doCRCs ~= true

        if fileHandle\Read( 4 ) ~= ( @identity or @Identity )
            error AddonError "File is not a gma"

        version = fileHandle\ReadByte!
        if version > ( @format_version or @Version )
            error AddonError "gma version is unsupported"

        @steam_id = tostring( fileHandle\ReadUInt64! ) or ""
        @timestamp = fileHandle\ReadUInt64!

        if version > 1
            required = @required

            while not fileHandle\EndOfFile!
                value = fileHandle\ReadString!
                unless value
                    break

                required[ value ] = true

            fileHandle\Skip( 1 )

        @title = fileHandle\ReadString!
        @description = fileHandle\ReadString!
        @author = fileHandle\ReadString!

        @version = fileHandle\ReadLong!

        files, position = @files, 0
        while not fileHandle\EndOfFile!
            index = fileHandle\ReadULong!
            if index == 0
                break

            data = {
                file_path: fileHandle\ReadString!
                :position
            }

            fileSize = fileHandle\ReadUInt64!
            data.size = fileSize
            position += fileSize

            data.stored_crc = fileHandle\ReadULong!
            files[ index ] = data

        files.data_pointer = fileHandle\Tell!

        unless doCRCs
            return

        contentSize = fileHandle\Size! - 4
        fileHandle\Seek( contentSize )

        @stored_crc = fileHandle\ReadULong! or 0

        fileHandle\Seek( 0 )
        @real_crc = tonumber( CRC( fileHandle\Read( contentSize ) ) )

    Read: ( filePath, gamePath, readFiles, doCRCs ) =>
        Empty( @required )
        Empty( @files )

        @Open( filePath, gamePath, "rb" )
        @Parse( doCRCs )

        if readFiles
            @ReadFiles( doCRCs )

        @Close!
        return

    VerifyCRC: =>
        return @stored_crc == @real_crc

    VerifyFilesCRC: =>
        for data in *@files
            storedCRC = data.stored_crc
            unless storedCRC
                return false, data

            realCRC = data.real_crc
            unless realCRC
                content = data.content
                if content
                    realCRC = tonumber( CRC( content ) )
                    data.real_crc = realCRC

            if storedCRC ~= realCRC
                return false, data

        return true

    VerifyFiles: =>
        files = @files
        if #files == 0
            return false, nil

        for data in *files
            unless IsFilePathAllowed( data.file_path )
                return false, data

        return true

    Write: ( filePath, gamePath, doCRCs ) =>
        ok, result = @VerifyFiles!
        unless ok
            if result
                error AddonError "file is not allowed by whitelist (" .. result.file_path .. ")"
            else
                error AddonError "gma is empty"

        fileHandle = @Open( filePath, gamePath, "wb" )
        unless fileHandle
            error AddonError "file read handler is missing, opening is impossible"

        doCRCs = doCRCs ~= false

        fileHandle\Write( @identity or @Identity )
        fileHandle\WriteByte( @format_version or @Version )

        fileHandle\WriteUInt64( tonumber( @steam_id ) or 0 )
        fileHandle\WriteUInt64( @timestamp or os.time() )

        for value in pairs( @required )
            fileHandle\WriteString( value )

        fileHandle\WriteByte( 0 )

        fileHandle\WriteString( @title )
        fileHandle\WriteString( @description )
        fileHandle\WriteString( @author )

        fileHandle\WriteLong( @version )

        files = @files
        for index = 1, #files
            fileHandle\WriteULong( index )
            data = files[ index ]

            fileHandle\WriteString( lower( data.file_path ) )
            fileHandle\WriteUInt64( data.size )

            if doCRCs
                fileHandle\WriteULong( tonumber( CRC( data.content ) ) )
            else
                fileHandle\WriteULong( 0 )

        fileHandle\WriteULong( 0 )

        for data in *files
            content = data.content
            if isstring( content )
                fileHandle\Write( content )
            else
                error AddonError "file content must be a string (" .. data.file_path .. ")"

        if doCRCs
            fileHandle = @Open( filePath, gamePath, "rb" )
            unless fileHandle
                error AddonError "file read handler is missing, opening is impossible"

            fileCRC = tonumber( CRC( fileHandle\Read! ) )
            @stored_crc = fileCRC
            @real_crc = fileCRC

            fileHandle = @Open( filePath, gamePath, "ab" )
            unless fileHandle
                error AddonError "file read handler is missing, opening is impossible"

            fileHandle\WriteULong( crc )
        else
            fileHandle\WriteULong( 0 )

        @Close!
        return true

    ReadFile: ( index ) =>
        ArgAssert( index, 1, "number" )

        fileHandle = @file_handler
        unless fileHandle
            error AddonError "file read handler is missing, reading is not possible"

        files = @files
        data = files[ index ]
        unless data
            error AddonError "requested file does not exist"

        fileHandle\Seek( files.data_pointer + data.position )
        data.content = fileHandle\Read( data.size )
        return data

    ReadFiles: ( doCRCs ) =>
        fileHandle = @file_handler
        unless fileHandle
            error AddonError "file read handler is missing, reading is not possible"

        files = @files
        pointer = files.data_pointer
        for data in *files
            fileHandle\Seek( pointer + data.position )
            content = fileHandle\Read( data.size )
            data.content = content
            if doCRCs
                data.real_crc = tonumber( CRC( content ) )

        return files

    GetFile: ( index ) =>
        return @files[ index ]

    AddFile: ( filePath, content, doCRCs ) =>
        ArgAssert( filePath, 1, "string" )
        ArgAssert( content, 2, "string" )

        filePath = lower( filePath )
        doCRCs = doCRCs ~= false

        files = @files
        length = #files
        ::removed::

        for index = 1, length
            if files[ index ].file_path == filePath
                remove( files, index )
                length -= 1
                goto removed

        data = {
            file_path: filePath
            size: #content
            :content
        }

        if doCRCs
            fileCRC = tonumber( CRC( content ) )
            data.stored_crc = fileCRC
            data.real_crc = fileCRC

        length += 1
        files[ length ] = data

    ClearFiles: =>
        return Empty( @files )

    AddRequiredContent: ( value ) =>
        ArgAssert( value, 1, "string" )
        @requiredContent[ value ] = true

    RemoveRequiredContent: ( value ) =>
        ArgAssert( value, 1, "string" )
        @requiredContent[ value ] = nil

    ClearRequiredContent: =>
        return Empty( @requiredContent )
