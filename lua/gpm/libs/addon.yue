import Open, Find, GetFilePaths from gpm.file
import HasValue, Empty from gpm.table
import lower, gsub, find from string
import ArgAssert from gpm
import CRC from util

isstring = isstring
tostring = tostring
tonumber = tonumber
istable = istable
error = error

addon = {}

do

    import GetAddons from engine

    addon.GetAll = GetAddons

    get = ( wsid ) ->
        for addon in *GetAll!
            if addon.wsid == wsid
                return addon

    addon.Get = get

    addon.FileFind = ( filePath, wsid ) ->
        addon = get( wsid )
        if addon
            return Find( filePath, addon.title )

    addon.GetFiles = ( wsid, filePath ) ->
        addon = get( wsid )
        if addon
            return GetFilePaths( filePath or "", addon.title )

-- Addon types
types = {
    "gamemode",
    "map",
    "weapon",
    "vehicle",
    "npc",
    "entity",
    "tool",
    "effects",
    "model",
    "servercontent"
}

addon.Types = types

addon.TypeExists = ( str ) ->
    return HasValue( types, str, true )

-- Addon tags
tags = {
    "fun",
    "roleplay",
    "scenic",
    "movie",
    "realism",
    "cartoon",
    "water",
    "comic",
    "build"
}

addon.Tags = tags

addon.TagExists = ( str ) ->
    return HasValue( tags, str, true )

-- Addon wildcards
wildcard = {
    "lua/*.lua",
    "scenes/*.vcd",
    "particles/*.pcf",
    "resource/fonts/*.ttf",
    "scripts/vehicles/*.txt",
    "resource/localization/*/*.properties",
    "maps/*.bsp",
    "maps/*.lmp",
    "maps/*.nav",
    "maps/*.ain",
    "maps/thumb/*.png",
    "sound/*.wav",
    "sound/*.mp3",
    "sound/*.ogg",
    "materials/*.vmt",
    "materials/*.vtf",
    "materials/*.png",
    "materials/*.jpg",
    "materials/*.jpeg",
    "materials/colorcorrection/*.raw",
    "models/*.mdl",
    "models/*.vtx",
    "models/*.phy",
    "models/*.ani",
    "models/*.vvd",
    "gamemodes/*/*.txt",
    "gamemodes/*/*.fgd",
    "gamemodes/*/logo.png",
    "gamemodes/*/icon24.png",
    "gamemodes/*/gamemode/*.lua",
    "gamemodes/*/entities/effects/*.lua",
    "gamemodes/*/entities/weapons/*.lua",
    "gamemodes/*/entities/entities/*.lua",
    "gamemodes/*/backgrounds/*.png",
    "gamemodes/*/backgrounds/*.jpg",
    "gamemodes/*/backgrounds/*.jpeg",
    "gamemodes/*/content/models/*.mdl",
    "gamemodes/*/content/models/*.vtx",
    "gamemodes/*/content/models/*.phy",
    "gamemodes/*/content/models/*.ani",
    "gamemodes/*/content/models/*.vvd",
    "gamemodes/*/content/materials/*.vmt",
    "gamemodes/*/content/materials/*.vtf",
    "gamemodes/*/content/materials/*.png",
    "gamemodes/*/content/materials/*.jpg",
    "gamemodes/*/content/materials/*.jpeg",
    "gamemodes/*/content/materials/colorcorrection/*.raw",
    "gamemodes/*/content/scenes/*.vcd",
    "gamemodes/*/content/particles/*.pcf",
    "gamemodes/*/content/resource/fonts/*.ttf",
    "gamemodes/*/content/scripts/vehicles/*.txt",
    "gamemodes/*/content/resource/localization/*/*.properties",
    "gamemodes/*/content/maps/*.bsp",
    "gamemodes/*/content/maps/*.nav",
    "gamemodes/*/content/maps/*.ain",
    "gamemodes/*/content/maps/thumb/*.png",
    "gamemodes/*/content/sound/*.wav",
    "gamemodes/*/content/sound/*.mp3",
    "gamemodes/*/content/sound/*.ogg",

    -- static version of the data/ folder
    -- (because you wouldn't be able to modify these)
    "data_static/*.txt",
    "data_static/*.dat",
    "data_static/*.json",
    "data_static/*.xml",
    "data_static/*.csv",
    "data_static/*.dem",
    "data_static/*.vcd",

    "data_static/*.vtf",
    "data_static/*.vmt",
    "data_static/*.png",
    "data_static/*.jpg",
    "data_static/*.jpeg",

    "data_static/*.mp3",
    "data_static/*.wav",
    "data_static/*.ogg"
}

-- Formatting wildcard to lua patterns
for index = 1, #wildcard
    wildcard[ index ] = gsub( gsub( wildcard[ index ], "%.", "%." ), "%*", ".*" )

isFilePathAllowed = ( filePath ) ->
    for pattern in *wildcard
        if find( filePath, pattern )
            return true

    return false

addon.IsFilePathAllowed = isFilePathAllowed

identity = "GMAD"
formatVersion = 3

class addon.GMAD
    __tostring: =>
        return "Garry's Mod Addon File '" .. title .. "'"

    new: =>
        @title = "unknown"
        @author = "unknown"
        @description = "unknown"
        @version = 1
        @timestamp = 0
        @required = {}
        @steam_id = ""
        @real_crc = 0
        @files = {}
        @stored_crc = 0

    GetTitle: =>
        return @title

    SetTitle: ( str ) =>
        ArgAssert( str, 1, "string" )
        @title = str

    GetAuthor: =>
        return @author

    SetAuthor: ( str ) =>
        ArgAssert( str, 1, "string" )
        @author = str

    GetDescription: =>
        return @description

    SetDescription: ( str ) =>
        ArgAssert( str, 1, "string" )
        @description = str

    GetAddonVersion: =>
        return @version

    SetAddonVersion: ( int32 ) =>
        ArgAssert( int32, 1, "number" )
        @version = int32

    GetTimestamp: =>
        return @timestamp

    SetTimestamp: ( uint64 ) =>
        ArgAssert( uint64, 1, "number" )
        @timestamp = uint64

    GetSteamID: =>
        return @steam_id

    SetSteamID: ( str ) =>
        ArgAssert( str, 1, "string" )
        @steam_id = str

    Open: ( filePath, gamePath, fileMode ) =>
        @Close!

        unless filePath
            filePath = @file_path

        unless gamePath
            gamePath = @game_path

        ArgAssert( filePath, 1, "string" )
        ArgAssert( gamePath, 2, "string" )

        fileHandle = Open( filePath, fileMode or "rb", gamePath )
        unless fileHandle
            error( "file read handler is missing, opening is impossible" )

        @file_path = filePath
        @game_path = gamePath
        @file_handler = fileHandle

        return fileHandle

    Close: =>
        fileHandle = @file_handler
        if fileHandle
            fileHandle\Close!
            @file_handler = nil
            return true

        return false

    Parse: ( doCRCs ) =>
        fileHandle = @file_handler
        unless fileHandle
            error( "file read handler is missing, parsing is impossible" )

        fileHandle\Seek( 0 )
        doCRCs = doCRCs ~= true

        if fileHandle\Read( 4 ) ~= ( @identity or identity )
            error( "File is not a gma" )

        version = fileHandle\ReadByte!
        if version > ( @format_version or formatVersion )
            error( "gma version is unsupported" )

        @steam_id = tostring( fileHandle\ReadUInt64! ) or ""
        @timestamp = fileHandle\ReadUInt64!

        if version > 1
            required = @required

            while not fileHandle\EndOfFile!
                value = fileHandle\ReadString!
                unless value
                    break

                required[ value ] = true

            fileHandle\Skip( 1 )

        @title = fileHandle\ReadString!
        @description = fileHandle\ReadString!
        @author = fileHandle\ReadString!

        @version = fileHandle\ReadLong!

        files, position = @files, 0
        while not fileHandle\EndOfFile!
            index = fileHandle\ReadULong!
            if index == 0
                break

            data = {
                file_path: fileHandle\ReadString!
                :position
            }

            fileSize = fileHandle\ReadUInt64!
            data.size = fileSize
            position += fileSize

            data.stored_crc = fileHandle\ReadULong!
            files[ index ] = data

        files.data_pointer = fileHandle\Tell!

        unless doCRCs
            return

        contentSize = fileHandle\Size! - 4
        fileHandle\Seek( contentSize )

        @stored_crc = fileHandle\ReadULong! or 0

        fileHandle\Seek( 0 )
        @real_crc = tonumber( CRC( fileHandle\Read( contentSize ) ) )

    Read: ( filePath, gamePath, readFiles, doCRCs ) =>
        Empty( @required )
        Empty( @files )

        if istable( filePath )
            @Close!
            doCRCs = readFiles
            readFiles = gamePath
            @file_handler = filePath
        else
            @Open( filePath, gamePath, "rb" )

        @Parse( doCRCs )

        if readFiles
            @ReadFiles( doCRCs )

        @Close!
        return

    VerifyCRC: =>
        return @stored_crc == @real_crc

    VerifyFilesCRC: =>
        for data in *@files
            storedCRC = data.stored_crc
            unless storedCRC
                return false, data

            realCRC = data.real_crc
            unless realCRC
                content = data.content
                if content
                    realCRC = tonumber( CRC( content ) )
                    data.real_crc = realCRC

            if storedCRC ~= realCRC
                return false, data

        return true

    VerifyFiles: =>
        files = @files
        if #files == 0
            return false, "unknown"

        for data in *files
            unless isFilePathAllowed( data.file_path )
                return false, data

        return true

    Write: ( filePath, gamePath, doCRCs ) =>
        ok, result = @VerifyFiles!
        unless ok
            error( "file is not allowed by whitelist (" .. result.file_path .. ")" )

        fileHandle = @Open( filePath, gamePath, "wb" )
        unless fileHandle
            error( "file read handler is missing, opening is impossible" )

        doCRCs = doCRCs ~= false

        fileHandle\Write( @identity or identity )
        fileHandle\WriteByte( @format_version or formatVersion )

        fileHandle\WriteUInt64( tonumber( @steam_id ) or 0 )
        fileHandle\WriteUInt64( @timestamp or os.time() )

        for value in pairs( @required )
            fileHandle\WriteString( value )

        fileHandle\WriteByte( 0 )

        fileHandle\WriteString( @title )
        fileHandle\WriteString( @description )
        fileHandle\WriteString( @author )

        fileHandle\WriteLong( @version )

        files = @files
        for index = 1, #files
            fileHandle\WriteULong( index )
            data = files[ index ]

            fileHandle\WriteString( lower( data.file_path ) )
            fileHandle\WriteUInt64( data.size )

            if doCRCs
                fileHandle\WriteULong( tonumber( CRC( data.content ) ) )
            else
                fileHandle\WriteULong( 0 )

        fileHandle\WriteULong( 0 )

        for data in *files
            content = data.content
            if isstring( content )
                fileHandle\Write( content )
            else
                error( "file content must be a string (" .. data.file_path .. ")" )

        if doCRCs
            fileHandle = @Open( filePath, gamePath, "rb" )
            unless fileHandle
                error( "file read handler is missing, opening is impossible" )

            fileCRC = tonumber( CRC( fileHandle\Read! ) )
            @stored_crc = fileCRC
            @real_crc = fileCRC

            fileHandle = @Open( filePath, gamePath, "ab" )
            unless fileHandle
                error( "file read handler is missing, opening is impossible" )

            fileHandle\WriteULong( crc )
        else
            fileHandle\WriteULong( 0 )

        @Close!
        return true

    ReadFile: ( index ) =>
        ArgAssert( index, 1, "number" )

        fileHandle = @file_handler
        unless fileHandle
            error( "file read handler is missing, reading is not possible" )

        files = @files
        data = files[ index ]
        unless data
            error( "requested file does not exist" )

        fileHandle\Seek( files.data_pointer + data.position )
        data.content = fileHandle\Read( data.size )
        return data

    ReadFiles: ( doCRCs ) =>
        fileHandle = @file_handler
        unless fileHandle
            error( "file read handler is missing, reading is not possible" )

        files = @files
        pointer = files.data_pointer
        for data in *files
            fileHandle\Seek( pointer + data.position )
            content = fileHandle\Read( data.size )
            data.content = content
            if doCRCs
                data.real_crc = tonumber( CRC( content ) )

        return files

    GetFile: ( index ) =>
        return @files[ index ]

    AddFile: ( filePath, content, doCRCs ) =>
        ArgAssert( filePath, 1, "string" )
        ArgAssert( content, 2, "string" )

        filePath = lower( filePath )
        doCRCs = doCRCs ~= false

        files = @files
        length = #files
        ::removed::

        for index = 1, length
            if files[ index ].file_path == filePath
                remove( files, index )
                length -= 1
                goto removed

        data = {
            file_path: filePath
            size: #content
            :content
        }

        if doCRCs
            fileCRC = tonumber( CRC( content ) )
            data.stored_crc = fileCRC
            data.real_crc = fileCRC

        length += 1
        files[ length ] = data

    ClearFiles: =>
        return Empty( @files )

    AddRequiredContent: ( value ) =>
        ArgAssert( value, 1, "string" )
        @requiredContent[ value ] = true

    RemoveRequiredContent: ( value ) =>
        ArgAssert( value, 1, "string" )
        @requiredContent[ value ] = nil

    ClearRequiredContent: =>
        return Empty( @requiredContent )

return addon
