_G = _G
import gpm from _G
import environment, Logger from gpm
import ArgAssert, Promise, http, isstring, isnumber, istable, WebClientError from environment

unless isstring( http.UserAgent )
    http.UserAgent = "GLua Package Manager/" .. gpm.VERSION .. " - Garry's Mod/" .. VERSIONSTR

client, clientName, returnsState, userAgentKey = _G.HTTP, "Garry's Mod", true, nil
do

    clients = {
        {
            Name: "reqwest"
            Client: "reqwest"
            Available: SERVER
            ReturnsState: false
            UserAgentKey: "User-Agent"
        },
        {
            Name: "chttp"
            Client: "CHTTP"
            Available: CLIENT or SERVER
            ReturnsState: false
        }
    }

    for item in *clients
        if item.Available and ( util.IsBinaryModuleInstalled( item.Name ) and pcall( require, item.Name ) )
            client, clientName, returnsState, userAgentKey = _G[ item.Client ], item.Name, item.ReturnsState, item.UserAgentKey
            break

    Logger\Info( "'%s' was connected as HTTP client.", clientName )

local HTTP
do

    http_timeout = CreateConVar( "http_timeout", "10", FCVAR_ARCHIVE, "Default http timeout for gpm http library.", 3, 300 )

    requestCache = {}

    request = ( parameters ) =>
        if client( parameters ) or not returnsState
            Logger\Debug( "%s HTTP request to '%s', using '%s', with timeout %d seconds.", parameters.method, parameters.url, clientName, parameters.timeout )
        else
            if parameters.cache
                requestCache[ parameters.method ][ parameters.url ] = nil

            @Reject( WebClientError "failed to make http request" )

    queue = {}
    timer.Simple 0, ->
        for func in *queue
            func!

        queue = nil


    HTTP = ( parameters ) ->
        ArgAssert( parameters, 1, "table" )
        promise = Promise!

        unless isstring( parameters.method )
            parameters.method = "GET"

        unless isnumber( parameters.timeout )
            parameters.timeout = http_timeout\GetInt!

        if userAgentKey
            unless istable( parameters.headers )
                parameters.headers = {}

            parameters.headers[ userAgentKey ] = http.UserAgent

        :cache, :method, :url = parameters
        if cache
            unless requestCache[ method ]
                requestCache[ method ] = {}
            
            if requestCache[ method ][ url ]
                return promise\Resolve( requestCache[ method ][ url ] )
            
            requestCache[ method ][ url ] = promise

        parameters.success = ( status, body, headers ) ->
            promise\Resolve( { :status, :body, :headers } )
            return

        parameters.failed = ( msg ) ->
            if cache
                requestCache[ method ][ url ] = nil

            promise\Reject( WebClientError msg )
            return

        if queue
            queue[] = ->
                request( promise, parameters )
        else
            request( promise, parameters )

        return promise

    environment.HTTP = HTTP

do

    tbl = setmetatable( {}, { __mode: "v" } )

    http.Fetch = ( url, headers, timeout ) ->
        tbl.url = url
        tbl.method = "GET"
        tbl.headers = headers
        tbl.timeout = timeout
        tbl.parameters = nil
        return HTTP( tbl )

    http.CachedFetch = ( url, headers, timeout ) ->
        tbl.url = url
        tbl.method = "GET"
        tbl.headers = headers
        tbl.timeout = timeout
        tbl.parameters = nil
        tbl.cache = true
        return HTTP( tbl )

    http.Post = ( url, parameters, headers, timeout ) ->
        tbl.url = url
        tbl.method = "POST"
        tbl.headers = headers
        tbl.timeout = timeout
        tbl.parameters = parameters
        return HTTP( tbl )

-- https://github.com/luvit/luvit/blob/master/deps/http-codec.lua
-- https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
-- https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
http.StatusCodes = setmetatable(
    {
        [ 100 ]: "Continue"
        [ 101 ]: "Switching Protocols"
        [ 102 ]: "Processing"               -- RFC 2518, obsoleted by RFC 4918
        [ 200 ]: "OK"
        [ 201 ]: "Created"
        [ 202 ]: "Accepted"
        [ 203 ]: "Non-Authoritative Information"
        [ 204 ]: "No Content"
        [ 205 ]: "Reset Content"
        [ 206 ]: "Partial Content"
        [ 207 ]: "Multi-Status"               -- RFC 4918
        [ 208 ]: "Already Reported",
        [ 300 ]: "Multiple Choices"
        [ 301 ]: "Moved Permanently"
        [ 302 ]: "Moved Temporarily"
        [ 303 ]: "See Other"
        [ 304 ]: "Not Modified"
        [ 305 ]: "Use Proxy"
        [ 307 ]: "Temporary Redirect"
        [ 400 ]: "Bad Request"
        [ 401 ]: "Unauthorized"
        [ 402 ]: "Payment Required"
        [ 403 ]: "Forbidden"
        [ 404 ]: "Not Found"
        [ 405 ]: "Method Not Allowed"
        [ 406 ]: "Not Acceptable"
        [ 407 ]: "Proxy Authentication Required"
        [ 408 ]: "Request Time-out"
        [ 409 ]: "Conflict"
        [ 410 ]: "Gone"
        [ 411 ]: "Length Required"
        [ 412 ]: "Precondition Failed"
        [ 413 ]: "Request Entity Too Large"
        [ 414 ]: "Request-URI Too Large"
        [ 415 ]: "Unsupported Media Type"
        [ 416 ]: "Requested Range Not Satisfiable"
        [ 417 ]: "Expectation Failed"
        [ 418 ]: "I'm a teapot"                       -- RFC 2324
        [ 422 ]: "Unprocessable Entity"               -- RFC 4918
        [ 423 ]: "Locked"                             -- RFC 4918
        [ 424 ]: "Failed Dependency"                  -- RFC 4918
        [ 425 ]: "Unordered Collection"               -- RFC 4918
        [ 426 ]: "Upgrade Required"                   -- RFC 2817
        [ 428 ]: "Precondition Required"              -- RFC 6585
        [ 429 ]: "Too Many Requests"                  -- RFC 6585
        [ 431 ]: "Request Header Fields Too Large"    -- RFC 6585
        [ 500 ]: "Internal Server Error"
        [ 501 ]: "Not Implemented"
        [ 502 ]: "Bad Gateway"
        [ 503 ]: "Service Unavailable"
        [ 504 ]: "Gateway Time-out"
        [ 505 ]: "HTTP Version not supported"
        [ 506 ]: "Variant Also Negotiates"            -- RFC 2295
        [ 507 ]: "Insufficient Storage"               -- RFC 4918
        [ 508 ]: "Loop Detected",
        [ 509 ]: "Bandwidth Limit Exceeded"
        [ 510 ]: "Not Extended"                       -- RFC 2774
        [ 511 ]: "Network Authentication Required"     -- RFC 6585
    },
    {
        __index: ->
            return "Unknown"
    }
)
