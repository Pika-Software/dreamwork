
import gpm, os, hook from _G
import istable, isstring, isnumber, isfunction, tostring, throw, Logger, xpcall, argument, pairs from gpm
import string, table from gpm
import SQLError from gpm

gsql = _G.sql
:sql = gpm
unless istable( sql )
    sql = gpm.sql = {}

--[[

    Standard SQL library

--]]

sql.escape = (str) ->
    if str == nil
        return "null"

    return gsql.SQLStr(str)

sql.query = ( query, ... ) ->
    args, i = { ... }, 0
    query = string.gsub( query, "?", ->
        i += 1
        return sql.escape( args[ i ] )
    )

    Logger\Debug( "Executing SQL query: " .. query )
    result = gsql.Query( query )
    if result == false
        throw SQLError gsql.LastError(), nil, nil, 4

    -- convert NULL values into nil
    if istable( result )
        for t in *result
            for k, v in pairs( t )
                if v == "NULL"
                    t[ k ] = nil

    return result

sql.queryOne = ( query, ... ) ->
    result = sql.query( query, ... )
    return result and result[1]

sql.begin = -> 
    return sql.query( "begin" )

sql.commit = -> 
    return sql.query( "commit" )

sql.rollback = -> 
    return sql.query( "rollback" )

sql.transaction = ( func ) ->
    sql.begin()
    ok, result = pcall( func )
    unless ok
        sql.rollback()
        throw result

    sql.commit()
    return result

--[[

    Libraries

--]]

do --- http_cache table, used for etag caching in http library
    lib = sql.http_cache = {}
    
    lib.get = ( url ) ->
        argument( url, 1, "string" )

        result = sql.query( "select etag, content from 'gpm.http_cache' where url=? limit 1", url )
        return result and result[1]

    lib.set = ( url, etag, content ) ->
        argument( url, 1, "string" )
        argument( etag, 2, "string" )
        argument( content, content, "string" )
        if #content > ( 50 * 1024 ) -- 50KB
            -- do not cache content that are larger than 50KB
            return
        
        if string.find( content, "\x00", 1, true )
            -- we are unable to store null bytes in sqlite
            return

        sql.query( "insert or replace into 'gpm.http_cache' (url, etag, timestamp, content) values (?, ?, ?, ?)", url, etag, os.time(), content )

do --- key-value store for gpm
    lib = sql.store = {}

    lib.set = ( key, value ) ->
        argument( key, 1, "string" )

        sql.query( "insert or replace into 'gpm.store' values (?, ?)", key, value )
        return
    
    lib.get = ( key ) ->
        argument( key, 1, "string" )

        result = sql.query( "select value from 'gpm.store' where key=?", key )
        return result and result[1].value

do --- repositories
    lib = sql.repositories = {}

    lib.getRepositories = ->
        result = sql.query( "select * from 'gpm.repositories'" )
        return

    lib.addRepository = ( url ) ->
        argument( url, 1, "string" )
        return sql.queryOne( "insert or ignore into 'gpm.repositories' (url) values (?); select * from 'gpm.repositories' where url=?", url, url )

    lib.removeRepository = ( url ) ->
        argument( url, 1, "string" )

        sql.transaction ->
            repository = sql.queryOne( "select id from 'gpm.repositories' where url=?", url )
            packages = sql.query( "select id from 'gpm.packages' where repositoryId=?", repository.id )
            
            -- delete all versions, packages and repository
            for p in *packages
                sql.query( "delete from 'gpm.package_versions' where packageId=?; delete from 'gpm.packages' where id=?", p.id, p.id )
            
            sql.query( "delete from 'gpm.repositories' where id=?", repository.id )
            
            return

    getRepositoryId = ( repository ) ->
        if isnumber( repository )
            return repository
    
        if istable( repository )
            return repository.id or repository.url

        if isstring( repository )
            result = sql.queryOne( "select id from 'gpm.repositories' where url=?", repository )
            return result and result.id or nil

    lib.getPackage = ( repository, name ) ->
        argument( name, 2, "string" )

        repositoryId = getRepositoryId( repository )
        unless repositoryId
            throw SQLError "invalid repository '#{repository}' was given as #1 argument"

        if pkg := sql.queryOne( "select * from 'gpm.packages' where name=? and repositoryId=?", name, repositoryId )
            pkg.versions = sql.query( "select version, metadata from 'gpm.package_versions' where packageId=?", pkg.id )
            return pkg
    
    lib.updateRepository = ( repository, packages ) ->
        argument( packages, 2, "table" )

        repositoryId = getRepositoryId( repository )
        unless repositoryId
            throw SQLError "invalid repository '#{repository}' was given as #1 argument"

        oldPackages = sql.query( "select id, name from 'gpm.packages' where repositoryId=?", repositoryId )
        oldPackages = { pkg.name, pkg.id for pkg in *oldPackages }

        sql.transaction ->
            for name, pkg in pairs( packages )
                sql.query( "insert or replace into 'gpm.packages' (name, url, type, repositoryId) values (?, ?, ?, ?)", pkg.name, pkg.url, pkg.type, repositoryId )
                packageId = sql.queryOne( "select id from 'gpm.packages' where name=? and repositoryId=?", pkg.name, repositoryId ).id

                sql.query( "delete from 'gpm.package_versions' where packageId=?", packageId )
                for v in *pkg.versions
                    sql.query( "insert into 'gpm.package_versions' (version, metadata, packageId) values (?, ?, ?)", v.version, v.metadata, packageId )

                oldPackages[ name ] = nil
            
            -- remove old packages
            for name, id in pairs( oldPackages )
                sql.query( "delete from 'gpm.package_versions' where packageId=?; delete from 'gpm.packages' where id=?", id, id )

--[[

    Migrations

--]]

sql.migrations = [
    {
        name: "initial"
        execute: -> -- deprecated
    }
    {
        name: "http_cache add primary key"
        execute: ->
            sql.query( "drop table if exists 'gpm.http_cache'" )
            sql.query( [[create table 'gpm.http_cache' (
                url text primary key, 
                etag text,
                timestamp int, 
                content blob
            )]] )

            return
    }
    {
        name: "added key-value store"
        execute: ->
            sql.query( "create table 'gpm.store' ( key text unique, value text )" )

            return
    }
    {
        name: "initial repositories and packages"
        execute: ->
            sql.query( "drop table if exists 'gpm.table_version'" )
            sql.query( "drop table if exists 'gpm.repository'" )
            sql.query( "drop table if exists 'gpm.packages'" )

            if SERVER
                sql.query( "create table 'gpm.repositories' ( id integer primary key autoincrement, url text unique not null )" )
                sql.query( [[
                    create table 'gpm.packages' (
                        id integer primary key autoincrement,
                        name text not null,
                        url text not null,
                        type int not null,
                        repositoryId integer,

                        foreign key(repositoryId) references 'gpm.repositories' (id)
                        unique(name, repositoryId) on conflict replace
                    )
                ]] )
                sql.query( [[
                    create table 'gpm.package_versions' ( 
                        version text not null,
                        metadata text,
                        packageId integer not null,

                        foreign key(packageId) references 'gpm.packages' (id)
                        unique(version, packageId) on conflict replace
                    )
                ]] )

            return
    }
]

-- optimize sqlite database
unless sql.optimized
    pragma_values = sql.query( "pragma foreign_keys; pragma journal_mode; pragma synchronous; pragma wal_autocheckpoint" )
    if pragma_values[1].foreign_keys == "0"
        sql.query( "pragma foreign_keys = 1" )
    
    if pragma_values[2].journal_mode == "delete"
        sql.query( "pragma journal_mode = wal" )
    
    if pragma_values[3].synchronous == "0"
        sql.query( "pragma synchronous = normal" )
    
    if pragma_values[4].wal_autocheckpoint == "1000"
        sql.query( "pragma wal_autocheckpoint = 100" )

    sql.optimized = true

-- truncate WAL journal on shutdown
hook.Add( "ShutDown", "GLua Package Manager", ->
    if gsql.Query( "pragma wal_checkpoint(TRUNCATE)" ) == false
        Logger\Error( "Failed to truncate WAL journal: %s", gsql.LastError() )
)


unless gsql.TableExists( "gpm.migration_history" )
    sql.query "create table 'gpm.migration_history' (name text, timestamp integer)"

sql.migrationExists = (name) ->
    for m in *sql.migrations
        if m.name == name
            return true
    return false

sql.runMigration = (migration) ->
    unless isfunction( migration.execute )
        throw SQLError "Migration '#{migration.name}' does not have an execute function"

    Logger\Info( "Running migration '#{migration.name}'..." )

    sql.begin() -- begin transaction so we can rollback if something goes wrong
    ok = xpcall( migration.execute, SQLError.display )

    if ok
        sql.query( "insert into 'gpm.migration_history' (name, timestamp) values (?, ?)", migration.name, os.time() )
        sql.commit()
    else
        sql.rollback()
    
    return ok


sql.migrate = (name) ->
    unless isstring( name )
        throw SQLError "Migration name must be a string, not #{name}"

    history = sql.query( "select name from 'gpm.migration_history'" ) or {}
    for m in *history
        history[ m.name ] = true

    -- find if given migration name exists
    unless sql.migrationExists( name )
        throw SQLError "Migration '" .. name .. "' not found"
    
    -- first execute migrations
    for m in *sql.migrations
        unless history[ m.name ] 
            if sql.runMigration( m ) == false
                break

        if m.name == name -- this is our last migration
            break
