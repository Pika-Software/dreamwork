
import gpm, os from _G
import istable, isstring, isfunction, tostring, throw, Logger, xpcall, ArgAssert, pairs from gpm
import string, table from gpm
import SQLError from gpm

gsql = _G.sql
:sql = gpm
unless istable( sql )
    sql = gpm.sql = {}

--[[

    Standard SQL library

--]]

sql.escape = (str) ->
    if str == nil
        return "null"

    return gsql.SQLStr(str)

sql.query = ( query, ... ) ->
    args, i = { ... }, 0
    query = string.gsub( query, "?", ->
        i += 1
        return sql.escape( args[ i ] )
    )

    Logger\Debug( "Executing SQL query: " .. query )
    result = gsql.Query( query )
    if result == false
        throw SQLError gsql.LastError(), nil, nil, 4

    -- convert NULL values into nil
    if istable( result )
        for t in *result
            for k, v in pairs( t )
                if v == "NULL"
                    t[ k ] = nil

    return result

sql.begin = -> 
    return sql.query( "begin" )

sql.commit = -> 
    return sql.query( "commit" )

sql.rollback = -> 
    return sql.query( "rollback" )

--[[

    Libraries

--]]

do --- http_cache table, used for etag caching in http library
    lib = sql.http_cache = {}
    
    lib.get = ( url ) ->
        ArgAssert( url, 1, "string" )

        result = sql.query( "select etag, content from 'gpm.http_cache' where url=? limit 1", url )
        return result and result[1]

    lib.set = ( url, etag, content ) ->
        ArgAssert( url, 1, "string" )
        ArgAssert( etag, 2, "string" )
        ArgAssert( content, content, "string" )
        if #content > ( 50 * 1024 ) -- 50KB
            -- do not cache content that are larger than 50KB
            return
        
        if string.find( content, "\x00", 1, true )
            -- we are unable to store null bytes in sqlite
            return

        sql.query( "insert or replace into 'gpm.http_cache' (url, etag, timestamp, content) values (?, ?, ?, ?)", url, etag, os.time(), content )

do --- key-value store for gpm
    lib = sql.store = {}

    lib.set = ( key, value ) ->
        ArgAssert( key, 1, "string" )

        sql.query( "insert or replace into 'gpm.store' values (?, ?)", key, value )
        return
    
    lib.get = ( key ) ->
        ArgAssert( key, 1, "string" )

        result = sql.query( "select value from 'gpm.store' where key=?", key )
        return result and result[1].value

do --- repositories
    lib = sql.repositories = {}

    lib.getPackage = ( repository, name ) ->
        if istable( repository )
            repository = repository.id

        ArgAssert( repository, 1, "number" )
        ArgAssert( name, 2, "string" )

        result = sql.query( [[
            select p.*, group_concat(v.version) as versions 
                from 'gpm.packages' p 
                join 'gpm.package_versions' v on p.repositoryId=? and p.name=? and p.id=v.packageId
        ]], repository, name )

        if result := result and result[1]
            result.versions = string.ByteSplit( result.versions, 0x2C --[[',']] )
            table.SortDesc( result.versions ) -- let be newest first
            return result

    lib.getRepositories = ->
        result = sql.query( "select * from 'gpm.repository'" )
        return

    lib.addRepository = ( url ) ->

    lib.removeRepository = ( url ) ->

--[[

    Migrations

--]]

sql.migrations = [
    {
        name: "initial"
        execute: -> -- deprecated
    }
    {
        name: "http_cache add primary key"
        execute: ->
            sql.query( "drop table if exists 'gpm.http_cache'" )
            sql.query( [[create table 'gpm.http_cache' (
                url text primary key, 
                etag text,
                timestamp int, 
                content blob
            )]] )

            return
    }
    {
        name: "added key-value store"
        execute: ->
            sql.query( "create table 'gpm.store' ( key text unique, value text )" )

            return
    }
    {
        name: "initial repositories and packages"
        execute: ->
            sql.query( "drop table if exists 'gpm.table_version'" )
            sql.query( "drop table if exists 'gpm.repository'" )
            sql.query( "drop table if exists 'gpm.packages'" )

            if SERVER
                sql.query( "create table 'gpm.repositories' ( id integer primary key autoincrement, url text unique not null )" )
                sql.query( [[
                    create table 'gpm.packages' (
                        id integer primary key autoincrement,
                        name text not null,
                        url text not null,
                        type int not null,
                        repositoryId integer,

                        foreign key(repositoryId) references 'gpm.repositories' (id)
                        unique(name, repositoryId) on conflict replace
                    )
                ]] )
                sql.query( [[
                    create table 'gpm.package_versions' ( 
                        version text not null,
                        metadata text,
                        packageId integer not null,

                        foreign key(packageId) references 'gpm.packages' (id)
                        unique(version, packageId) on conflict replace
                    )
                ]] )

            return
    }
]

-- migration history table
unless gsql.TableExists( "gpm.migration_history" )
    sql.query "create table 'gpm.migration_history' (name text, timestamp integer)"

sql.migrationExists = (name) ->
    for m in *sql.migrations
        if m.name == name
            return true
    return false

sql.runMigration = (migration) ->
    unless isfunction( migration.execute )
        throw SQLError "Migration '#{migration.name}' does not have an execute function"

    Logger\Info( "Running migration '#{migration.name}'..." )

    sql.begin() -- begin transaction so we can rollback if something goes wrong
    ok = xpcall( migration.execute, SQLError.display )

    if ok
        sql.query( "insert into 'gpm.migration_history' (name, timestamp) values (?, ?)", migration.name, os.time() )
        sql.commit()
    else
        sql.rollback()
    
    return ok


sql.migrate = (name) ->
    unless isstring( name )
        throw SQLError "Migration name must be a string, not #{name}"

    history = sql.query( "select name from 'gpm.migration_history'" ) or {}
    for m in *history
        history[ m.name ] = true

    -- find if given migration name exists
    unless sql.migrationExists( name )
        throw SQLError "Migration '" .. name .. "' not found"
    
    -- first execute migrations
    for m in *sql.migrations
        unless history[ m.name ] 
            if sql.runMigration( m ) == false
                break

        if m.name == name -- this is our last migration
            break
