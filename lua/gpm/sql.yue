
import gpm from _G
import istable, isstring, isfunction, tostring, throw, Logger, xpcall from gpm
import string from gpm
import SQLError from gpm

gsql = _G.sql
:sql = gpm
unless istable( sql )
    sql = gpm.sql = {}

--[[

    Standard SQL library

--]]

sql.escape = (str) -> gsql.SQLStr(str)

sql.query = ( query, ... ) ->
    args, i = { ... }, 0
    query = string.gsub( query, "?", ->
        i += 1
        return sql.escape( args[ i ] )
    )

    Logger\Debug( "Executing SQL query: " .. query )
    result = gsql.Query( query )
    if result == false
        throw SQLError gsql.LastError(), nil, nil, 4

    return result

sql.begin = -> 
    return sql.query( "begin" )

sql.commit = -> 
    return sql.query( "commit" )

sql.rollback = -> 
    return sql.query( "rollback" )

--[[

    Libraries

--]]

do
    lib = sql.http_cache = {}
    
    lib.exists = ( url, etag ) ->
        unless isstring( url ) and isstring( etag )
            throw SQLError "URL and ETag must be strings, not #{url} and #{etag}"

        return sql.query( "select 1 from 'gpm.http_cache' where url=? and etag=? limit 1" ) != nil

    lib.set = ( url, etag, content ) ->
        unless isstring( url ) and isstring( etag ) and isstring( content )
            throw SQLError "URL, ETag and content must be strings, not #{url}, #{etag} and #{content}"

        sql.query( "insert into 'gpm.http_cache' (url, etag, timestamp, content) values (?, ?, ?, ?)", url, etag, os.time(), content )
    
    lib.get = ( url, etag ) ->
        unless isstring( url ) and isstring( etag )
            throw SQLError "URL and ETag must be strings, not #{url} and #{etag}"

        result = sql.query( "select content from 'gpm.http_cache' where url=? and etag=? limit 1" )
        return result and result[1] and result[1].content

--[[

    Migrations

--]]

sql.migrations = [
    {
        name: "initial"
        execute: ->
            sql.query [[create table 'gpm.http_cache' (
                url text, 
                etag text,
                timestamp int, 
                content blob, 
                unique(url, etag) on conflict replace
            )]]
    }
]

-- migration history table
unless gsql.TableExists( "gpm.migration_history" )
    sql.query "create table 'gpm.migration_history' (name text, timestamp int)"

sql.migrationExists = (name) ->
    for m in *sql.migrations
        if m.name == name
            return true
    return false

sql.runMigration = (migration) ->
    unless isfunction( migration.execute )
        throw SQLError "Migration '#{migration.name}' does not have an execute function"

    Logger\Debug( "Running migration '#{migration.name}'..." )

    sql.begin() -- begin transaction so we can rollback if something goes wrong
    ok = xpcall( migration.execute, SQLError.display )

    if ok
        sql.query( "insert into 'gpm.migration_history' (name, timestamp) values (?, ?)", migration.name, os.time() )
        sql.commit()
    else
        sql.rollback()
    
    return ok


sql.migrate = (name) ->
    unless isstring( name )
        throw SQLError "Migration name must be a string, not #{name}"

    history = sql.query( "select name from 'gpm.migration_history'" ) or {}
    for m in *history
        history[ m.name ] = true

    -- find if given migration name exists
    unless sql.migrationExists( name )
        throw SQLError "Migration '" .. name .. "' not found"
    
    -- first execute migrations
    for m in *sql.migrations
        unless history[ m.name ] 
            if sql.runMigration( m ) == false
                break

        if m.name == name -- this is our last migration
            break
