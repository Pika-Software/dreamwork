
import gpm, os from _G
import istable, isstring, isfunction, tostring, throw, Logger, xpcall, ArgAssert from gpm
import string from gpm
import SQLError from gpm

gsql = _G.sql
:sql = gpm
unless istable( sql )
    sql = gpm.sql = {}

--[[

    Standard SQL library

--]]

sql.escape = (str) -> gsql.SQLStr(str)

sql.query = ( query, ... ) ->
    args, i = { ... }, 0
    query = string.gsub( query, "?", ->
        i += 1
        return sql.escape( args[ i ] )
    )

    Logger\Debug( "Executing SQL query: " .. query )
    result = gsql.Query( query )
    if result == false
        throw SQLError gsql.LastError(), nil, nil, 4

    return result

sql.begin = -> 
    return sql.query( "begin" )

sql.commit = -> 
    return sql.query( "commit" )

sql.rollback = -> 
    return sql.query( "rollback" )

--[[

    Libraries

--]]

do --- http_cache table, used for etag caching in http library
    lib = sql.http_cache = {}
    
    lib.get = ( url ) ->
        ArgAssert( url, 1, "string" )

        result = sql.query( "select etag, content from 'gpm.http_cache' where url=? limit 1", url )
        return result and result[1]

    lib.set = ( url, etag, content ) ->
        ArgAssert( url, 1, "string" )
        ArgAssert( etag, 2, "string" )
        ArgAssert( content, content, "string" )
        if #content > ( 50 * 1024 ) -- 50KB
            -- do not cache content that are larger than 50KB
            return
        
        if string.find( content, "\x00", 1, true )
            -- we are unable to store null bytes in sqlite
            return

        sql.query( "insert or replace into 'gpm.http_cache' (url, etag, timestamp, content) values (?, ?, ?, ?)", url, etag, os.time(), content )

do --- key-value store for gpm
    lib = sql.store = {}

    lib.set = ( key, value ) ->
        ArgAssert( key, 1, "string" )
        ArgAssert( value, 2, "string" )

        sql.query( "insert or replace into 'gpm.store' values (?, ?)", key, value )
        return
    
    lib.get = ( key ) ->
        ArgAssert( key, 1, "string" )

        result = sql.query( "select value from 'gpm.store' where key=?", key )
        return result and result[1].value

--[[

    Migrations

--]]

sql.migrations = [
    {
        name: "initial"
        execute: -> -- deprecated
    },
    {
        name: "http_cache add primary key"
        execute: ->
            sql.query( "drop table if exists 'gpm.http_cache'" )
            sql.query( [[create table 'gpm.http_cache' (
                url text primary key, 
                etag text,
                timestamp int, 
                content blob
            )]] )
    }
    {
        name: "added key-value store",
        execute: ->
            sql.query( "create table 'gpm.store' ( key text unique, value text )" )
    }
]

-- migration history table
unless gsql.TableExists( "gpm.migration_history" )
    sql.query "create table 'gpm.migration_history' (name text, timestamp int)"

sql.migrationExists = (name) ->
    for m in *sql.migrations
        if m.name == name
            return true
    return false

sql.runMigration = (migration) ->
    unless isfunction( migration.execute )
        throw SQLError "Migration '#{migration.name}' does not have an execute function"

    Logger\Debug( "Running migration '#{migration.name}'..." )

    sql.begin() -- begin transaction so we can rollback if something goes wrong
    ok = xpcall( migration.execute, SQLError.display )

    if ok
        sql.query( "insert into 'gpm.migration_history' (name, timestamp) values (?, ?)", migration.name, os.time() )
        sql.commit()
    else
        sql.rollback()
    
    return ok


sql.migrate = (name) ->
    unless isstring( name )
        throw SQLError "Migration name must be a string, not #{name}"

    history = sql.query( "select name from 'gpm.migration_history'" ) or {}
    for m in *history
        history[ m.name ] = true

    -- find if given migration name exists
    unless sql.migrationExists( name )
        throw SQLError "Migration '" .. name .. "' not found"
    
    -- first execute migrations
    for m in *sql.migrations
        unless history[ m.name ] 
            if sql.runMigration( m ) == false
                break

        if m.name == name -- this is our last migration
            break
