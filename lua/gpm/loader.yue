gpm = gpm
import Environment from gpm
import URL, Promise, Error, path, string, file, rawget, getfenv from Environment
import getfmain, getfpathi from Environment.debug
import sub, find, gsub, len, match from string
import async, await, saveAwait from Promise
import Fetch from Environment.http

class ModuleURLResolutionError extends Error
Environment.ModuleURLResolutionError = ModuleURLResolutionError

class InvalidModuleSpecifierError extends Error
Environment.InvalidModuleSpecifierError = InvalidModuleSpecifierError

class ModuleLoadError extends Error
Environment.ModuleLoadError = ModuleLoadError

class ModuleNotFoundError extends Error
Environment.ModuleNotFoundError = ModuleNotFoundError

:loader = gpm
unless istable( loader )
    loader = gpm.loader = {}

--[[

    tasks = {}
    for package in packages
        tasks[] = asyncImport package, parentURL

    for task in tasks
        task\Catch (err) ->
            print err

    _PKG.name
    _PKG.metadata.name
    _PKG\GetEnvironment! == getfenv(1)
    PARENT_URL

    _PKG == gpm.Package!

    _PKG.Tasks = {
        metadata: Promise 1
        download: Primise 2
    }

    Packages = { }

    -- package://PackageA/module1 -> lua://packages/PackageA/module1/package.lua
    -- lua://niknaks/package.lua

    lua://my_package/init.lua   - single file package
    lua://my_package            - multi file package ( package.lua and other files )

    NewPackage = ( url ) ->
        -- example1: url = "package://PackageA"
        -- example1: url = "lua://my_package"
        url = resolveURL( url )

        -- example1: url = "lua://packages/PackageA"
        -- example2: url = "lua://my_package"

        package = Packages[ url ]
        unless package
            package = gpm.Package( url )
            Packages[ url ] = package

        return package

    Package A:
        Code:
            ents.MyFunc = ->
                print( "FUnc!" )

            print COLLISION_GROUP_CUSTOM

        Depends:
            Package B:
                Globals:
                    markers = {}

    Package C:
        Code:
            print COLLISION_GROUP_CUSTOM
            ents.MyFunc!

        Depends:
            Package D:
                Globals:
                    markers = {}

            Package B:

    Output:
            FUnc!
            1
            2

]]

-- Simple module loader that takes url and tries to get module entry
loader.LoadURL = async ( urlStr, parentPackage ) ->
    url = URL.parse( urlStr )
    :scheme = url

    local entry_fn
    if scheme == "lua"
        entry_fn = await file.Compile( url.pathname, "LUA" )
        unless entry_fn
            error ModuleLoadError "failed to compile file " .. url.pathname

    elseif scheme == "http" or scheme == "https"
        ext = string.GetExtensionFromFilename( url.pathname )
        if ext ~= "lua"
            error ModuleLoadError "unsupported web url: " .. url.href

        req = await Fetch( url.href )
        unless req and req.code == 200 and req.body
            error ModuleLoadError "failed to fetch " .. url.href

        entry_fn = CompileString( req.body, url.href )
        unless entry_fn
            error ModuleLoadError "failed to compile file " .. url.href
    else
        error ModuleLoadError "unsupported url: " .. url.href

    genv = parentPackage and parentPackage\GetEnvironment! or gpm.CreateEnvironment!

    env = setmetatable( {
        _PKG: parentPackage
        _URL: url.href
    },
    {
        __index: genv
        __newindex: genv
    } )

    return setfenv( entry_fn, env )

resolvePackagePath = ( currentPath, specifier, subPathIsLocal ) ->
    local filePath
    if currentPath == ""
        filePath = path.Resolve( "packages", specifier )
    else
        filePath = path.Resolve( currentPath, "packages", specifier )

    if file.Exists( filePath, "LUA" )
        pkg = await gpm.ParsePackage( path.Join( filePath, "package.lua" ) ) -- TODO: lookup package in global table

        -- TODO: If pmeta is not null and pmeta.exports is not null or undefined, then
        -- Return the result of PACKAGE_EXPORTS_RESOLVE(filePath, packageSubpath, pjson.exports, defaultConditions).
        if not subPathIsLocal or pkg.entry
            return pkg\LoadURL( "lua:" .. path.Join( pkg.dir, pkg.entry ) )

    if currentPath ~= ""
        return resolvePackagePath( sub( string.GetPathFromFilename( currentPath ), 1, -2 ), specifier, subPathIsLocal )

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
loader.PackageResolve = async ( specifier, parentURL, parentPackage ) ->
    local packageName
    if specifier == ""
        error InvalidModuleSpecifierError specifier

    if string.StartsWith( specifier, "@" )
        unless match( specifier, "/" ) -- check if specifier even has /
            error InvalidModuleSpecifierError specifier

        packageName = match( specifier, "(@[^/]*/[^/]*)" )
    else
        packageName = match( specifier, "([^/]*)" )

    if sub( packageName, 1, 1 ) == "." or match( packageName, "[\\%%]" )
        error InvalidModuleSpecifierError specifier

    subPath = "." .. sub( specifier, len( packageName ) + 1 )
    -- if string.EndsWith( subPath, "/" )
    if sub( subPath, -1 ) == "/"
        error InvalidModuleSpecifierError specifier

    -- TODO make PACKAGE_SELF_RESOLVE
    -- if specifier := packageSelfResolve packageName, subPath, parentURL
    --     return specifier

    parentPath = URL.parse( parentURL )\getPath!
    if parentPath == ""
        parentPath = "./"

    entry_fn = resolvePackagePath( parentPath, specifier, subPath == "." )
    if entry_fn
        return entry_fn

    error ModuleNotFoundError specifier
    return

-- Simplest vanilla lua `require` implementation
-- Not uses package or any other fancy stuff
-- package.path is hardcoded into it :p
do

    templates = {
        ".lua"
        "/init.lua"
    }

    length = #templates

    if CLIENT
        length += 1
        templates[ length ] = "/cl_init.lua"

    length += 1
    templates[ length ] = "/shared.lua"

    loader.RequireResolve = async ( specifier, parentURL, parentPackage ) ->
        specifier = gsub( specifier, "%.", "/" )
        url = URL.parse( parentURL )

        for index = 1, length
            success, entry = saveAwait loader.LoadURL( url\resolve( specifier .. templates[ index ] ), parentPackage )
            if success and entry
                return entry

-- Simple URL resolver based on https://nodejs.org/api/esm.html#resolution-algorithm-specification
-- without packageResolve since it is more advanced and not needed for now
loader.ResolveURL = ( specifier, parentURL ) ->
    url = URL.parse( specifier )
    if url.scheme
        return url\format!

    -- parent-url: lua:/example/foo.lua
    -- url: ../config.lua
    -- result: lua:/config.lua
    if find( url.pathname, "%.?%.?/", 1, false )
        -- If specifier is relative path then resolve it against parentURL
        return URL.resolve( parentURL, url.pathname )\format!

-- Resolves specifier and returns a promise with entry function
loader.Resolve = async ( specifier, parentURL = "lua:", parentPackage ) ->
    -- First lets try to resolve as URL
    resolved = loader.ResolveURL( specifier, parentURL )
    if resolved
        return loader.LoadURL( resolved, parentPackage )

    -- Try to resolve as vanilla `require`
    entry = await loader.RequireResolve( specifier, parentURL, parentPackage )
    if entry
        return entry

    -- Try to resolve as package
    return loader.PackageResolve( specifier, parentURL, parentPackage )

-- TODO: What is this for?
asyncImport = async ( specifier, parentURL, parentPackage ) ->
    entry_fn = await loader.Resolve( specifier, parentURL, parentPackage )
    entry_fn = async entry_fn -- convert entry to async function
    return entry_fn!

loader.AsyncImport = asyncImport

getParentURL = ->
    if entry := getfmain!
        -- Get URL from entry env
        env = getfenv( entry )
        if value := env and rawget( env, "_URL" )
            return value

        -- Try to resolve URL from entry source
        if folderPath := getfpathi( entry )
            url = URL.parse( folderPath )
            url.protocol or= "lua"
            return url\format!

    return "lua:" -- default fallback

loader.GetParentURL = getParentURL

getPackage = ->
    if func := getfmain!
        env = getfenv( func )
        return env and rawget( env, "_PKG" )

loader.GetPackage = getPackage

gpm.Import = ( url, should_await ) ->
    result = asyncImport( url, getParentURL!, getPackage! )
    if should_await ~= false
        return await( result )

    return result

Environment.require = gpm.Import
