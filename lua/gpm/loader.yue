_G = _G
import gpm, getmetatable, setmetatable, rawset from _G
import environment from gpm

import debug, string, path, table, file, util, pairs, isurl, isstring, ArgAssert, URL, NotImplementedError, ModuleError, error, pcall, PackageError from environment
import async, await, reject, SafeAwait, STATE_REJECTED from environment.Promise
import stripExtension from path
import getfpath from debug
import Find from file

file.CreateDir( "/data/gpm/vfs", true )

_G.hook.Add "ShutDown", "GLua Package Manager::VFS", ->
    file.Delete( "/data/gpm/vfs" )
    return nil

:loader = gpm
unless istable( loader )
    -- Modules and Packages are tables with format: [url] = Module/Package
    loader = gpm.loader = {}

packages = loader.Packages = {}
modules = loader.Modules = {}

local repositories

if SERVER or MENU_DLL
    import Query from _G.sql

    Query( "CREATE TABLE IF NOT EXISTS `gpm.table_version` ( Name TEXT PRIMARY KEY NOT NULL, Version INT )" )
    Query( "CREATE TABLE IF NOT EXISTS `gpm.repository` ( ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, URL TEXT NOT NULL )" )
    Query( "CREATE TABLE IF NOT EXISTS `gpm.packages` ( Name TEXT PRIMARY KEY NOT NULL, URL TEXT UNIQUE NOT NULL, InstalledVersion TEXT, RepositoryID INTEGER DEFAULT 0 NOT NULL, FOREIGN KEY(repositoryID) REFERENCES `gpm.repository` (ID) )" )

    repositories = Query( "SELECT * FROM `gpm.repository`" ) or {}

    length = #repositories
    if length == 0
        Query( "INSERT INTO `gpm.repository` ( URL ) VALUES ( 'https://raw.githubusercontent.com/Pika-Software/.github/main/gpm/repositories.json' )" )
        repositories = Query( "SELECT * FROM `gpm.repository`" ) or {}

    for index = 1, length
        repository = repositories[ index ]
        repository.Packages = Query( "SELECT * FROM `gpm.packages` WHERE RepositoryID = " .. repository.ID ) or {}

    loader.Repositories = repositories

if SERVER
    filePath = "/lua/gpm/vfs/repositories.lua"
    file.Set( filePath, "return '" .. util.TableToJSON( repositories, false ) .. "'", "GLua Package Manager::Repositories" )
    file.AddCSLuaFile( filePath )

if CLIENT
    repositories = include( "gpm/vfs/repositories.lua" )
    if repositories
        repositories = loader.Repositories = util.JSONToTable( repositories )

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
import sub, byte, find, match, gsub, format, StartsWith, IsURL from string
import IsFile, NormalizeGamePath from file

local Module, Package
do

    import getDirectory, getFileName, getExtension from path
    import AsyncWrite, Time from file
    import PathFromURL from string
    import IsEmpty from table
    import Version from util
    import tobool from _G

    startTime = environment.os.time! - ( gpm.StartTime or 0 )

    class Module
        __tostring: =>
            return format( "Module: %p [%s]", @, @name )

        new: ( @location, @url, @env = _G ) =>
            unless isurl( url )
                error ModuleError "url is " .. type( url ) .. ", expected URL"

            @name = getfpath( location ) or "unknown"

            :pathname = url
            setfenv( location, setmetatable({ __module: @, __filename: pathname, __dirname: getDirectory( pathname, false ) }, { __index: env, __newindex: env }) )

            modules[ url.href ] = @
            return nil

        run: ( ... ) =>
            -- if result := @result
            --     return result

            -- result = @result = async( @location )( ... )
            -- return result
            return async( @location )( ... )

        @getAll: -> modules

        @get: ( url ) -> modules[ url.href ]

        @cache: async ( url, content ) ->
            filePath = "/data/gpm/vfs/" .. stripExtension( PathFromURL( url ) ) .. ".txt"
            if IsFile( filePath ) and Time( filePath ) >= startTime
                return filePath

            return AsyncWrite( filePath, content )

        @run: ( location, url, env ) ->
            m = modules[ url.href ]
            unless m
                m = Module( location, url, env )

            return m\run!

    loader.Module = Module

    environment.ismodule = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Module

    do

        import AsyncCompile from file
        import Logger from util
        import Merge from table

        default = environment.Color( 50, 100, 200 )\DoCorrection!
        environmentMetatable = { __index: environment }

        hooksMeta = {
            __index: ( tbl, key ) ->
                new = {}
                rawset( tbl, key, new )
                return new
        }

        class Package
            __tostring: =>
                return format( "Package: %p [%s@%s]", @, @name, @version )

            new: ( filePath, info ) =>
                @path = filePath

                unless info
                    @name = match( filePath, ".*packages/([^/]+)" ) or getFileName( filePath, false )
                    @version = Version( "0.1.0" )
                    return nil

                -- name
                name = info.name
                unless isstring( name )
                    name = match( filePath, ".*packages/([^/]+)" ) or getFileName( filePath, false )

                if not name or name == ""
                    name = format( "%p", @ )

                @name = name

                -- version
                :version = info
                unless isstring( version )
                    version = "0.1.0"

                version = Version( version )
                @version = version

                -- autorun
                @autorun = tobool( info.autorun )

                -- send
                :send = info
                unless istable( send )
                    send = {}

                @send = send

                -- exports
                :exports = info
                if isstring( exports )
                    exports = { [ "." ]: exports }
                elseif not istable( exports )
                    exports = nil

                @exports = exports

                -- imports
                :imports = info
                if isstring( imports )
                    imports = { [ "." ]: imports }
                elseif not istable( imports )
                    imports = nil

                @imports = imports

                -- dependencies
                :dependencies = info
                unless istable( dependencies )
                    dependencies = nil

                @dependencies = dependencies

                -- logger
                :logger = info
                unless istable( logger )
                    logger = {
                        interpolation: true
                        disabled: false
                        color: default
                    }

                @logger = logger

                -- description
                :description = info
                unless isstring( description )
                    description = "Description not provided"

                @description = description

                -- license
                :license = info
                unless isstring( license )
                    license = "License not provided"

                @license = license

                -- homepage
                :homepage = info
                unless isstring( homepage )
                    homepage = "Homepage not provided"

                @homepage = homepage

                -- package logger
                if logger
                    if logger.disabled
                        logger = nil
                    else
                        logger = Logger( name .. "@" .. version\__tostring!, logger.color, logger.interpolation )
                else
                    logger = Logger( name .. "@" .. version\__tostring! )

                @__hooks = setmetatable( {}, hooksMeta )
                @__prefix = @__tostring! .. "::"
                @__timers = {}

                -- package environment
                @env = setmetatable( { __package: @, Logger: logger }, environmentMetatable )

            -- directly reads package info from given filePath and creates Package
            -- do not use this method directly, use Package.read instead
            @parse: async ( filePath, gamePath, config ) ->
                compileResult = await AsyncCompile( filePath, {}, config, gamePath, true )
                await Module.cache( "file://" .. compileResult.path, compileResult.content )
                func = compileResult.func

                info = {}
                setfenv( func, info )
                success, result = pcall( func )
                if success
                    if istable( result )
                        Merge( info, result )

                    if IsEmpty( info )
                        error PackageError "file '#{filePath}' does not contain valid package info (empty or cannot be parsed)"
                        return nil

                    return Package( filePath, info )

                error PackageError "package info '" .. filePath .. "' execution error: " .. result
                return nil

            -- Finds a package info in given url.
            -- If package.* file was not given in path, tries to find it.
            -- Also caches the package by URL.
            @read: async ( url ) ->
                if isstring( url )
                    url = URL( url )

                unless isurl( url )
                    error PackageError "invalid url '" .. url.href .. "'"

                if url.scheme ~= "file"
                    -- error PackageError "unsupported scheme '" .. url.scheme .. "' ('" .. url.href .. "')"
                    return nil

                unless istable( url.path )
                    -- error PackageError "invalid path '" .. url.pathname .. "' ('" .. url.href .. "')"
                    return nil

                cached = packages[ url.href ]
                if cached
                    if cached.state ~= STATE_REJECTED
                        return cached

                    -- clear cache if parsing failed
                    packages[ url.href ] = nil

                filePath, gamePath = NormalizeGamePath( url.pathname )
                fileDir = getDirectory( filePath, true )

                -- if not package.* file was given in url, try to find it smartly
                if getFileName( filePath, false ) ~= "package"
                    files = Find( fileDir .. "/package.*", gamePath, true )
                    if #files == 1
                        filePath = fileDir .. files[ 1 ]

                    elseif #files > 1
                        -- Smartly decide which file to use
                        values = {} -- [ext] = filePath
                        for fileName in *files
                            values[ getExtension( fileName, false ) ] = fileName

                        filePath = fileDir .. values.yue or values.moon or values.lua or values[ 1 ]

                unless IsFile( filePath, gamePath, true )
                    -- error PackageError "file '" .. filePath .. "' does not exist for packageURL '" .. url.href .. "'"
                    return nil

                config = {}
                for key, value in url.searchParams\iterator!
                    config[ key ] = value

                -- also cache result so next calls will return current package
                promise = Package.parse( filePath, gamePath, config )
                packages[ url.href ] = promise
                return promise

    environment.ispackage = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Package

-- TODO: after this works as specs intended, optimize it and make better!
local ESM
do

    import canParse from URL
    import IsDir from file

    class ESM
        DEFAULT_CONDITIONS = {
            [SERVER and "server" or CLIENT and "client" or MENU_DLL and "menu" or "default"]: true,
        }

        -- Just a shortcut so `ESM.resolve ...` can be used instead of creating a new instance.
        @resolve: ( ... ) -> ESM!\resolve( ... )

        -- ESM_RESOLVE(specifier, parentURL)
        resolve: async ( specifier, parentURL ) =>
            @specifier = specifier
            @parentURL = parentURL

            local resolved

            -- resolve
            if isurl( specifier ) or canParse( specifier )
                resolved = URL( specifier )
            elseif StartsWith( specifier, "/" ) or StartsWith( specifier, "./" ) or StartsWith( specifier, "../" )
                resolved = URL( specifier, parentURL )
            elseif StartsWith( specifier, "#" )
                resolved = packageImportsResolve( @, specifier, parentURL )
            else
                -- specifier is now a bare specifier
                resolved = packageResolve( @, specifier, parentURL )

            return { :resolved, package: @pjson }

        -- PACKAGE_RESOLVE(packageSpecifier, parentURL)
        packageResolve = ( packageSpecifier, parentURL ) =>
            local packageName
            if packageSpecifier == ""
                error PackageError "specifier is an empty string"

            -- If packageSpecifier is a Node.js builtin module name, then
            -- 1. Return the string "node:" concatenated with packageSpecifier.

            if not StartsWith( packageSpecifier, "@" )
                packageName = match( packageSpecifier, "(.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the first "/" separator or the end of the string.
            else
                packageName = match( packageSpecifier, "(.-/.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the second "/" separator or the end of the string.
                if not packageName -- If packageSpecifier does not contain a "/" separator, then
                    error PackageError "invalid specifier '#{packageSpecifier}'"

            if StartsWith( packageSpecifier, "." ) or find( packageSpecifier, "%", 1, true ) or find( packageSpecifier, "\\", 1, true )
                error PackageError "invalid specifier '#{packageSpecifier}'"

            packageSubpath = "." .. sub( packageSpecifier, #packageName + 1 )

            if selfURL := packageSelfResolve( @, packageName, packageSubpath, parentURL )
                return selfURL

            local packageURL
            while not packageURL or packageURL.path[1] ~= "packages" -- While parentURL is not the file system root
                firstTime = not packageURL

                packageURL = URL( "packages/" .. packageName .. "/", parentURL ) -- Let packageURL be the URL resolution of "node_modules/" concatenated with packageSpecifier, relative to parentURL.
                parentURL = URL( "..", parentURL ) -- Set parentURL to the parent folder URL of parentURL.

                if packageURL.scheme == "file" and not IsDir( packageURL.pathname ) -- If the folder at packageURL does not exist, then
                    if result := firstTime and packageDependenciesResolve( @, packageName, packageSubpath )
                        return result

                    continue

                pjson = @pjson = await Package.read( packageURL )
                if pjson and pjson.exports
                    return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

                return URL( packageSubpath, packageURL )

            error PackageError "package not found: '#{packageSpecifier}' from '#{@parentURL}'"
            return

        -- PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL)
        packageSelfResolve = ( packageName, packageSubpath, parentURL ) =>
            packageURL = lookupPackageScope( @, parentURL )
            if not packageURL
                return

            pjson = @pjson = await Package.read( packageURL )
            if not pjson or not pjson.exports
                return

            if pjson.name == packageName
                return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

        packageDependenciesResolve = ( packageName, packageSubpath ) =>
            -- @pjson must be set by packageSelfResolve
            pjson = @pjson
            if not pjson or not istable(pjson.dependencies)
                return

            target = pjson.dependencies[ packageName ]
            if isstring( target )
                return packageDependencyResolve( @, packageName, target, packageSubpath )

        packageDependencyResolve = ( name, target, subpath ) =>
            if not target or #target == 0
                error PackageError "invalid dependency target '#{target}' for '#{name}'"

            -- TODO: add installed package resolving
            unless IsURL( target )
                error PackageError "unsupported dependency target '#{target}' from '#{name}'"

            target = URL( target )

            -- Convert target url to file:///
            if target.scheme ~= "file"
                error PackageError "unsupported scheme #{target.scheme} ('#{target}') from '{#name}'"

            packageURL = URL( ".", target ) -- remove file from url (basically same as path.dirname)
            unless IsDir( packageURL.pathname )
                return

            pjson = @pjson = await Package.read( packageURL )
            if pjson and pjson.exports
                return packageExportsResolve( @, packageURL, subpath, pjson.exports )

            return URL( packageSubpath, packageURL )

        exportsStartsWithDot = ( exports, packageURL ) =>
            if istable( exports )
                local state
                for k in pairs( exports )
                    statsWithDot = StartsWith( k, "." )
                    if state == nil
                        state = statsWithDot
                    elseif state ~= statsWithDot
                        error PackageError "'#{packageURL}' exports are invalid"
                return state
            -- otherwise exports must be a string
            return StartsWith( exports, "." )

        -- PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)
        packageExportsResolve = ( packageURL, subpath, exports ) =>
            startsWithDot = exportsStartsWithDot( @, exports, packageURL )

            if subpath == "."
                local mainExport
                if isstring( exports ) or not startsWithDot
                    mainExport = exports
                elseif istable( exports ) and startsWithDot
                    mainExport = exports["."]

                if mainExport
                    if resolved := packageTargetResolve( @, packageURL, mainExport, nil, false )
                        return resolved
            elseif istable( exports ) and startsWithDot
                if resolved := packageImportsExportsResolve( @, subpath, exports, packageURL, false )
                    return resolved

            error PackageError "no exports found for '#{subpath}' in '#{packageURL}'"
            return

        -- PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)
        packageImportsResolve = ( specifier, parentURL ) =>
            if specifier == "#" or StartsWith( specifier, "#/" )
                error PackageError "invalid import specifier '" .. specifier .. "'"

            packageURL = lookupPackageScope( @, parentURL )
            if packageURL
                pjson = @pjson = await Package.read( packageURL )
                if pjson and pjson.imports
                    if resolved := packageImportsExportsResolve( @, specifier, pjson.imports, packageURL, true )
                        return resolved

            error PackageError "imports are not defined for '" .. specifier .. "' in #{packageURL or parentURL}"
            return

        -- PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports)
        packageImportsExportsResolve = ( matchKey, matchObj, packageURL, isImports ) =>
            if matchObj[matchKey] and not find( matchKey, "*", 1, true )
                target = matchObj[matchKey]
                return packageTargetResolve( @, packageURL, target, nil, isImports )

            -- TODO: Implement pattern matching
            error PackageError "pattern matching is not implemented"
            return

        -- PACKAGE_TARGET_RESOLVE(packageURL, target, patternMatch, isImports, conditions)
        packageTargetResolve = ( packageURL, target, patternMatch, isImports ) =>
            if isstring( target )
                unless StartsWith( target, "./" )
                    if isImports == false or StartsWith( target, "/" ) or StartsWith( target, "../" ) or canParse( target )
                        error PackageError "invalid target '#{target}' for '#{packageURL}'"
                        return nil

                    if isstring( patternMatch )
                        return packageResolve( @, gsub( target, "*", patternMatch ), packageURL )

                    return packageResolve( @, target, packageURL )

                -- TODO: If target split on "/" or "\" contains any "", ".", "..", or "node_modules" segments after the first "." segment, case insensitive and including percent encoded variants, throw an Invalid Package Target error.

                resolvedTarget = URL( target, packageURL )
                if patternMatch == nil
                    return resolvedTarget

                -- TODO: If patternMatch split on "/" or "\" contains any "", ".", "..", or "node_modules" segments, case insensitive and including percent encoded variants, throw an Invalid Module Specifier error.
                resolvedTarget.pathname = gsub( resolvedTarget.pathname, "*", patternMatch )
                return resolvedTarget

            if istable( target )
                if #target == 0 -- object
                    local defaultValue
                    for p, targetValue in pairs( target )
                        if DEFAULT_CONDITIONS[ p ]
                            if resolved := packageTargetResolve( @, packageURL, targetValue, patternMatch, isImports )
                                return resolved

                        elseif p == "default"
                            defaultValue = targetValue

                    -- resolving "default" at the end because tables in lua are unordered
                    if defaultValue
                        return packageTargetResolve( @, packageURL, defaultValue, patternMatch, isImports )

                    return nil

                -- array
                local success, resolved
                for targetValue in *target
                    success, resolved = pcall( packageTargetResolve, @, packageURL, targetValue, patternMatch, isImports )
                    if success and resolved
                        return resolved

                unless success
                    error resolved
                    return nil

                return nil

            if target == nil
                return nil

            error PackageError "invalid target '#{target}' for '#{packageURL}'"
            return nil

        -- LOOKUP_PACKAGE_SCOPE(url)
        lookupPackageScope = ( url ) =>
            if url.scheme ~= "file"
                error PackageError "unable to lookup package scope for '#{url}' (not a file:/// URL)"

            local scopeURL = URL( "./package.lua", url )
            while scopeURL.path[1] ~= "package.lua" -- not filesystem root
                if scopeURL.path[ #scopeURL.path - 1 ] == "packages"
                    return nil

                if IsFile( scopeURL.pathname )
                    return URL( "./", scopeURL )

                scopeURL = URL( "../package.lua", scopeURL )

    loader.ESM = ESM

local Require
do

    PACKAGE_PATHS = { "./?.lua", "./?/init.lua" }
    import IsBinaryModuleInstalled from util
    import tostring from environment

    isRequireSyntax = ( modname ) ->
        return match( modname, "^[%a%d_%-.]+$" )

    resolveFile = ( filePath, base ) =>
        for pattern in *PACKAGE_PATHS
            url = URL( gsub( pattern, "%?", filePath ), base )
            if IsFile( url.pathname )
                return url

        return nil

    class Require
        -- Just a shortcut so `Require.resolve ...` can be used instead of creating a new instance.
        @resolve: ( ... ) -> Require!\resolve( ... )

        resolve: async ( modname, base ) =>
            unless base
                error ModuleError "`require` cannot be used outside of modules"

            if base.scheme ~= "file"
                error NotImplementedError "cannot use `require` from `#{base}`"

            isOpaque = isRequireSyntax( modname )
            filePath = gsub( modname, "%.", "/" )

            if resolved := isOpaque and resolveFile( @, filePath, base )
                return { :resolved }

            if StartsWith( filePath, "gpm/" ) or StartsWith( filePath, "garrysmod/" ) or StartsWith( filePath, "gmod/" )
                protocol, filePath = match( filePath, "^(.-)/(.*)" )
                filePath = tostring( URL( protocol .. ":///" .. filePath ) )

            success, resolved = try await ESM.resolve( isOpaque and filePath or modname, base )
            if success
                return resolved

            if IsBinaryModuleInstalled( modname )
                return { resolved: URL( "dll:" .. modname ) }

            -- TODO: make better errors
            error resolved -- just return error from ESM
            return

    loader.Require = Require

class Include
    -- Just a shortcut so `Include.resolve ...` can be used instead of creating a new instance.
    @resolve: ( ... ) -> Include!\resolve( ... )

    resolve: async ( fileName, base ) =>
        if base and base.scheme == "file"
            resolved = URL( fileName, base )
            if resolved.path[ 1 ] == "lua" and IsFile( resolved.pathname )
                return { :resolved }

        resolved = URL( fileName, "file:///lua/" )
        if resolved.path[ 1 ] == "lua" and IsFile( resolved.pathname )
            return { :resolved }

        return ESM.resolve( fileName, base )

loader.Include = Include

local findSource
do

    import SourceError from environment

    sources = loader.Sources
    unless istable( sources )
        sources = loader.Sources = {}

    findSource = loader.FindSource = ( scheme ) ->
        source = sources[ scheme ]
        if source
            return source

        error SourceError "Source for scheme '#{scheme}' not implemented."
        return

    registerSource = loader.RegisterSource = ( scheme, source ) ->
        sources[ scheme ] = source

    class loader.BaseSourceHandler
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source handler", @ )

        FetchInfo: async ( url, base, env, parent ) =>
            return nil

        Install: async ( url, info, base, env, parent ) =>
            error NotImplementedError "Source:Install( url, info, base, env, parent )"
            return

    class loader.BaseSource
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source", @ )

        new: ( ... ) =>
            @handlers = {}

            for scheme in *{ ... }
                registerSource( scheme, @ )

        RegisterHandler: ( handler ) =>
            @handlers[] = handler

        CallHandler: ( name, url, ... ) =>
            for handler in *@handlers
                if not handler.ShouldHandle or handler\ShouldHandle( url, ... )
                    return handler[ name ]( handler, url, ... )

            return reject SourceError "No handler found for URL '#{url}' (" .. name .. ")"

        FetchInfo: ( url, base, env, parent ) =>
            return @CallHandler( "FetchInfo", url, base, env, parent )

        Install: ( url, info, base, env, parent ) =>
            return @CallHandler( "Install", url, info, base, env, parent )

    parseFileURL = loader.ParseFileURL = ( any ) ->
        if isurl( any )
            return any

        if isstring( any ) and IsURL( any )
            return URL( any )

    getFileURL = loader.GetFileURL = ( any ) ->
        url = parseFileURL( any )
        unless url
            error SourceError "Invalid URL: #{any}"

        unless url.scheme
            error SourceError "Invalid protocol for URL: #{any}"

        return url

    loader.FetchInfo = async ( url, base, env, parent ) ->
        url = getFileURL( url )
        return findSource( url.scheme )\FetchInfo( url, base, env, parent )

    asyncImport = loader.AsyncImport = async ( specifier, resolver, info, base = URL( "file:///lua/" ), env, parent ) ->
        :resolved, :package = await resolver( specifier, base )

        -- if package was found, then it must overwrite current env
        if package
            env = package.env or env

        source = findSource( resolved.scheme )

        unless info
            info = await source\FetchInfo( resolved, base, env, parent )

        return source\Install( resolved, info, base, env, parent )

    local getImportMeta
    do

        import getfenv, rawget from _G
        import getfmain from debug

        getModule = loader.GetModule = ( func = getfmain! ) ->
            if fenv := func and getfenv( func )
                return rawget( fenv, "__module" )

        getURL = loader.GetURL = ( func = getfmain! ) ->
            if fpath := func and getfpath( func )
                if fenv := getfenv( func )
                    if m := rawget( fenv, "__module" )
                        if url := m.url
                            return url

                if IsURL( fpath )
                    return URL( fpath )

                return URL( "file:///" .. fpath )

        getParentURL = loader.GetParentURL = ( m = getModule! ) ->
            return m and m.url or nil

        getEnvironment = loader.GetEnvironment = ( m = getModule! ) ->
            return m and m.env or nil

        getPackage = loader.GetPackage = ( env = getEnvironment! ) ->
            return env and env.__package or nil

        getImportMeta = loader.GetImportMeta = ->
            local base, parent, env
            if fmain := getfmain!
                if m := getModule( fmain )
                    base = getParentURL( m )
                    env = getEnvironment( m )
                    parent = getPackage( env )

                base or= getURL( fmain )

            return base, env, parent

    gpm.Import = ( specifier ) ->
        ArgAssert( specifier, 1, "string" )
        return asyncImport( specifier, ESM.resolve, nil, getImportMeta! )

    -- just for a .lua users
    environment.import = ( specifier ) ->
        ArgAssert( specifier, 1, "string" )
        return await asyncImport( specifier, ESM.resolve, nil, getImportMeta! )

    environment.require = ( modname ) ->
        ArgAssert( modname, 1, "string" )
        return await asyncImport( modname, Require.resolve, nil, getImportMeta! )

    environment.include = environment.dofile = ( fileName ) ->
        ArgAssert( fileName, 1, "string" )
        return await asyncImport( fileName, Include.resolve, nil, getImportMeta! )

-- packages autorun
do

    import display from environment.Error
    import resolve from ESM
    import Logger from gpm

    loader.Startup = async ->
        base = URL( "file:///lua/" )

        _, folders = Find( "packages/*", file.LuaPath, true )
        for folderName in *folders
            ok, result = SafeAwait resolve( folderName, base )
            unless ok
                display( result )
                continue

            :resolved, :package = result
            unless package and package.autorun
                continue

            Logger\Debug( "Package autorun: " .. package\__tostring! )

            source = findSource( resolved.scheme )
            unless source
                continue

            :env = package

            ok, result = SafeAwait source\FetchInfo( resolved, base, env, nil )
            unless ok
                display( result )
                continue

            ok, result = SafeAwait source\Install( resolved, result, base, env, nil )
            unless ok
                display( result )

        return nil
