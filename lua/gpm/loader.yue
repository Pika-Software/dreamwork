_G = _G
import gpm from _G
import environment, CreateEnvironment from gpm
import URL, isurl, isstring, Promise, path, string, file, metaworks, rawget, getfenv from environment
import sub, find, gsub, len, match, format from string
import NotImplementedError, Error from environment
import getfmain, getfpathi from environment.debug
import async, await, saveAwait from Promise
import Fetch from environment.http

class ModuleURLResolutionError extends Error
environment.ModuleURLResolutionError = ModuleURLResolutionError

class InvalidModuleSpecifierError extends Error
environment.InvalidModuleSpecifierError = InvalidModuleSpecifierError

class ModuleLoadError extends Error
environment.ModuleLoadError = ModuleLoadError

class ModuleNotFoundError extends Error
environment.ModuleNotFoundError = ModuleNotFoundError

class SourceError extends environment.Error
environment.SourceError = SourceError

:loader = gpm
unless istable( loader )
    loader = gpm.loader = {}

:sources = gpm
unless istable( sources )
    sources = gpm.Sources = {}

--[[

    file://path/to/file/in/game
    game://path/to/file/in/game
    data://path/to/file/in/data
    lua://path/to/file/in/lua

    Sources: {
        file: Source Obj1
        game: Source Obj1
        data: Source Obj1
        lua: Source Obj1
        http: Source Obj2
        https: Source Obj2
    }

]]

-- Individual file environment
loader.GetFileEnvironment = getfenv

loader.SetFileEnvironment = ( location, url, pkg ) ->
    env = pkg and pkg\GetEnvironment! or CreateEnvironment!

    return setfenv( location, setmetatable(
        { _URL: url, _PKG: pkg, _ENV: env },
        { __index: env, __newindex: env }
    ) )

-- Source classes
class gpm.BaseSourceHandler
    __tostring: =>
        return format( "%s: %p", @@__name or "unknown source handler", @ )

    FetchInfo: async ( url ) =>
        error NotImplementedError "Source:FetchInfo(url)"
        return

    Install: async ( url, info ) =>
        error NotImplementedError "Source:Install(url, info)"
        return

class gpm.BaseSource
    __tostring: =>
        return format( "%s: %p", @@__name or "unknown source", @ )

    new: =>
        @handlers = {}

    RegisterHandler: ( handler ) =>
        @handlers[] = handler

    CallHandler: ( name, url, ... ) =>
        for handler in *@handlers
            if not handler.ShouldHandle or handler\ShouldHandle( url, ... )
                return handler[ name ]( handler, url, ... )

        return Promise.reject SourceError "No handler found for URL #{url} (" .. name .. ")"

    FetchInfo: ( url ) =>
        return @CallHandler( "FetchInfo", url )

    Install: ( url, info ) =>
        return @CallHandler( "Install", url, info )

gpm.RegisterSource = ( scheme, source ) ->
    sources[ scheme ] = source

findSourceByURL = ( url ) ->
    src = sources[ url.scheme ]
    unless src
        error SourceError "No source found for URL: " .. url.href

    return src

gpm.FindSourceByURL = findSourceByURL

parsePackageURL = ( any ) ->
    if isurl( any )
        return any

    if isstring( any ) and string.IsURL( any )
        return URL.parse( any )

gpm.ParsePackageURL = parsePackageURL

getPackageURL = ( any ) ->
    url = parsePackageURL( any )
    unless url
        error SourceError "Invalid URL: #{any}"

    unless url.scheme
        error SourceError "Invalid protocol for URL: #{any}"

    return url

gpm.GetPackageURL = getPackageURL

loader.FetchInfo = async ( url ) ->
    url = getPackageURL( url )
    return findSourceByURL( url )\FetchInfo( url )

loader.AsyncImport = async ( url, parentURL = "lua:", parentPackage, packageInfo ) ->
    url = getPackageURL( URL.resolve( parentURL or "", url ) )
    src = findSourceByURL( url )

    unless packageInfo
        packageInfo = await src\FetchInfo( url )

    return src\Install( url, packageInfo, parentURL, parentPackage )

--[[

    tasks = {}
    for package in packages
        tasks[] = asyncImport package, parentURL

    for task in tasks
        task\Catch (err) ->
            print err

    _PKG.name
    _PKG.metadata.name
    _PKG\GetEnvironment! == getfenv(1)
    PARENT_URL

    _PKG == gpm.Package!

    _PKG.Tasks = {
        metadata: Promise 1
        download: Primise 2
    }

    Packages = { }

    -- package://PackageA/module1 -> lua://packages/PackageA/module1/package.lua
    -- lua://niknaks/package.lua

    lua://my_package/init.lua   - single file package
    lua://my_package            - multi file package ( package.lua and other files )

    NewPackage = ( url ) ->
        -- example1: url = "package://PackageA"
        -- example1: url = "lua://my_package"
        url = resolveURL( url )

        -- example1: url = "lua://packages/PackageA"
        -- example2: url = "lua://my_package"

        package = Packages[ url ]
        unless package
            package = gpm.Package( url )
            Packages[ url ] = package

        return package

    Package A:
        Code:
            ents.MyFunc = ->
                print( "FUnc!" )

            print COLLISION_GROUP_CUSTOM

        Depends:
            Package B:
                Globals:
                    markers = {}

    Package C:
        Code:
            print COLLISION_GROUP_CUSTOM
            ents.MyFunc!

        Depends:
            Package D:
                Globals:
                    markers = {}

            Package B:

    Output:
            FUnc!
            1
            2

]]

--[[

-- Simple module loader that takes url and tries to get module entry
loader.LoadURL = async ( urlStr, parentPackage ) ->
    url = URL.parse( urlStr )
    :scheme = url

    local entry_fn
    if scheme == "lua"
        entry_fn = await file.Compile( url.pathname, "LUA" )
        unless entry_fn
            error ModuleLoadError "failed to compile file " .. url.pathname

    elseif scheme == "http" or scheme == "https"
        ext = string.GetExtensionFromFilename( url.pathname )
        if ext ~= "lua"
            error ModuleLoadError "unsupported web url: " .. url.href

        req = await Fetch( url.href )
        unless req and req.code == 200 and req.body
            error ModuleLoadError "failed to fetch " .. url.href

        entry_fn = CompileString( req.body, url.href )
        unless entry_fn
            error ModuleLoadError "failed to compile file " .. url.href
    else
        error ModuleLoadError "unsupported url: " .. url.href

    -- Package environment
    env = parentPackage and parentPackage\GetEnvironment! or CreateEnvironment!

    -- Func environment
    return setfenv( entry_fn, setmetatable(
            {
                _PKG: parentPackage
                _URL: url.href
            },
            {
                __index: env
                __newindex: env
            }
        )
    )

resolvePackagePath = ( currentPath, specifier ) ->
    local filePath
    if currentPath == ""
        filePath = path.Resolve( "packages", specifier )
    else
        filePath = path.Resolve( currentPath, "packages", specifier )

    if file.Exists( filePath, "LUA" )
        return filePath

    if currentPath ~= ""
        return resolvePackagePath( sub( string.GetPathFromFilename( currentPath ), 1, -2 ), specifier )

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
loader.PackageResolve = async ( specifier, parentURL, parentPackage ) ->
    local packageName
    if specifier == ""
        error InvalidModuleSpecifierError specifier

    if string.StartsWith( specifier, "@" )
        unless match( specifier, "/" ) -- check if specifier even has /
            error InvalidModuleSpecifierError specifier

        packageName = match( specifier, "(@[^/]*/[^/]*)" )
    else
        packageName = match( specifier, "([^/]*)" )

    if sub( packageName, 1, 1 ) == "." or match( packageName, "[\\%%]" )
        error InvalidModuleSpecifierError specifier

    packageSubPath = "." .. sub( specifier, len( packageName ) + 1 )
    if sub( packageSubPath, -1 ) == "/"
        error InvalidModuleSpecifierError specifier

    -- TODO make PACKAGE_SELF_RESOLVE
    -- if specifier := packageSelfResolve packageName, packageSubPath, parentURL
    --     return specifier

    parentPath = URL.parse( parentURL )\getPath!
    if parentPath == ""
        parentPath = "./"

    packagePath = resolvePackagePath( parentPath, specifier )
    if packagePath
        pkg = await gpm.ParsePackage( path.Join( packagePath, "package.lua" ) ) -- TODO: lookup package in global table

        -- TODO: If pmeta is not null and pmeta.exports is not null or undefined, then
        -- Return the result of PACKAGE_EXPORTS_RESOLVE(packagePath, packageSubpath, pjson.exports, defaultConditions).
        urlStr = "lua:" .. path.Join( pkg.dir, pkg.entry )

        if packageSubPath ~= "." or pkg.entry
            if parentPackage
                return loader.LoadURL( urlStr, parentPackage )

            return pkg\LoadURL( urlStr )

    error ModuleNotFoundError specifier
    return

-- Simplest vanilla lua `require` implementation
-- Not uses package or any other fancy stuff
-- package.path is hardcoded into it :p
do

    templates = {
        ".lua"
        "/init.lua"
    }

    length = #templates

    if CLIENT
        length += 1
        templates[ length ] = "/cl_init.lua"

    length += 1
    templates[ length ] = "/shared.lua"

    loader.RequireResolve = async ( specifier, parentURL, parentPackage ) ->
        specifier = gsub( specifier, "%.", "/" )
        url = URL.parse( parentURL )

        for index = 1, length
            success, entry = saveAwait loader.LoadURL( url\resolve( specifier .. templates[ index ] ), parentPackage )
            if success and entry
                return entry

-- Simple URL resolver based on https://nodejs.org/api/esm.html#resolution-algorithm-specification
-- without packageResolve since it is more advanced and not needed for now
loader.ResolveURL = ( specifier, parentURL ) ->
    url = URL.parse( specifier )
    if url.scheme
        return url\format!

    -- parent-url: lua:/example/foo.lua
    -- url: ../config.lua
    -- result: lua:/config.lua
    if find( url.pathname, "%.?%.?/", 1, false )
        -- If specifier is relative path then resolve it against parentURL
        return URL.resolve( parentURL, url.pathname )\format!

-- Resolves specifier and returns a promise with entry function
loader.Resolve = async ( specifier, parentURL = "lua:", parentPackage ) ->
    -- First lets try to resolve as URL
    resolved = loader.ResolveURL( specifier, parentURL )
    if resolved
        return loader.LoadURL( resolved, parentPackage )

    -- Try to resolve as vanilla `require`
    entry = await loader.RequireResolve( specifier, parentURL, parentPackage )
    if entry
        return entry

    -- Try to resolve as package
    return loader.PackageResolve( specifier, parentURL, parentPackage )

-- loader.AsyncImport = async ( specifier, parentURL, parentPackage ) ->
--     entry_fn = await loader.Resolve( specifier, parentURL, parentPackage )
--     entry_fn = async entry_fn -- convert entry to async function
--     return entry_fn!

--]]

getParentURL = ->
    if entry := getfmain!
        -- Get URL from entry env
        env = getfenv( entry )
        if value := env and rawget( env, "_URL" )
            return value

        -- Try to resolve URL from entry source
        if folderPath := getfpathi( entry )
            url = URL.parse( folderPath )
            url.protocol or= "lua"
            return url\format!

    return "lua:" -- default fallback

loader.GetParentURL = getParentURL

getPackage = ->
    if func := getfmain!
        env = getfenv( func )
        return env and rawget( env, "_PKG" )

loader.GetPackage = getPackage

gpm.Import = ( url, should_await ) ->
    result = loader.AsyncImport( url, getParentURL!, getPackage! )
    if should_await ~= false
        return await( result )

    return result

environment.require = gpm.Import
