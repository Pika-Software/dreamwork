gpm = gpm
:Promise, :Error, :path, :string = gpm
:async, :await = Promise

gpm.loader or= {}

class ModuleURLResolutionError extends Error
gpm.ModuleURLResolutionError = ModuleURLResolutionError

class InvalidModuleSpecifierError extends Error
gpm.InvalidModuleSpecifierError = InvalidModuleSpecifierError

class ModuleLoadError extends Error
gpm.ModuleLoadError = ModuleLoadError

class ModuleNotFoundError extends Error
gpm.ModuleNotFoundError = ModuleNotFoundError

-- https://nodejs.org/api/esm.html#resolution-algorithm-specification
-- Yeah, this loader tries to mimic ESM loader procedure

packageSelfResolve = (package_name, package_subpath, parent_url) -> nil

packageResolve = (specifier, parent_url) ->
    package_name = nil
    if url == ""
        error InvalidModuleSpecifierError specifier

    unless string.StartsWith specifier, "@"
        package_name = string.match specifier, "([^/]*)"
    else
        unless string.match specifier, "/" -- check if specifier even has /
            error InvalidModuleSpecifierError specifier
        package_name = string.match specifier, "(@[^/]*/[^/]*)"

    if string.StartsWith(package_name, ".") or string.match(package_name, "[\\%%]")
        error InvalidModuleSpecifierError specifier

    package_subpath = "." .. string.sub(specifier, #package_name + 1)
    if string.EndsWith package_subpath, "/"
        error InvalidModuleSpecifierError specifier

    if self_url = packageSelfResolve package_name, package_subpath, parent_url
        return self_url

    parent_path = parent_url.path
    while parent_path and parent_path != ""
        parent_path = string.sub string.GetPathFromFilename(parent_path), 1, -2
        package_url = path.Resolve path.Join parent_path, "packages", specifier
        if not file.Exists package_url, "LUA"
            continue
        
        pmeta = gpm.ParsePackageMeta path.Join package_url, "package.lua"
        -- TODO If pmeta is not null and pmeta.exports is not null or undefined, then
        -- Return the result of PACKAGE_EXPORTS_RESOLVE(packageURL, packageSubpath, pjson.exports, defaultConditions).
        if package_subpath == "."
            entry = pmeta and gpm.Package.GetEntry pmeta
            if entry
                return "lua:/" .. path.Join( package_url, entry )
        else
            return "lua:/" .. path.Resolve( path.Join( package_url, package_subpath ) ) 

    error ModuleNotFoundError specifier

resolveURL = (specifier, parent_url) ->
    resolved = nil
    format = nil
    url = gpm.url.parse specifier
    parent_url = gpm.url.parse parent_url

    -- https://nodejs.org/api/esm.html#resolution-algorithm-specification
    -- should first check if url is a valid url
    if url.scheme
        resolved = url\build!
    -- check if url is a relative path
    else if string.StartsWith(url.path, "./") or string.StartsWith(url.path, "../") or string.StartsWith(url.path, "/")
        resolved = parent_url\resolve(url.path)\build!
    -- it is a bare specifier, run package resolve
    else
        resolved = packageResolve specifier, parent_url

    return resolved, format

setupEnv = (func) ->
    setfenv func, gpm.Package.CreateEnvironment!

-- Checks if given lua file exists
checkFileExists = (path) ->
    if moonloader
        path = string.gsub path, "%.lua$", ".*"
        return file.Find("lua/" .. path, "GAME")[1] != nil
    else
        return file.Exists "lua/" .. path, "GAME"

CompileFile = (path) ->
    if string.StartsWith path, "/"
        path = string.sub path, 2
    if checkFileExists path
        return _G.CompileFile path
    
--[[

    tasks = {}
    for package in packages
        tasks[] = asyncImport package, parent_url

    for task in tasks
        task\Catch (err) ->
            print err

    PKG.name
    PKG.metadata.name
    PKG.env == getfenv(1)
    PARENT_URL

    PKG == gpm.Package!

    PKG.Tasks = {
        metadata: Promise 1
        download: Primise 2
    }

    Packages = { }

    -- package://PackageA/module1 -> lua://packages/PackageA/module1/package.lua
    -- lua://niknaks/package.lua

    lua://my_package/init.lua   - single file package
    lua://my_package            - multi file package ( package.lua and other files )

    NewPackage = ( url ) ->
        -- example1: url = "package://PackageA"
        -- example1: url = "lua://my_package"
        url = resolveURL( url )

        -- example1: url = "lua://packages/PackageA"
        -- example2: url = "lua://my_package"

        package = Packages[ url ]
        unless package
            package = gpm.Package( url )
            Packages[ url ] = package

        return package

    Package A:
        Code:
            ents.MyFunc = ->
                print( "FUnc!" )

            print COLLISION_GROUP_CUSTOM

        Depends:
            Package B:
                Globals:
                    markers = {}

    Package C:
        Code:
            print COLLISION_GROUP_CUSTOM
            ents.MyFunc!

        Depends:
            Package D:
                Globals:
                    markers = {}

            Package B:

    Output:
            FUnc!
            1
            2

]]

-- Simple module loader that takes url and tries to get module entry
gpm.loader.LoadURL = async (url, parent_package) ->
    if parent_package
        return parent_package\LoadURL url

    url = gpm.url.parse url
    if url.scheme == "lua"
        entry_fn = CompileFile url.path
        unless entry_fn
            error ModuleLoadError "failed to compile file #{url.path}"
        return entry_fn
    elseif url.scheme == "http" or url.scheme == "https"
        ext = string.GetExtensionFromFilename url.path
        if ext ~= "lua"
            error ModuleLoadError "unsupported web url: #{url}"

        req = await gpm.http.Fetch tostring url
        unless req and req.code == 200 and req.body
            error ModuleLoadError "failed to fetch #{url}"

        entry_fn = CompileString req.body, url\build!
        unless entry_fn
            error ModuleLoadError "failed to compile file #{url.path}"
        return entry_fn

-- Simple URL resolver based on https://nodejs.org/api/esm.html#resolution-algorithm-specification
-- without packageResolve since it is more advanced and not needed for now
gpm.loader.ResolveURL = (specifier, parent_url = "lua:/") ->
    url = gpm.url.parse specifier
    if url.scheme
        -- If specifier is url then just return it
        return url\build!
    else if string.StartsWith(url.path, "./") or string.StartsWith(url.path, "../") or string.StartsWith(url.path, "/")
        -- If specifier is relative path then resolve it against parent_url
        return gpm.url.parse(parent_url)\resolve(url.path)\build!

-- Simplest vanilla lua `require` implementation
-- Not uses package or any other fancy stuff
-- package.path is hardcoded into it :p
gpm.loader.RequireResolve = async (specifier, parent_url = "lua:/", parent_package) ->
    parent_url = gpm.url.parse parent_url
    specifier = string.gsub specifier, "%.", "/"
    -- yup, it is hard coded for now
    for template in string.gmatch "?.lua;?/init.lua", "[^;]+"
        resolved = parent_url\resolve string.gsub template, "?", specifier
        
        -- TODO If package is given, then try to resolve it through package
        if success, entry = try await gpm.loader.LoadURL resolved, parent_package
            if entry
                return entry

-- Resolves specifier and returns a promise with entry function
gpm.loader.Resolve = async (specifier, parent_url, parent_package) ->
    -- First lets try to resolve as URL
    if resolved = gpm.loader.ResolveURL specifier, parent_url
        return gpm.loader.LoadURL resolved, parent_package

    -- Try to resolve as vanilla `require`
    if entry = await gpm.loader.RequireResolve specifier, parent_url, parent_package
        return entry

    -- Try to resolve as package
    -- TODO make PackageResolve
    error ModuleNotFoundError specifier


gpm.loader.AsyncImport = async (specifier, parent_url) ->
    resolved, format = resolveURL specifier, parent_url
    url = gpm.url.parse resolved
    gpm.Logger\Debug "resolved url: #{url}"
    if url.scheme == "lua"
        entry_fn = CompileFile url.path
        unless entry_fn
            error ModuleLoadError "failed to compile file #{url.path}"

        entry_fn = async setupEnv entry_fn
        return entry_fn!
    elseif url.scheme == "http" or url.scheme == "https"
        ext = string.GetExtensionFromFilename url.path
        if ext ~= "lua"
            error ModuleLoadError "unsupported https url: #{url}"

        req = await gpm.http.Fetch tostring url
        unless req and req.code == 200 and req.body
            error ModuleLoadError "failed to fetch #{url}"

        entry_fn = CompileString req.body
        unless entry_fn
            error ModuleLoadError "failed to compile file #{url.path}"

        entry_fn = async setupEnv entry_fn
        return entry_fn!
    else
        error ModuleURLResolutionError "cannot resolve url: #{url}"

getParentURL = ->
    -- get url from something like gpm.meta.url or PARENT_URL
    if current_dir = gpm.debug.getfpath!
        current_dir = gpm.url.parse current_dir
        current_dir.scheme or= "lua"
        return current_dir\build!

    return "lua:/" -- default fallback

gpm.Import = (url, should_await = true) ->
    parent_url = getParentURL!
    result = gpm.loader.AsyncImport url, parent_url

    if should_await
        return result\await!

    return result
