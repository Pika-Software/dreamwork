_G = _G
import gpm, getmetatable, setmetatable from _G
import environment from gpm

import debug, isurl, isstring, ArgAssert, URL, NotImplementedError from environment
import async, await, reject from environment.Promise
import getfpathi from debug

:loader = gpm
unless istable( loader )
    loader = gpm.loader = {}

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
import CompileLuaString, CompileMoonString, CompileYueString, Version, Logger, JSONToTable from environment.util
import AsyncRead, IsFile, IsDir, NormalizeGamePath from environment.file
import sub, byte, find, match, gsub, format, StartsWith, IsURL from environment.string
import ModuleError, PackageError from environment
import getDirectory, join, stripExtension from environment.path

local Package
do

    class Module
        __tostring: =>
            return format( "Module: %p [%s]", @, @name )

        new: ( @location, @url, @env = _G ) =>
            unless isurl( url )
                error InvalidModuleConfigurationError "url is " .. type( url ) .. ", expected URL"

            :pathname = url
            @name = getfpathi( location ) or "unknown"
            setfenv( location, setmetatable({ __module: @, __filename: pathname, __dirname: getDirectory( pathname ) }, { __index: env, __newindex: env }) )
            return

        run: ( ... ) =>
            if result := @result
                return result

            result = @result = async( @location )( ... )
            return result

    loader.Module = Module

    environment.ismodule = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Module

    packages = gpm.Packages
    unless istable( packages )
        packages = gpm.Packages = setmetatable( {}, { __newindex: debug.fempty, __index: ( key ) =>
            tbl = {}
            rawset( @, key, tbl )
            return tbl
        } )

    base = {
        __tostring: => -- 2
            return format( "Package: %p [%s@%s]", @, @name, @version )
    }

    base.__index = base

    Package = loader.Package = setmetatable(
        {
            __name: "Package"
            __base: base

            __init: ( filePath, info ) =>
                unless istable( info )
                    return {
                        path: filePath,
                        exists: false
                    }

                name = info.name
                unless isstring( name )
                    name = match( filePath, "packages/(.+)/package%..+$" )

                @name = name

                version = info.version
                unless isstring( version )
                    version = "0.1.0"

                version = @version = Version( version )

                pkg = packages[ name ][ version ]
                if pkg
                    return pkg

                packages[ name ][ version ] = @

                @exports = info.exports
                @imports = info.imports
                @path = filePath
                @exists = true

                local logger

                params = info.logger
                if params
                    logger = Logger( name .. "@" .. version\__tostring!, params.color, params.interpolation )
                else
                    logger = Logger( name .. "@" .. version\__tostring! )

                @logger = logger

                @env = setmetatable({ __package: @, Logger: logger }, { __index: environment, __newindex: _G })

                :description = info
                if description and isstring( description )
                    @description = description

                :license = info
                if license and isstring( license )
                    @license = license

                :homepage = info
                if homepage and isstring( homepage )
                    @homepage = homepage

        },
        {
            __index: base
            __call: ( cls, ... ) ->
                obj = setmetatable( {}, base )
                return cls.__init( obj, ... ) or obj
        }
    )

    base.__class = Package

    environment.ispackage = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Package

-- TODO: after this works as specs intended, optimize it and make better!
class ESM
    DEFAULT_CONDITIONS = {
        [SERVER and "server" or CLIENT and "client" or MENU_DLL and "menu" or "default"]: true,
    }

    -- Just a shortcut so `ESM.resolve ...` can be used instead of creating a new instance.
    @resolve: ( ... ) -> ESM!\resolve( ... )

    -- ESM_RESOLVE(specifier, parentURL)
    resolve: async ( specifier, parentURL ) =>
        @specifier = specifier
        @parentURL = parentURL

        local resolved

        -- resolve
        if isurl( specifier ) or URL.canParse( specifier )
            resolved = URL( specifier )
        elseif StartsWith( specifier, "/" ) or StartsWith( specifier, "./" ) or StartsWith( specifier, "../" )
            resolved = URL( specifier, parentURL )
        elseif StartsWith( specifier, "#" )
            resolved = packageImportsResolve( @, specifier, parentURL )
        else
            -- specifier is now a bare specifier
            resolved = packageResolve( @, specifier, parentURL )

        return { :resolved, package: @pjson }

    -- PACKAGE_RESOLVE(packageSpecifier, parentURL)
    packageResolve = ( packageSpecifier, parentURL ) =>
        local packageName
        if packageSpecifier == ""
            error PackageError "specifier is an empty string"

        -- If packageSpecifier is a Node.js builtin module name, then
        -- 1. Return the string "node:" concatenated with packageSpecifier.

        if not StartsWith( packageSpecifier, "@" )
            packageName = match( packageSpecifier, "(.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the first "/" separator or the end of the string.
        else
            packageName = match( packageSpecifier, "(.-/.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the second "/" separator or the end of the string.
            if not packageName -- If packageSpecifier does not contain a "/" separator, then
                error PackageError "invalid specifier '#{packageSpecifier}'"

        if StartsWith( packageSpecifier, "." ) or find( packageSpecifier, "%", 1, true ) or find( packageSpecifier, "\\", 1, true )
            error PackageError "invalid specifier '#{packageSpecifier}'"

        packageSubpath = "." .. sub( packageSpecifier, #packageName + 1 )

        if selfURL := packageSelfResolve( @, packageName, packageSubpath, parentURL )
            return selfURL

        local packageURL
        while not packageURL or packageURL.path[1] ~= "packages" -- While parentURL is not the file system root
            packageURL = URL( "packages/" .. packageName .. "/", parentURL ) -- Let packageURL be the URL resolution of "node_modules/" concatenated with packageSpecifier, relative to parentURL.
            parentURL = URL( "..", parentURL ) -- Set parentURL to the parent folder URL of parentURL.

            if packageURL.scheme == "file" and not IsDir( packageURL.pathname ) -- If the folder at packageURL does not exist, then
                continue

            pjson = @pjson = readPackageJSON( @, packageURL )
            if pjson and pjson.exports
                return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

            return URL( packageSubpath, packageURL )

        error PackageError "package not found: '#{packageSpecifier}' from '#{@parentURL}'"
        return

    -- PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL)
    packageSelfResolve = ( packageName, packageSubpath, parentURL ) =>
        packageURL = lookupPackageScope( @, parentURL )
        if not packageURL
            return

        pjson = @pjson = readPackageJSON( @, packageURL )
        if not pjson or not pjson.exports
            return

        if pjson.name == packageName
            return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

    exportsStartsWithDot = ( exports, packageURL ) =>
        if istable( exports )
            local state
            for k, _ in pairs exports
                statsWithDot = StartsWith( k, "." )
                if state == nil
                    state = statsWithDot
                elseif state ~= statsWithDot
                    error PackageError "'#{packageURL}' exports are invalid"
            return state
        -- otherwise exports must be a string
        return StartsWith( exports, "." )

    -- PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)
    packageExportsResolve = ( packageURL, subpath, exports ) =>
        startsWithDot = exportsStartsWithDot( @, exports, packageURL )

        if subpath == "."
            local mainExport
            if isstring( exports ) or not startsWithDot
                mainExport = exports
            elseif istable( exports ) and startsWithDot
                mainExport = exports["."]

            if mainExport
                if resolved := packageTargetResolve( @, packageURL, mainExport, nil, false )
                    return resolved
        elseif istable( exports ) and startsWithDot
            if resolved := packageImportsExportsResolve( @, subpath, exports, packageURL, false )
                return resolved

        error PackageError "no exports found for '#{subpath}' in '#{packageURL}'"
        return

    -- PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)
    packageImportsResolve = ( specifier, parentURL ) =>
        if specifier == "#" or StartsWith( specifier, "#/" )
            error PackageError "invalid import specifier '" .. specifier .. "'"

        packageURL = lookupPackageScope( @, parentURL )
        if packageURL
            pjson = @pjson = readPackageJSON( @, packageURL )
            if pjson and pjson.imports
                if resolved := packageImportsExportsResolve( @, specifier, pjson.imports, packageURL, true )
                    return resolved

        error PackageError "imports are not defined for '" .. specifier .. "' in #{packageURL or parentURL}"
        return

    -- PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports)
    packageImportsExportsResolve = ( matchKey, matchObj, packageURL, isImports ) =>
        if matchObj[matchKey] and not find( matchKey, "*", 1, true )
            target = matchObj[matchKey]
            return packageTargetResolve( @, packageURL, target, nil, isImports )

        -- TODO: Implement pattern matching
        error PackageError "pattern matching is not implemented"
        return

    -- PACKAGE_TARGET_RESOLVE(packageURL, target, patternMatch, isImports, conditions)
    packageTargetResolve = ( packageURL, target, patternMatch, isImports ) =>
        if isstring( target )
            if not StartsWith( target, "./" )
                if isImports == false or StartsWith( target, "/" ) or StartsWith( target, "../" ) or URL.canParse( target )
                    error PackageError "invalid target '#{target}' for '#{packageURL}'"

                if isstring( patternMatch )
                    return packageResolve( @, gsub( target, "*", patternMatch ), packageURL )

                return packageResolve( @, target, packageURL )

            -- TODO: If target split on "/" or "\" contains any "", ".", "..", or "node_modules" segments after the first "." segment, case insensitive and including percent encoded variants, throw an Invalid Package Target error.

            resolvedTarget = URL( target, packageURL )
            if patternMatch == nil
                return resolvedTarget

            -- TODO: If patternMatch split on "/" or "\" contains any "", ".", "..", or "node_modules" segments, case insensitive and including percent encoded variants, throw an Invalid Module Specifier error.
            resolvedTarget.pathname = gsub( resolvedTarget.pathname, "*", patternMatch )
            return resolvedTarget
        elseif istable( target )
            if #target == 0 -- object
                local defaultValue
                for p, targetValue in pairs target
                    if DEFAULT_CONDITIONS[p]
                        if resolved := packageTargetResolve( @, packageURL, targetValue, patternMatch, isImports )
                            return resolved
                    elseif p == "default"
                        defaultValue = targetValue

                -- resolving "default" at the end because tables in lua are unordered
                if defaultValue
                    return packageTargetResolve( @, packageURL, defaultValue, patternMatch, isImports )

                return nil

            -- array
            local success, resolved
            for targetValue in *target
                success, resolved = pcall( packageTargetResolve, @, packageURL, targetValue, patternMatch, isImports )
                if success and resolved
                    return resolved

            unless success
                error resolved
                return

            return nil
        elseif target == nil
            return nil

        error PackageError "invalid target '#{target}' for '#{packageURL}'"
        return

    -- LOOKUP_PACKAGE_SCOPE(url)
    lookupPackageScope = ( url ) =>
        if url.scheme ~= "file"
            error PackageError "unable to lookup package scope for '#{url}' (not a file:/// URL)"

        local scopeURL = URL( "./package.lua", url )
        while scopeURL.path[1] ~= "package.lua" -- not filesystem root
            if scopeURL.path[ #scopeURL.path - 1 ] == "packages"
                return

            if IsFile( scopeURL.pathname )
                return URL( "./", scopeURL )

            scopeURL = URL( "../package.lua", scopeURL )

    -- READ_PACKAGE_JSON(packageURL)
    readPackageJSON = ( packageURL ) =>
        pjsonPath = join( packageURL.pathname, "package.lua" )
        unless IsFile( pjsonPath )
            return

        filePath, gamePath = NormalizeGamePath( pjsonPath )

        withoutExtension, extension = stripExtension( filePath )
        if IsFile( withoutExtension .. ".yue", gamePath, true )
            extension = "yue"
        elseif IsFile( withoutExtension .. ".moon", gamePath, true )
            extension = "moon"

        filePath = withoutExtension .. "." .. extension
        content = await AsyncRead( filePath, gamePath, true )

        if extension == "lua"
            firstByte = byte( content, 1 )
            if firstByte == 0x5b --[['[']] or firstByte == 0x7b --[['{']]
                info = JSONToTable( content )
                if info
                    return Package( filePath, info )

        func = switch extension
            when "yue"
                CompileYueString( content, filePath, true )
            when "moon"
                CompileMoonString( content, filePath, true )
            else
                CompileLuaString( content, filePath, true, false )

        if func
            info = {}
            setfenv( func, info )
            success, result = pcall( func )
            if success
                if istable( result )
                    table.Merge( info, result )

                return Package( filePath, info )

            error PackageError "File '" .. filePath .. "' compilation error: " .. result
            return

        error PackageError "File '" .. filePath .. "' cannot be compiled."
        return

class Require
    PACKAGE_PATHS = { "./?.lua", "./?/init.lua" }

    -- Just a shortcut so `Require.resolve ...` can be used instead of creating a new instance.
    @resolve: ( ... ) -> Require!\resolve( ... )

    resolve: async ( modname, base ) =>
        unless base
            error ModuleError "`require` cannot be used outside of modules"

        if base.scheme ~= "file"
            error NotImplementedError "cannot use `require` from `#{base}`"

        isOpaque = isRequireSyntax( modname )
        filePath = gsub( modname, "%.", "/" )

        if resolved := isOpaque and resolveFile( @, filePath, base )
            return { :resolved }

        success, resolved = try await ESM.resolve( isOpaque and filePath or modname, base )
        if success
            return resolved

        if util.IsBinaryModuleInstalled( modname )
            return { resolved: URL( "dll:" .. modname ) }

        -- TODO: make better errors
        error resolved -- just return error from ESM
        return

    isRequireSyntax = ( modname ) -> match( modname, "^[%a%d_%-.]+$" )

    resolveFile = ( filePath, base ) =>
        for pattern in *PACKAGE_PATHS
            url = URL( gsub( pattern, "%?", filePath ), base )
            if IsFile( url.pathname )
                return url

class Include
    -- Just a shortcut so `Include.resolve ...` can be used instead of creating a new instance.
    @resolve: ( ... ) -> Include!\resolve( ... )

    resolve: async ( fileName, base ) =>
        if base and base.scheme == "file"
            resolved = URL( fileName, base )
            if resolved.path[1] == "lua" and IsFile( resolved.pathname )
                return { :resolved }

        resolved = URL( fileName, "file:///lua/" )
        if resolved.path[1] == "lua" and IsFile( resolved.pathname )
            return { :resolved }

        return ESM.resolve( fileName, base )

do

    import SourceError from environment

    sources = loader.Sources
    unless istable( sources )
        sources = loader.Sources = {}

    findSource = loader.FindSource = ( scheme ) ->
        source = sources[ scheme ]
        if source
            return source

        error SourceError "Source for scheme '#{scheme}' not implemented."
        return

    registerSource = loader.RegisterSource = ( scheme, source ) ->
        sources[ scheme ] = source

    class loader.BaseSourceHandler
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source handler", @ )

        FetchInfo: async ( url, base, env, parent ) =>
            return nil

        Install: async ( url, info, base, env, parent ) =>
            error NotImplementedError "Source:Install( url, info, base, env, parent )"
            return

    class loader.BaseSource
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source", @ )

        new: ( ... ) =>
            @handlers = {}

            for scheme in *{ ... }
                registerSource( scheme, @ )

        RegisterHandler: ( handler ) =>
            @handlers[] = handler

        CallHandler: ( name, url, ... ) =>
            for handler in *@handlers
                if not handler.ShouldHandle or handler\ShouldHandle( url, ... )
                    return handler[ name ]( handler, url, ... )

            return reject SourceError "No handler found for URL '#{url}' (" .. name .. ")"

        FetchInfo: ( url, base, env, parent ) =>
            return @CallHandler( "FetchInfo", url, base, env, parent )

        Install: ( url, info, base, env, parent ) =>
            return @CallHandler( "Install", url, info, base, env, parent )

    parseFileURL = loader.ParseFileURL = ( any ) ->
        if isurl( any )
            return any

        if isstring( any ) and IsURL( any )
            return URL( any )

    getFileURL = loader.GetFileURL = ( any ) ->
        url = parseFileURL( any )
        unless url
            error SourceError "Invalid URL: #{any}"

        unless url.scheme
            error SourceError "Invalid protocol for URL: #{any}"

        return url

    loader.FetchInfo = async ( url, base, env, parent ) ->
        url = getFileURL( url )
        return findSource( url.scheme )\FetchInfo( url, base, env, parent )

    asyncImport = loader.AsyncImport = async ( specifier, resolver, info, base = URL( "file:///lua/" ), env, parent ) ->
        :resolved, :package = await resolver( specifier, base )

        if package -- if package was found, then it must overwrite current env
            env = package.env or env

        source = findSource( resolved.scheme )

        unless info
            info = await source\FetchInfo( resolved, base, env, parent )

        return source\Install( resolved, info, base, env, parent )

    local getImportMeta
    do

        import getfmain from debug

        local getModule
        do

            import rawget, getfenv from _G

            getModule = loader.GetModule = ( func = getfmain! ) ->
                if fenv := func and getfenv( func )
                    return rawget( fenv, "__module" )

        getURL = loader.GetURL = ( func = getfmain! ) ->
            if fpath := func and getfpathi( func )
                if IsURL( fpath )
                    return URL( fpath )

                return URL( "file:///" .. fpath )

        loader.GetFolder = ( func = getfmain! ) -> -- not compatible with urls
            if fpath := func and getfpathi( func )
                return getDirectory( fpath )

        getParentURL = loader.GetParentURL = ( m = getModule! ) ->
            return m and m.url or nil

        getEnvironment = loader.GetEnvironment = ( m = getModule! ) ->
            return m and m.env or nil

        getPackage = loader.GetPackage = ( env = getEnvironment! ) ->
            return env and env.__package or nil

        getImportMeta = loader.GetImportMeta = ->
            local base, parent, env
            if fmain := getfmain!
                if m := getModule( fmain )
                    base = getParentURL( m )
                    env = getEnvironment( m )
                    parent = getPackage( env )

                base or= getURL( fmain )

            return base, env, parent

    do

        import_fn = gpm.Import = ( specifier, should_await ) ->
            ArgAssert( specifier, 1, "string", 2 )

            if should_await
                return await asyncImport( specifier, ESM.resolve, nil, getImportMeta! )

            return asyncImport( specifier, ESM.resolve, nil, getImportMeta! )

        -- just for a .lua users
        environment.import = ( specifier, should_await ) ->
            return import_fn( specifier, should_await or true )

    environment.require = ( modname ) ->
        ArgAssert( modname, 1, "string" )
        return await asyncImport( modname, Require.resolve, nil, getImportMeta! )

    environment.include = ( fileName ) ->
        ArgAssert( fileName, 1, "string" )
        return await asyncImport( fileName, Include.resolve, nil, getImportMeta! )

test = async ->
    gpm.Import "package_v2"
    -- package resovle

    -- :resolved, :format, :package = await ESM.resolve( "b/init.lua", URL( "file:/lua/packages/exports/" ) )
    -- source = loader.FindSource(resolved.scheme)
    -- func = await source\FetchInfo(resolved)
    -- print await source\Install(resolved, func)
    return

-- requre( "package:a" )

if SERVER
    test!\Catch( environment.Error.display )
