_G = _G
import CLIENT, SERVER, gpm, pcall from _G
import environment from gpm

import debug, string, path, file, util, pairs, isurl, isstring, argument, URL, ModuleError, error, PackageError, Promise from environment
import getDirectory, getExtension, replaceExtension from path
import NormalizeGamePath, AbsoluteGamePath, Find from file
import concat, IsEmpty, Merge from environment.table
import await, async from Promise
newClass = environment.class
import getfpath from debug
import Version from util

file.CreateDir( "/data/gpm/vfs", true )

_G.hook.Add "ShutDown", "GLua Package Manager::VFS", ->
    file.Delete( "/data/gpm/vfs" )
    return nil

local addcsluafile

if SERVER

    import getCurrentFile, getCurrentDirectory, getFile from path
    import LuaGamePaths, LuaExtensions from file
    import AddCSLuaFile from _G

    addFilePath = ( filePath, gamePath ) ->
        basePath = getDirectory( filePath, true )
        searchable = getFile( filePath )

        files, dirs = Find( filePath, gamePath, true )

        for index = 1, #files
            fileName = files[ index ]
            if LuaExtensions[ getExtension( fileName, false ) ]
                AddCSLuaFile( basePath .. replaceExtension( fileName, "lua" ) )
            else
                error "Attept to send non-lua file '" .. basePath .. fileName .. "'.", 2

        for directoryName in *dirs
            directoryPath = basePath .. directoryName
            if directoryPath == filePath
                addFilePath( directoryPath .. "/*", gamePath )
            else
                addFilePath( directoryPath .. "/" .. searchable, gamePath )

        return nil

    addcsluafile = ( filePath = "", gamePath, skipNormalize ) ->
        if filePath == "" or getFile( filePath ) == "."
            fenv = getfenv( 2 )
            if m := fenv and fenv.__module
                filePath = m.file
            else
                filePath = getCurrentFile!

        elseif filePath == "./"
            fenv = getfenv( 2 )
            if m := fenv and fenv.__module
                filePath = m.directory .. "/*"
            else
                filePath = getCurrentDirectory( nil, true ) .. "*"

        unless skipNormalize
            filePath, gamePath = NormalizeGamePath( filePath, gamePath )

        unless LuaGamePaths[ gamePath ]
            error "Sending lua files from '" .. gamePath .. "' game path is not allowed.", 2

        addFilePath( filePath, gamePath )
        return nil

else

    addcsluafile = environment.debug.fempty

environment.AddCSLuaFile = addcsluafile

:loader = gpm
unless istable( loader )
    loader = gpm.loader = {}

-- Modules and Packages are tables with format: [url] = Module/Package
packages = loader.Packages = {}
modules = loader.Modules = {}

sources = loader.Sources
unless istable( sources )
    sources = loader.Sources = {}

getSource = ( protocol ) ->
    if isstring( protocol ) and IsURL( protocol )
        protocol = URL( protocol ).scheme
    elseif isurl( protocol )
        protocol = protocol.scheme

    return sources[ protocol ]

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
import find, match, gsub, format, StartsWith, IsURL from string
import AsyncCompile, IsFile from file

local moduleClass, packageClass, packageRead
do

    import setmetatable from _G

    do

        import AsyncWrite, Time from file
        import stripExtension from path
        import PathFromURL from string
        -- startTime = environment.os.time! - ( gpm.StartTime or 0 )

        -- cache files have different paths for client and server
        getCachePath = ( url ) ->
            if CLIENT
                return "/lua/gpm/vfs/" .. stripExtension( PathFromURL( url ) ) .. ".lua"

            return "/data/gpm/vfs/" .. stripExtension( PathFromURL( url ) ) .. ".txt"

        moduleClass = newClass(
            "Module",
            {
                __tostring: =>
                    return format( "Module: %p [%s]", @, @name )

                new: ( @url, @env = _G ) =>
                    argument( url, 1, "URL" )

                    :pathname = url
                    unless pathname
                        return nil

                    @name = "unknown"
                    @file = pathname
                    @directory = getDirectory( pathname, false )
                    @env = setmetatable( { __module: @, __filename: @file, __dirname: @directory }, { __index: @env, __newindex: @env } )

                    modules[ url.href ] = @
                    return nil

                load: async =>
                    if @func
                        return @func

                    config = {}

                    if @url.scheme == "file"
                        filePath, gamePath = NormalizeGamePath( @url.pathname )
                        unless IsFile( filePath, gamePath, true )
                            error ModuleError "file '#{@url}' does not exist"

                        compileResult = await AsyncCompile( filePath, @env, config, gamePath, true )
                        @func = func = compileResult.func
                        @name = getfpath( func ) or "unknown"
                        return func

                    error ModuleError "unsupported scheme '" .. @url.scheme .. "' ('" .. @url.href .. "')"
                    return nil

                run: ( ... ) =>
                    if not @func
                        error ModuleError "module #{@url} was not loaded"

                    return async( @func )( ... )
            },
            {
                getAll: ->
                    return modules

                get: ( url ) ->
                    return modules[ url.href ]

                -- @getCachePath: getCachePath

                -- @cache: async ( url, content ) ->
                --     filePath = getCachePath( url )
                --     if CLIENT
                --         return filePath

                --     if IsFile( filePath ) and Time( filePath ) >= startTime
                --         return filePath

                --     return AsyncWrite( filePath, content )

                run: async ( url, env ) ->
                    argument( url, 1, "URL" )

                    m = modules[ url.href ]
                    unless m
                        m = moduleClass( url, env )
                        await m\load!

                    return m\run!
            }
        )

        loader.Module = moduleClass

    import STATE_REJECTED from Promise
    import rawset, tobool from _G
    import getFileName from path
    import Logger from util

    default = environment.Color( 50, 100, 200 )\DoCorrection!
    environmentMetatable = { __index: environment }

    hooksMeta = {
        __index: ( tbl, key ) ->
            new = {}
            rawset( tbl, key, new )
            return new
    }

    -- TODO: maybe allow urls and strings instead of just local file asyncompile?
    parse = async ( filePath, gamePath, config ) ->
        compileResult = await AsyncCompile( filePath, {}, config, gamePath, true )
        -- await Module.cache( "file://" .. compileResult.path, compileResult.content )
        :func = compileResult

        info = {}
        setfenv( func, info )
        success, result = pcall( func )
        if success
            if istable( result )
                Merge( info, result )

            if IsEmpty( info )
                error PackageError "file '#{filePath}' does not contain valid package info (empty or cannot be parsed)"
                return nil

            if gamePath == file.LuaPath
                addcsluafile( replaceExtension( filePath, "lua" ), gamePath, true )

            return packageClass( URL( AbsoluteGamePath( filePath, gamePath ), "file:///" ), info )

        error PackageError "package info '" .. filePath .. "' execution error: " .. result
        return nil

    emptyTable = {}

    packageRead = async ( url ) ->
        if isstring( url )
            url = URL( url )

        unless isurl( url )
            error PackageError "invalid url '" .. url.href .. "'"

        if url.scheme ~= "file"
            -- error PackageError "unsupported scheme '" .. url.scheme .. "' ('" .. url.href .. "')"
            return nil

        unless istable( url.path )
            -- error PackageError "invalid path '" .. url.pathname .. "' ('" .. url.href .. "')"
            return nil

        cached = packages[ url.href ]
        if cached
            if cached.state ~= STATE_REJECTED
                return cached

            -- clear cache if parsing failed
            packages[ url.href ] = nil

        filePath, gamePath = NormalizeGamePath( url.pathname )
        fileDir = getDirectory( filePath, true )

        -- if not package.* file was given in url, try to find it smartly
        if getFileName( filePath, false ) ~= "package"
            files = Find( fileDir .. "/package.*", gamePath, true )
            if #files == 1
                filePath = fileDir .. files[ 1 ]

            elseif #files > 1
                -- Smartly decide which file to use
                values = {} -- [ext] = filePath
                for fileName in *files
                    values[ getExtension( fileName, false ) ] = fileName

                filePath = fileDir .. values.yue or values.moon or values.lua or values[ 1 ]

        unless IsFile( filePath, gamePath, true )
            -- error PackageError "file '" .. filePath .. "' does not exist for packageURL '" .. url.href .. "'"
            return nil

        config = {}
        for key, value in url.searchParams\iterator!
            config[ key ] = value

        -- also cache result so next calls will return current package
        promise = parse( filePath, gamePath, config )
        packages[ url.href ] = promise
        return promise

    packageClass = newClass( "Package", {
        __tostring: =>
            return format( "Package: %p [%s@%s]", @, @name, @version )

        new: ( @url, info ) =>
            filePath = @file = url.pathname
            @directory = getDirectory( filePath, false )

            unless info
                info = emptyTable

            -- name
            :name = info
            unless isstring( name ) and match( name, "^[a-zA-Z_][%w ~<>_&+%-]*" )
                name = match( filePath, ".*packages/([^/]+)" ) or getFileName( filePath, false )

                if name == ""
                    error PackageError "invalid package name: '" .. name .. "'"

            @name = name

            -- version
            :version = info
            unless isstring( version )
                version = "0.1.0"

            version = Version( version )
            @version = version

            -- autorun
            @autorun = tobool( info.autorun )

            -- send
            if SERVER
                :send = info
                unless istable( send )
                    send = {}

                @send = send

            -- exports
            :exports = info
            unless isstring( exports ) or istable( exports )
                exports = nil

            @exports = exports

            -- imports
            :imports = info
            unless isstring( imports ) or istable( imports )
                imports = nil

            @imports = imports

            -- dependencies
            :dependencies = info
            unless istable( dependencies )
                dependencies = nil

            @dependencies = dependencies

            -- description
            :description = info
            unless isstring( description )
                description = "Description not provided"

            @description = description

            -- license
            :license = info
            unless isstring( license )
                license = "License not provided"

            @license = license

            -- homepage
            :homepage = info
            unless isstring( homepage )
                homepage = "Homepage not provided"

            @homepage = homepage

            -- logger
            :logger = info
            unless istable( logger )
                logger = {
                    interpolation: true
                    disabled: false
                    color: default
                }

            @logger = logger

            local packageLogger
            if logger
                if logger.disabled
                    packageLogger = nil
                else
                    packageLogger = Logger( name .. "@" .. version\__tostring!, logger.color, logger.interpolation )
            else
                packageLogger = Logger( name .. "@" .. version\__tostring! )

            @__hooks = setmetatable( {}, hooksMeta )
            @__prefix = @__tostring! .. "::"
            @__timers = {}
            @__dependencies = {}

            -- package environment
            @env = setmetatable( { __package: @, Logger: packageLogger }, environmentMetatable )
    },
    {
        -- directly reads package info from given filePath and creates Package
        -- do not use this method directly, use Package.read instead
        parse: parse

        -- Finds a package info in given url.
        -- If package.* file was not given in path, tries to find it.
        -- Also caches the package by URL.
        read: packageRead
    } )

    environment.Package = packageClass

-- TODO: after this works as specs intended, optimize it and make better!
local esmClass, esmResolve
do

    import canParse from URL
    import IsDir from file
    import sub from string

    DEFAULT_CONDITIONS = {
        [ SERVER and "server" or CLIENT and "client" or _G.MENU_DLL and "menu" or "default" ]: true,
    }

    local packageResolve

    -- PACKAGE_TARGET_RESOLVE(packageURL, target, patternMatch, isImports, conditions)
    packageTargetResolve = ( packageURL, target, patternMatch, isImports ) =>
        if isstring( target )
            unless StartsWith( target, "./" )
                if isImports == false or StartsWith( target, "/" ) or StartsWith( target, "../" ) or canParse( target )
                    error PackageError "invalid target '#{target}' for '#{packageURL}'"
                    return nil

                if isstring( patternMatch )
                    return packageResolve( @, gsub( target, "*", patternMatch ), packageURL )

                return packageResolve( @, target, packageURL )

            -- TODO: If target split on "/" or "\" contains any "", ".", "..", or "node_modules" segments after the first "." segment, case insensitive and including percent encoded variants, throw an Invalid Package Target error.

            resolvedTarget = URL( target, packageURL )
            if patternMatch == nil
                return resolvedTarget

            -- TODO: If patternMatch split on "/" or "\" contains any "", ".", "..", or "node_modules" segments, case insensitive and including percent encoded variants, throw an Invalid Module Specifier error.
            resolvedTarget.pathname = gsub( resolvedTarget.pathname, "*", patternMatch )
            return resolvedTarget

        if istable( target )
            if #target == 0 -- object
                local defaultValue
                for p, targetValue in pairs( target )
                    if DEFAULT_CONDITIONS[ p ]
                        if resolved := packageTargetResolve( @, packageURL, targetValue, patternMatch, isImports )
                            return resolved

                    elseif p == "default"
                        defaultValue = targetValue

                -- resolving "default" at the end because tables in lua are unordered
                if defaultValue
                    return packageTargetResolve( @, packageURL, defaultValue, patternMatch, isImports )

                return nil

            -- array
            local success, resolved
            for targetValue in *target
                success, resolved = pcall( packageTargetResolve, @, packageURL, targetValue, patternMatch, isImports )
                if success and resolved
                    return resolved

            unless success
                error resolved
                return nil

            return nil

        if target == nil
            return nil

        error PackageError "invalid target '#{target}' for '#{packageURL}'"
        return nil

    exportsStartsWithDot = ( exports, packageURL ) =>
        if istable( exports )
            local state
            for key in pairs( exports )
                statsWithDot = StartsWith( key, "." )
                if state == nil
                    state = statsWithDot
                elseif state ~= statsWithDot
                    error PackageError "'#{packageURL}' exports are invalid"

            return state

        -- otherwise exports must be a string
        return StartsWith( exports, "." )

    -- PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports)
    packageImportsExportsResolve = ( matchKey, matchObj, packageURL, isImports ) =>
        if matchObj[ matchKey ] and not find( matchKey, "*", 1, true )
            target = matchObj[ matchKey ]
            return packageTargetResolve( @, packageURL, target, nil, isImports )

        -- TODO: Implement pattern matching
        error PackageError "pattern matching is not implemented"
        return nil

    -- PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)
    packageExportsResolve = ( packageURL, subpath, exports ) =>
        startsWithDot = exportsStartsWithDot( @, exports, packageURL )

        if subpath == "."
            local mainExport
            if isstring( exports ) or not startsWithDot
                mainExport = exports
            elseif istable( exports ) and startsWithDot
                mainExport = exports["."]

            if mainExport
                if resolved := packageTargetResolve( @, packageURL, mainExport, nil, false )
                    return resolved

        elseif istable( exports ) and startsWithDot
            if resolved := packageImportsExportsResolve( @, subpath, exports, packageURL, false )
                return resolved

        error PackageError "no exports found for '#{subpath}' in '#{packageURL}'"
        return nil

    packageDependencyResolve = ( name, target, subpath ) =>
        unless target
            error PackageError "invalid dependency target '#{target}' for '#{name}'"

        packageURL = nil
        if IsURL( target ) -- source lookup
            source = getSource( target )
            unless source
                error PackageError "source for '#{target}' not found"

            packageURL = source\WorkingDirectory( target ) -- our package must be in the root directory, I hope
        else -- version lookup
            -- Retrieving all version of the package
            _, folders = Find( "gpm/vfs/packages/" .. name .. "/*", file.LuaPath, true ) -- lets hope that package installer will create correct versions of the package
            version = Version.select( target, folders )
            unless version
                versions_str = concat( folders, ", " )
                error PackageError "could not find installed #{name} with version selector #{target} (available versions: [#{versions_str}])"

            packageURL = URL( "file:///lua/gpm/vfs/packages/" .. name .. "/" .. tostring( version ) .. "/" )
            unless IsDir( packageURL.pathname )
                error PackageError "#{packagePath} should exists but it does not :? (#{name} with target #{target})"

        pjson = @pjson = await packageRead( packageURL )
        if pjson and pjson.exports
            return packageExportsResolve( @, packageURL, subpath, pjson.exports )

        return URL( subpath, packageURL )

    packageDependenciesResolve = ( packageName, packageSubpath ) =>
        -- @pjson must be set by packageSelfResolve
        pjson = @pjson
        if not pjson or not istable( pjson.dependencies )
            return nil

        target = pjson.dependencies[ packageName ]
        if isstring( target )
            return packageDependencyResolve( @, packageName, target, packageSubpath )

        return nil

    -- LOOKUP_PACKAGE_SCOPE(url)
    lookupPackageScope = ( url ) =>
        if url.scheme ~= "file"
            error PackageError "unable to lookup package scope for '#{url}' (not a file:/// URL)"

        local scopeURL = URL( "./package.lua", url )
        while scopeURL.path[ 1 ] ~= "package.lua" -- not filesystem root
            if scopeURL.path[ #scopeURL.path - 1 ] == "packages"
                return nil

            if IsFile( scopeURL.pathname )
                return URL( "./", scopeURL )

            scopeURL = URL( "../package.lua", scopeURL )

        return nil

    -- PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL)
    packageSelfResolve = ( packageName, packageSubpath, parentURL ) =>
        packageURL = lookupPackageScope( @, parentURL )
        unless packageURL
            return nil

        pjson = @pjson = await packageRead( packageURL )
        unless pjson and pjson.exports
            return nil

        if pjson.name == packageName
            return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

        return nil

    -- PACKAGE_RESOLVE(packageSpecifier, parentURL)
    packageResolve = ( packageSpecifier, parentURL ) =>
        local packageName
        if packageSpecifier == ""
            error PackageError "specifier is an empty string"

        -- If packageSpecifier is a Node.js builtin module name, then
        -- 1. Return the string "node:" concatenated with packageSpecifier.

        if StartsWith( packageSpecifier, "@" )
            packageName = match( packageSpecifier, "(.-/.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the second "/" separator or the end of the string.
            unless packageName -- If packageSpecifier does not contain a "/" separator, then
                error PackageError "invalid specifier '#{packageSpecifier}'"
        else
            packageName = match( packageSpecifier, "(.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the first "/" separator or the end of the string.

        if StartsWith( packageSpecifier, "." ) or find( packageSpecifier, "%", 1, true ) or find( packageSpecifier, "\\", 1, true )
            error PackageError "invalid specifier '#{packageSpecifier}'"

        packageSubpath = "." .. sub( packageSpecifier, #packageName + 1 )

        if selfURL := packageSelfResolve( @, packageName, packageSubpath, parentURL )
            return selfURL

        local packageURL
        while not packageURL or packageURL.path[ 1 ] ~= "packages" -- While parentURL is not the file system root
            firstTime = not packageURL

            packageURL = URL( "packages/" .. packageName .. "/", parentURL ) -- Let packageURL be the URL resolution of "node_modules/" concatenated with packageSpecifier, relative to parentURL.
            parentURL = URL( "..", parentURL ) -- Set parentURL to the parent folder URL of parentURL.

            if packageURL.scheme == "file" and not IsDir( packageURL.pathname ) -- If the folder at packageURL does not exist, then
                if result := firstTime and packageDependenciesResolve( @, packageName, packageSubpath )
                    return result

                continue

            pjson = @pjson = await packageRead( packageURL )
            if pjson and pjson.exports
                return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

            return URL( packageSubpath, packageURL )

        error PackageError "package not found: '#{packageSpecifier}' from '#{@parentURL}'"
        return nil

    -- PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)
    packageImportsResolve = ( specifier, parentURL ) =>
        if specifier == "#" or StartsWith( specifier, "#/" )
            error PackageError "invalid import specifier '" .. specifier .. "'"

        packageURL = lookupPackageScope( @, parentURL )
        if packageURL
            pjson = @pjson = await packageRead( packageURL )
            if pjson and pjson.imports
                if resolved := packageImportsExportsResolve( @, specifier, pjson.imports, packageURL, true )
                    return resolved

        error PackageError "imports are not defined for '" .. specifier .. "' in #{packageURL or parentURL}"
        return nil

    esmResolve = ( ... ) ->
        return esmClass!\resolve( ... )

    esmClass = newClass(
        "ESM",
        {
            -- ESM_RESOLVE(specifier, parentURL)
            resolve: async ( specifier, parentURL ) =>
                @specifier = specifier
                @parentURL = parentURL

                -- resolve
                local resolved
                if isurl( specifier ) or canParse( specifier )
                    resolved = URL( specifier )
                elseif StartsWith( specifier, "/" ) or StartsWith( specifier, "./" ) or StartsWith( specifier, "../" )
                    resolved = URL( specifier, parentURL )
                elseif StartsWith( specifier, "#" )
                    resolved = packageImportsResolve( @, specifier, parentURL )
                else
                    -- specifier is now a bare specifier
                    resolved = packageResolve( @, specifier, parentURL )

                return { :resolved, package: @pjson }
        },
        {
            -- Just a shortcut so `ESM.resolve ...` can be used instead of creating a new instance.
            resolve: esmResolve
        }
    )

    loader.ESM = esmClass

local requireClass
do

    import NotImplementedError from environment
    -- import IsBinaryModuleInstalled from util

    PACKAGE_PATHS = { "./?.lua", "./?/init.lua" }

    isRequireSyntax = ( modname ) ->
        return match( modname, "^[%a%d_%-.]+$" )

    resolveFile = ( filePath, base ) =>
        for pattern in *PACKAGE_PATHS
            url = URL( gsub( pattern, "%?", filePath ), base )
            if IsFile( url.pathname )
                return url

        return nil

    requireClass = newClass(
        "Require",
        {
            resolve: async ( modname, base ) =>
                unless base
                    error ModuleError "`require` cannot be used outside of modules"

                if base.scheme ~= "file"
                    error NotImplementedError "cannot use `require` from `#{base}`"

                isOpaque = isRequireSyntax( modname )
                filePath = gsub( modname, "%.", "/" )

                if resolved := isOpaque and resolveFile( @, filePath, base )
                    return { :resolved }

                if StartsWith( filePath, "gpm/" ) or StartsWith( filePath, "gmod/" )
                    protocol, filePath = match( filePath, "^(.-)/(.*)" )
                    filePath = URL( protocol .. ":///" .. filePath ).href

                if filePath == "gpm" or filePath == "gmod"
                    filePath ..= ":///"

                success, resolved = try await esmResolve( isOpaque and filePath or modname, base )
                if success
                    return resolved

                -- if IsBinaryModuleInstalled( modname )
                --     return { resolved: URL( "dll:" .. modname ) }

                -- TODO: make better errors
                error resolved -- just return error from ESM
                return nil
        },
        {
            -- Just a shortcut so `Require.resolve ...` can be used instead of creating a new instance.
            resolve: ( ... ) ->
                return requireClass!\resolve( ... )
        }
    )

    loader.Require = requireClass

local includeClass
includeClass = newClass(
    "Include",
    {
        resolve: async ( fileName, base ) =>
            if base and base.scheme == "file"
                resolved = URL( fileName, base )
                if resolved.path[ 1 ] == "lua" and IsFile( resolved.pathname )
                    return { :resolved }

            resolved = URL( fileName, "file:///lua/" )
            if resolved.path[ 1 ] == "lua" and IsFile( resolved.pathname )
                return { :resolved }

            return esmResolve( fileName, base )
    },
    {
        -- Just a shortcut so `Include.resolve ...` can be used instead of creating a new instance.
        resolve: ( ... ) ->
           return includeClass!\resolve( ... )
    }
)

loader.Include = includeClass

local asyncImport, findSource
do

    import SourceError from environment
    import Logger, ispromise from gpm
    import reject from Promise
    import join from path

    findSource = loader.FindSource = ( scheme ) ->
        source = sources[ scheme ]
        if source
            return source

        error SourceError "Source for scheme '#{scheme}' not implemented."
        return

    registerSource = loader.RegisterSource = ( scheme, source ) ->
        sources[ scheme ] = source

    loader.Source = newClass(
        "Source",
        {
            __tostring: =>
                return format( "%s %p", @@__name, @ )

            new: ( ... ) =>
                for protocol in *{ ... }
                    @register( protocol )

                unless @FetchInfo
                    Logger\Warn( "Source #{@} does not implement :FetchInfo method. May cause errors." )

                unless @Install
                    Logger\Warn( "Source #{@} does not implement :Install method. May cause errors." )

            register: ( protocol ) =>
                if isurl( protocol )
                    protocol = protocol.scheme

                old = sources[ protocol ]
                if old
                    Logger\Warn( "Protocol '#{protocol}' has been reregistered by '#{@}'. (was #{old})" )

                sources[ protocol ] = @
                Logger\Debug( "  - #{@} was registered for #{protocol}:"  )

            WorkingDirectory: ( url ) =>
                return URL( join("file:///lua/gpm/vfs/modules/", string.PathFromURL( url ) ) .. "/" )
        },
        {
            get: getSource
        }
    )

    parseFileURL = loader.ParseFileURL = ( any ) ->
        if isurl( any )
            return any

        if isstring( any ) and IsURL( any )
            return URL( any )

    getFileURL = loader.GetFileURL = ( any ) ->
        url = parseFileURL( any )
        unless url
            error SourceError "Invalid URL: #{any}"
            return nil

        unless url.scheme
            error SourceError "Invalid protocol for URL: #{any}"
            return nil

        return url

    loader.FetchInfo = async ( url, base, env, parent ) ->
        url = getFileURL( url )
        return findSource( url.scheme )\FetchInfo( url, base, env, parent )

    do

        import run from moduleClass

        defaultBase = URL( "file:///lua/" )

        asyncImport = loader.AsyncImport = async ( specifier, resolver, info, base, env, parent ) ->
            :resolved, :package = await resolver( specifier, base or defaultBase )

            -- if package was found, then it must overwrite current env
            if package
                env = package.env or env

                -- if package has dependencies, wait until they are resolved
                if dependencies := package.__dependencies
                    for name, dep in pairs( dependencies )
                        if ispromise( dep )
                            await dep

            return run( resolved, env )

            -- source = findSource( resolved.scheme )
            -- info or= await source\FetchInfo( resolved, base )
            -- info = await source\Install( resolved, info )
            -- return source\Run( resolved, info, env, parent )

    local getImportMeta
    do

        import getfenv, rawget from _G
        import getfmain from debug

        getModule = loader.GetModule = ( func = getfmain! ) ->
            if fenv := func and getfenv( func )
                return rawget( fenv, "__module" )

        getURL = loader.GetURL = ( func = getfmain! ) ->
            if fpath := func and getfpath( func )
                if fenv := getfenv( func )
                    if m := rawget( fenv, "__module" )
                        if url := m.url
                            return url

                if IsURL( fpath )
                    return URL( fpath )

                return URL( "file:///" .. fpath )

        getParentURL = loader.GetParentURL = ( m = getModule! ) ->
            return m and m.url or nil

        getEnvironment = loader.GetEnvironment = ( m = getModule! ) ->
            return m and m.env or nil

        getPackage = loader.GetPackage = ( env = getEnvironment! ) ->
            return env and env.__package or nil

        getImportMeta = loader.GetImportMeta = ->
            local base, parent, env
            if fmain := getfmain!
                if m := getModule( fmain )
                    base = getParentURL( m )
                    env = getEnvironment( m )
                    parent = getPackage( env )

                base or= getURL( fmain )

            return base, env, parent

    gpm.Import = ( specifier ) ->
        argument( specifier, 1, "string" )
        return asyncImport( specifier, esmResolve, nil, getImportMeta! )

    -- just for a .lua users
    environment.import = ( specifier ) ->
        argument( specifier, 1, "string" )
        return await asyncImport( specifier, esmResolve, nil, getImportMeta! )

    do

        :resolve = requireClass

        environment.require = ( modname ) ->
            argument( modname, 1, "string" )
            return await asyncImport( modname, resolve, nil, getImportMeta! )

    do

        :resolve = includeClass

        environment.include = environment.dofile = ( fileName ) ->
            argument( fileName, 1, "string" )
            return await asyncImport( fileName, resolve, nil, getImportMeta! )

-- packages autorun
do

    import display from environment.Error
    import Logger, repositories from gpm
    import all, allSettled from Promise

    -- this one has [name@version or url] = Promise
    dependencies = loader.Dependencies = {}

    -- used for reloading server if not all dependencies were installed
    lastHumanCount = 0
    getHumanCount = -> #_G.player.GetHumans()

    local installDependency, resolveDependencies

    installDependency = async ( pkg, name, target, force ) ->
        unless isstring( name )
            error PackageError "invalid dependency name '#{name}' for '#{pkg}'"

        -- caching installation so duplicate dependencies wont be installed two times
        if force ~= true
            ref = tostring( target )
            unless IsURL( ref )
                ref = name .. "@" .. target

            task = dependencies[ ref ]
            if task
                return task

            dependencies[ ref ] = task = installDependency( pkg, name, target, true )
            unless pkg.__dependencies[ name ]
                pkg.__dependencies[ name ] = task

            return task

        if istable( target )
            -- handle multiple
            return nil

        unless isstring( target )
            error PackageError "invalid dependency target '#{target}' for '#{name}' in '#{pkg}'"

        local workdir
        unless IsURL( target )
            -- probably version
            res = await repositories.FindPackage( name, target )
            unless res
                error PackageError "could not find package '#{name}' with version '#{target}' for '#{pkg}'"

            target = res.url
            workdir = "lua/gpm/vfs/packages/" .. name .. "/" .. tostring( res.version ) .. "/"

        url = URL( target )
        source = getSource( url )

        unless source
            error PackageError "source for '#{url}' not found (dependency of '#{pkg}')"

        info = await source\FetchInfo( url )

        if source.Install
            await source\Install( info, workdir )
            Logger\Info( "Installed dependency '%s' [%s] for '%s'", name, target, pkg.name )

        pkg.__dependencies[ name ] = info.package

        -- resolve dependencies of the dependency
        await resolveDependencies( info.package )
        return nil

    loader.InstallDependency = installDependency

    resolveDependencies = async ( pkg ) ->
        unless pkg.dependencies
            return nil

        tasks, taskCount = {}, 0
        for name, target in pairs( pkg.dependencies )
            taskCount += 1
            tasks[ taskCount ] = installDependency( pkg, name, target )

        await all( tasks )

        -- hacky way to determine if all packages were installed
        for _, task in pairs( dependencies )
            if task.state == task.STATE_PENDING
                return nil

        -- alright, it seems that all dependencies were installed
        -- let's restart server if there is any humans on the servers
        if getHumanCount() > lastHumanCount
            RunConsoleCommand( "changelevel", game.GetMap() )

        return nil

    loader.ResolveDependencies = resolveDependencies

    initializePackage = async ( pkg ) ->
        if SERVER
            -- we are resolving dependencies only on server
            await resolveDependencies( pkg )

            -- AddCSLuaFile in pkg.send
            for fileName in *pkg.send
                addcsluafile( URL( fileName, pkg.url ).pathname )

        unless pkg.autorun
            return nil

        Logger\Info( "Executing '%s@%s' package...", pkg.name, pkg.version )
        await asyncImport( pkg.name, esmResolve, nil, pkg.url, pkg.env )
        return nil

    loader.InitializePackage = initializePackage

    loader.Startup = async ->
        if SERVER
            lastHumanCount = getHumanCount()

        Logger\Info( "Parsing `packages/` directory..." )
        _, folders = Find( "packages/*", file.LuaPath, true )
        base = URL( "file:///lua/packages/" )

        readTasks, taskCount = {}, 0
        for folderName in *folders
            taskCount += 1
            readTasks[ taskCount ] = packageRead( URL( folderName .. "/", base ) ) -- TODO: addcsluafile

        -- no :>
        pkgs, pkgCount = {}, 0

        for result in *await( allSettled( readTasks ) )
            if result.value
                pkgCount += 1
                pkgs[ pkgCount ] = result.value

            elseif result.status == "rejected"
                display( result.reason )

        if pkgCount == 0
            Logger\Info( "No packages were found :<" )
            return nil

        Logger\Info( "Found %d packages! Initializing them...", pkgCount )

        tasks, taskCount = {}, 0
        for pkg in *pkgs
            taskCount += 1
            tasks[ taskCount ] = initializePackage( pkg )

        tasks = await allSettled( tasks )

        for index = 1, taskCount
            result = tasks[ index ]
            if result.status == "rejected"
                display( result.reason )

        return nil
