_G = _G
import gpm, getmetatable, setmetatable, rawset from _G
import environment from gpm

import debug, string, path, table, file, util, isurl, isstring, ArgAssert, URL, NotImplementedError, ModuleError, Promise, error from environment
import getCurrentFile, getCurrentDirectory from path
import async, await, reject from Promise
import getfpath from debug

:loader = gpm
unless istable( loader )
    loader = gpm.loader = { Modules: {} }

local repositories

if SERVER or MENU_DLL
    import Query from _G.sql

    Query( "CREATE TABLE IF NOT EXISTS `gpm.repository` ( ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, URL TEXT NOT NULL )" )
    Query( "CREATE TABLE IF NOT EXISTS `gpm.packages` ( Name TEXT PRIMARY KEY NOT NULL, URL TEXT UNIQUE NOT NULL, InstalledVersion TEXT, RepositoryID INTEGER DEFAULT 0 NOT NULL, FOREIGN KEY(repositoryID) REFERENCES `gpm.repository` (ID) )" )

    repositories = Query( "SELECT * FROM `gpm.repository`" ) or {}

    length = #repositories
    if length == 0
        Query( "INSERT INTO `gpm.repository` ( URL ) VALUES ( 'https://raw.githubusercontent.com/Pika-Software/.github/main/gpm/repositories.json' )" )
        repositories = Query( "SELECT * FROM `gpm.repository`" ) or {}

    for index = 1, length
        repository = repositories[ index ]
        repository.Packages = Query( "SELECT * FROM `gpm.packages` WHERE RepositoryID = " .. repository.ID ) or {}

    loader.Repositories = repositories

if SERVER
    f = environment.addon.File!
    f\SetTitle( "GLua Package Manager::Repositories" )

    filePath = "/lua/gpm/vfs/repositories.lua"
    f\SetFile( filePath, "return '" .. util.TableToJSON( repositories, false ) .. "'" )
    f\Mount( false )

    file.AddCSLuaFile( filePath )

if CLIENT
    repositories = include( "gpm/vfs/repositories.lua" )
    if repositories
        repositories = loader.Repositories = util.JSONToTable( repositories )

packages = gpm.Packages
unless istable( packages )
    packages = gpm.Packages = setmetatable( {}, {
        __newindex: debug.fempty
        __index: ( tbl, key ) ->
            new = {}
            rawset( tbl, key, new )
            return new
    } )

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
import sub, byte, find, match, gsub, format, StartsWith, IsURL from string
import IsFile from file

local Package
do

    import getDirectory, getFileName from path
    import Version from util
    import tobool from _G

    loader.Module = class Module
        __tostring: =>
            return format( "Module: %p [%s]", @, @name )

        new: ( @location, @url, @env = _G ) =>
            unless isurl( url )
                error ModuleError "url is " .. type( url ) .. ", expected URL"

            @name = getfpath( location ) or "unknown"

            :pathname = url
            setfenv( location, setmetatable({ __module: @, __filename: pathname, __dirname: getDirectory( pathname ) }, { __index: env, __newindex: env }) )

            loader.Modules[ url.href ] = @
            return

        run: ( ... ) =>
            if result := @result
                return result

            result = @result = async( @location )( ... )
            return result

        @getAll: -> loader.Modules

        @get: ( url ) -> loader.Modules[ url.href ]

        @run: ( location, url, env ) ->
            m = Module.get( url )
            unless m
                m = Module( location, url, env )

            return m\run!

    environment.ismodule = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Module

    default = Color( 50, 100, 200 )

    class Package
        __tostring: =>
            return format( "Package: %p [%s@%s]", @, @name, @version )

        new: ( filePath, info ) =>
            @path = filePath

            unless info
                @name = match( filePath, ".*packages/([^/]+)" ) or getFileName( filePath )
                @version = Version( "0.1.0" )
                return nil

            -- name
            name = info.name
            unless isstring( name )
                name = match( filePath, ".*packages/([^/]+)" ) or getFileName( filePath )

            if not name or name == ""
                name = format( "%p", @ )

            @name = name

            -- version
            version = info.version
            unless isstring( version )
                version = "0.1.0"

            version = @version = Version( version )

            -- autorun
            @autorun = tobool( info.autorun )

            -- send
            :send = info
            unless istable( send )
                send = {}

            @send = send

            -- exports
            :exports = info
            if isstring( exports )
                exports = { [ "." ]: exports }
            elseif not istable( exports )
                exports = nil

            @exports = exports

            -- imports
            :imports = info
            if isstring( imports )
                imports = { [ "." ]: imports }
            elseif not istable( imports )
                imports = nil

            @imports = imports

            -- dependencies
            :dependencies = info
            unless istable( dependencies )
                dependencies = nil

            @dependencies = dependencies

            -- logger
            :logger = info
            unless istable( logger )
                logger = {
                    interpolation: true
                    disabled: false
                    color: default
                }

            @logger = logger

            -- description
            :description = info
            unless isstring( description )
                description = "Description not provided"

            @description = description

            -- license
            :license = info
            unless isstring( license )
                license = "License not provided"

            @license = license

            -- homepage
            :homepage = info
            unless isstring( homepage )
                homepage = "Homepage not provided"

            @homepage = homepage

    environment.ispackage = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Package

-- TODO: after this works as specs intended, optimize it and make better!
local ESM
do

    import CompileLuaString, CompileMoonString, CompileYueString, JSONToTable, Logger from util
    import AsyncRead, IsDir, NormalizeGamePath from file
    import join, stripExtension from path
    import PackageError from environment
    import canParse from URL
    import Merge from table

    local getPackage
    do

        environmentMetatable = { __index: environment }

        hooksMeta = {
            __index: ( tbl, key ) ->
                new = {}
                rawset( tbl, key, new )
                return new
        }

        getPackage = ( filePath, info ) ->
            pkg = Package( filePath, info )
            if info
                :name, :version = pkg

                existing = packages[ name ][ version ]
                if existing
                    return existing

                packages[ name ][ version ] = pkg

                -- package logger
                :logger = pkg
                if logger
                    if logger.disabled
                        logger = nil
                    else
                        logger = Logger( name .. "@" .. version\__tostring!, logger.color, logger.interpolation )
                else
                    logger = Logger( name .. "@" .. version\__tostring! )

                pkg.__hooks = setmetatable( {}, hooksMeta )
                pkg.__prefix = pkg\__tostring! .. "::"
                pkg.__timers = {}

                -- package environment
                pkg.env = setmetatable( { __package: pkg, Logger: logger }, environmentMetatable )

            return pkg

    class ESM
        DEFAULT_CONDITIONS = {
            [SERVER and "server" or CLIENT and "client" or MENU_DLL and "menu" or "default"]: true,
        }

        -- Just a shortcut so `ESM.resolve ...` can be used instead of creating a new instance.
        @resolve: ( ... ) -> ESM!\resolve( ... )

        -- ESM_RESOLVE(specifier, parentURL)
        resolve: async ( specifier, parentURL ) =>
            @specifier = specifier
            @parentURL = parentURL

            local resolved

            -- resolve
            if isurl( specifier ) or canParse( specifier )
                resolved = URL( specifier )
            elseif StartsWith( specifier, "/" ) or StartsWith( specifier, "./" ) or StartsWith( specifier, "../" )
                resolved = URL( specifier, parentURL )
            elseif specifier == "gpm" or StartsWith( specifier, "gpm/" )
                resolved = URL( "gpm:///" .. sub( specifier, 5 ) )
            elseif specifier == "gmod" or StartsWith( specifier, "gmod/" )
                resolved = URL( "gmod:///" .. sub( specifier, 6 ) )
            elseif specifier == "garrysmod" or StartsWith( specifier, "garrysmod/" )
                resolved = URL( "garrysmod:///" .. sub( specifier, 11 ) )
            elseif StartsWith( specifier, "#" )
                resolved = packageImportsResolve( @, specifier, parentURL )
            else
                -- specifier is now a bare specifier
                resolved = packageResolve( @, specifier, parentURL )

            return { :resolved, package: @pjson }

        -- PACKAGE_RESOLVE(packageSpecifier, parentURL)
        packageResolve = ( packageSpecifier, parentURL ) =>
            local packageName
            if packageSpecifier == ""
                error PackageError "specifier is an empty string"

            -- If packageSpecifier is a Node.js builtin module name, then
            -- 1. Return the string "node:" concatenated with packageSpecifier.

            if not StartsWith( packageSpecifier, "@" )
                packageName = match( packageSpecifier, "(.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the first "/" separator or the end of the string.
            else
                packageName = match( packageSpecifier, "(.-/.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the second "/" separator or the end of the string.
                if not packageName -- If packageSpecifier does not contain a "/" separator, then
                    error PackageError "invalid specifier '#{packageSpecifier}'"

            if StartsWith( packageSpecifier, "." ) or find( packageSpecifier, "%", 1, true ) or find( packageSpecifier, "\\", 1, true )
                error PackageError "invalid specifier '#{packageSpecifier}'"

            packageSubpath = "." .. sub( packageSpecifier, #packageName + 1 )

            if selfURL := packageSelfResolve( @, packageName, packageSubpath, parentURL )
                return selfURL

            local packageURL
            while not packageURL or packageURL.path[1] ~= "packages" -- While parentURL is not the file system root
                firstTime = not packageURL

                packageURL = URL( "packages/" .. packageName .. "/", parentURL ) -- Let packageURL be the URL resolution of "node_modules/" concatenated with packageSpecifier, relative to parentURL.
                parentURL = URL( "..", parentURL ) -- Set parentURL to the parent folder URL of parentURL.

                if packageURL.scheme == "file" and not IsDir( packageURL.pathname ) -- If the folder at packageURL does not exist, then
                    if result := firstTime and packageDependenciesResolve( @, packageName, packageSubpath )
                        return result

                    continue

                pjson = @pjson = readPackageJSON( @, packageURL )
                if pjson and pjson.exports
                    return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

                return URL( packageSubpath, packageURL )

            error PackageError "package not found: '#{packageSpecifier}' from '#{@parentURL}'"
            return

        -- PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL)
        packageSelfResolve = ( packageName, packageSubpath, parentURL ) =>
            packageURL = lookupPackageScope( @, parentURL )
            if not packageURL
                return

            pjson = @pjson = readPackageJSON( @, packageURL )
            if not pjson or not pjson.exports
                return

            if pjson.name == packageName
                return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

        packageDependenciesResolve = ( packageName, packageSubpath ) =>
            -- @pjson must be set by packageSelfResolve
            pjson = @pjson
            if not pjson or not istable(pjson.dependencies)
                return

            target = pjson.dependencies[ packageName ]
            if isstring( target )
                return packageDependencyResolve( @, packageName, target, packageSubpath )


        packageDependencyResolve = ( name, target, subpath ) =>
            if not target or #target == 0
                error PackageError "invalid dependency target '#{target}' for '#{name}'"

            -- TODO: implement URL target and etc.
            targetPath = target
            unless match( target, "^[%w._+~^-]+$" )
                targetPath = util.MD5( target )

            packageURL = URL( join("file:///lua/gpm/vfs/packages", name, targetPath, "/") )
            unless IsDir( packageURL.pathname )
                return

            pjson = @pjson = readPackageJSON( @, packageURL )
            if pjson and pjson.exports
                return packageExportsResolve( @, packageURL, subpath, pjson.exports )

            return URL( packageSubpath, packageURL )

        exportsStartsWithDot = ( exports, packageURL ) =>
            if istable( exports )
                local state
                for k, _ in pairs exports
                    statsWithDot = StartsWith( k, "." )
                    if state == nil
                        state = statsWithDot
                    elseif state ~= statsWithDot
                        error PackageError "'#{packageURL}' exports are invalid"
                return state
            -- otherwise exports must be a string
            return StartsWith( exports, "." )

        -- PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)
        packageExportsResolve = ( packageURL, subpath, exports ) =>
            startsWithDot = exportsStartsWithDot( @, exports, packageURL )

            if subpath == "."
                local mainExport
                if isstring( exports ) or not startsWithDot
                    mainExport = exports
                elseif istable( exports ) and startsWithDot
                    mainExport = exports["."]

                if mainExport
                    if resolved := packageTargetResolve( @, packageURL, mainExport, nil, false )
                        return resolved
            elseif istable( exports ) and startsWithDot
                if resolved := packageImportsExportsResolve( @, subpath, exports, packageURL, false )
                    return resolved

            error PackageError "no exports found for '#{subpath}' in '#{packageURL}'"
            return

        -- PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)
        packageImportsResolve = ( specifier, parentURL ) =>
            if specifier == "#" or StartsWith( specifier, "#/" )
                error PackageError "invalid import specifier '" .. specifier .. "'"

            packageURL = lookupPackageScope( @, parentURL )
            if packageURL
                pjson = @pjson = readPackageJSON( @, packageURL )
                if pjson and pjson.imports
                    if resolved := packageImportsExportsResolve( @, specifier, pjson.imports, packageURL, true )
                        return resolved

            error PackageError "imports are not defined for '" .. specifier .. "' in #{packageURL or parentURL}"
            return

        -- PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports)
        packageImportsExportsResolve = ( matchKey, matchObj, packageURL, isImports ) =>
            if matchObj[matchKey] and not find( matchKey, "*", 1, true )
                target = matchObj[matchKey]
                return packageTargetResolve( @, packageURL, target, nil, isImports )

            -- TODO: Implement pattern matching
            error PackageError "pattern matching is not implemented"
            return

        -- PACKAGE_TARGET_RESOLVE(packageURL, target, patternMatch, isImports, conditions)
        packageTargetResolve = ( packageURL, target, patternMatch, isImports ) =>
            if isstring( target )
                unless StartsWith( target, "./" )
                    if isImports == false or StartsWith( target, "/" ) or StartsWith( target, "../" ) or canParse( target )
                        error PackageError "invalid target '#{target}' for '#{packageURL}'"

                    if isstring( patternMatch )
                        return packageResolve( @, gsub( target, "*", patternMatch ), packageURL )

                    return packageResolve( @, target, packageURL )

                -- TODO: If target split on "/" or "\" contains any "", ".", "..", or "node_modules" segments after the first "." segment, case insensitive and including percent encoded variants, throw an Invalid Package Target error.

                resolvedTarget = URL( target, packageURL )
                if patternMatch == nil
                    return resolvedTarget

                -- TODO: If patternMatch split on "/" or "\" contains any "", ".", "..", or "node_modules" segments, case insensitive and including percent encoded variants, throw an Invalid Module Specifier error.
                resolvedTarget.pathname = gsub( resolvedTarget.pathname, "*", patternMatch )
                return resolvedTarget
            elseif istable( target )
                if #target == 0 -- object
                    local defaultValue
                    for p, targetValue in pairs target
                        if DEFAULT_CONDITIONS[p]
                            if resolved := packageTargetResolve( @, packageURL, targetValue, patternMatch, isImports )
                                return resolved
                        elseif p == "default"
                            defaultValue = targetValue

                    -- resolving "default" at the end because tables in lua are unordered
                    if defaultValue
                        return packageTargetResolve( @, packageURL, defaultValue, patternMatch, isImports )

                    return nil

                -- array
                local success, resolved
                for targetValue in *target
                    success, resolved = pcall( packageTargetResolve, @, packageURL, targetValue, patternMatch, isImports )
                    if success and resolved
                        return resolved

                unless success
                    error resolved
                    return

                return nil
            elseif target == nil
                return nil

            error PackageError "invalid target '#{target}' for '#{packageURL}'"
            return

        -- LOOKUP_PACKAGE_SCOPE(url)
        lookupPackageScope = ( url ) =>
            if url.scheme ~= "file"
                error PackageError "unable to lookup package scope for '#{url}' (not a file:/// URL)"

            local scopeURL = URL( "./package.lua", url )
            while scopeURL.path[1] ~= "package.lua" -- not filesystem root
                if scopeURL.path[ #scopeURL.path - 1 ] == "packages"
                    return

                if IsFile( scopeURL.pathname )
                    return URL( "./", scopeURL )

                scopeURL = URL( "../package.lua", scopeURL )

        -- READ_PACKAGE_JSON(packageURL)
        readPackageJSON = ( packageURL ) =>
            pjsonPath = join( packageURL.pathname, "package.lua" )
            unless IsFile( pjsonPath )
                return

            filePath, gamePath = NormalizeGamePath( pjsonPath )

            withoutExtension, extension = stripExtension( filePath )
            if IsFile( withoutExtension .. ".yue", gamePath, true )
                extension = "yue"
            elseif IsFile( withoutExtension .. ".moon", gamePath, true )
                extension = "moon"

            filePath = withoutExtension .. "." .. extension
            content = await AsyncRead( filePath, gamePath, true )

            if extension == "lua"
                firstByte = byte( content, 1 )
                if firstByte == 0x5b --[['[']] or firstByte == 0x7b --[['{']]
                    info = JSONToTable( content )
                    if info
                        return getPackage( filePath, info )

            func = switch extension
                when "yue"
                    CompileYueString( content, filePath, true )
                when "moon"
                    CompileMoonString( content, filePath, true )
                else
                    CompileLuaString( content, filePath, true, false )

            if func
                info = {}
                setfenv( func, info )
                success, result = pcall( func )
                if success
                    if istable( result )
                        Merge( info, result )

                    return getPackage( filePath, info )

                error PackageError "File '" .. filePath .. "' compilation error: " .. result
                return

            error PackageError "File '" .. filePath .. "' cannot be compiled."
            return

    loader.ESM = ESM

class Require
    PACKAGE_PATHS = { "./?.lua", "./?/init.lua" }

    -- Just a shortcut so `Require.resolve ...` can be used instead of creating a new instance.
    @resolve: ( ... ) -> Require!\resolve( ... )

    resolve: async ( modname, base ) =>
        unless base
            error ModuleError "`require` cannot be used outside of modules"

        if base.scheme ~= "file"
            error NotImplementedError "cannot use `require` from `#{base}`"

        isOpaque = isRequireSyntax( modname )
        filePath = gsub( modname, "%.", "/" )

        if resolved := isOpaque and resolveFile( @, filePath, base )
            return { :resolved }

        success, resolved = try await ESM.resolve( isOpaque and filePath or modname, base )
        if success
            return resolved

        if util.IsBinaryModuleInstalled( modname )
            return { resolved: URL( "dll:" .. modname ) }

        -- TODO: make better errors
        error resolved -- just return error from ESM
        return

    isRequireSyntax = ( modname ) -> match( modname, "^[%a%d_%-.]+$" )

    resolveFile = ( filePath, base ) =>
        for pattern in *PACKAGE_PATHS
            url = URL( gsub( pattern, "%?", filePath ), base )
            if IsFile( url.pathname )
                return url

loader.Require = Require

class Include
    -- Just a shortcut so `Include.resolve ...` can be used instead of creating a new instance.
    @resolve: ( ... ) -> Include!\resolve( ... )

    resolve: async ( fileName, base ) =>
        if base and base.scheme == "file"
            resolved = URL( fileName, base )
            if resolved.path[1] == "lua" and IsFile( resolved.pathname )
                return { :resolved }

        resolved = URL( fileName, "file:///lua/" )
        if resolved.path[1] == "lua" and IsFile( resolved.pathname )
            return { :resolved }

        return ESM.resolve( fileName, base )

loader.Include = Include

local findSource
do

    import SourceError from environment

    sources = loader.Sources
    unless istable( sources )
        sources = loader.Sources = {}

    findSource = loader.FindSource = ( scheme ) ->
        source = sources[ scheme ]
        if source
            return source

        error SourceError "Source for scheme '#{scheme}' not implemented."
        return

    registerSource = loader.RegisterSource = ( scheme, source ) ->
        sources[ scheme ] = source

    class loader.BaseSourceHandler
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source handler", @ )

        FetchInfo: async ( url, base, env, parent ) =>
            return nil

        Install: async ( url, info, base, env, parent ) =>
            error NotImplementedError "Source:Install( url, info, base, env, parent )"
            return

    class loader.BaseSource
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source", @ )

        new: ( ... ) =>
            @handlers = {}

            for scheme in *{ ... }
                registerSource( scheme, @ )

        RegisterHandler: ( handler ) =>
            @handlers[] = handler

        CallHandler: ( name, url, ... ) =>
            for handler in *@handlers
                if not handler.ShouldHandle or handler\ShouldHandle( url, ... )
                    return handler[ name ]( handler, url, ... )

            return reject SourceError "No handler found for URL '#{url}' (" .. name .. ")"

        FetchInfo: ( url, base, env, parent ) =>
            return @CallHandler( "FetchInfo", url, base, env, parent )

        Install: ( url, info, base, env, parent ) =>
            return @CallHandler( "Install", url, info, base, env, parent )

    parseFileURL = loader.ParseFileURL = ( any ) ->
        if isurl( any )
            return any

        if isstring( any ) and IsURL( any )
            return URL( any )

    getFileURL = loader.GetFileURL = ( any ) ->
        url = parseFileURL( any )
        unless url
            error SourceError "Invalid URL: #{any}"

        unless url.scheme
            error SourceError "Invalid protocol for URL: #{any}"

        return url

    loader.FetchInfo = async ( url, base, env, parent ) ->
        url = getFileURL( url )
        return findSource( url.scheme )\FetchInfo( url, base, env, parent )

    asyncImport = loader.AsyncImport = async ( specifier, resolver, info, base = URL( "file:///lua/" ), env, parent ) ->
        :resolved, :package = await resolver( specifier, base )

        -- if package was found, then it must overwrite current env
        if package
            env = package.env or env

        source = findSource( resolved.scheme )

        unless info
            info = await source\FetchInfo( resolved, base, env, parent )

        return source\Install( resolved, info, base, env, parent )

    local getImportMeta
    do

        import getfenv, rawget from _G
        import getfmain from debug

        getModule = loader.GetModule = ( func = getfmain! ) ->
            if fenv := func and getfenv( func )
                return rawget( fenv, "__module" )

        getURL = loader.GetURL = ( func = getfmain! ) ->
            if fpath := func and getfpath( func )
                if fenv := getfenv( func )
                    if m := rawget( fenv, "__module" )
                        if url := m.url
                            return url

                if IsURL( fpath )
                    return URL( fpath )

                return URL( "file:///" .. fpath )

        getParentURL = loader.GetParentURL = ( m = getModule! ) ->
            return m and m.url or nil

        getEnvironment = loader.GetEnvironment = ( m = getModule! ) ->
            return m and m.env or nil

        getPackage = loader.GetPackage = ( env = getEnvironment! ) ->
            return env and env.__package or nil

        getImportMeta = loader.GetImportMeta = ->
            local base, parent, env
            if fmain := getfmain!
                if m := getModule( fmain )
                    base = getParentURL( m )
                    env = getEnvironment( m )
                    parent = getPackage( env )

                base or= getURL( fmain )

            return base, env, parent

    gpm.Import = ( specifier ) ->
        ArgAssert( specifier, 1, "string" )
        return asyncImport( specifier, ESM.resolve, nil, getImportMeta! )

    -- just for a .lua users
    environment.import = ( specifier ) ->
        ArgAssert( specifier, 1, "string" )
        return await asyncImport( specifier, ESM.resolve, nil, getImportMeta! )

    environment.require = ( modname ) ->
        ArgAssert( modname, 1, "string" )
        return await asyncImport( modname, Require.resolve, nil, getImportMeta! )

    environment.include = environment.dofile = ( fileName ) ->
        ArgAssert( fileName, 1, "string" )
        return await asyncImport( fileName, Include.resolve, nil, getImportMeta! )

-- packages autorun
do

    import display from environment.Error
    import SafeAwait from Promise
    import resolve from ESM
    import Empty from table
    import Logger from gpm

    Empty( loader.Modules )
    Empty( gpm.Packages )

    async( ->
        base = URL( "file:///lua/" )

        _, folders = file.Find( "packages/*", file.LuaPath, true )
        for folderName in *folders
            ok, result = SafeAwait resolve( folderName, base )
            unless ok
                display( result )
                continue

            :resolved, :package = result
            unless package and package.autorun
                continue

            Logger\Debug( "Package autorun: " .. package\__tostring! )

            source = findSource( resolved.scheme )
            unless source
                continue

            :env = package

            ok, result = SafeAwait source\FetchInfo( resolved, base, env, nil )
            unless ok
                display( result )
                continue

            ok, result = SafeAwait source\Install( resolved, result, base, env, nil )
            unless ok
                display( result )

        return nil
    )!\Catch( display )
