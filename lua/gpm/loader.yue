_G = _G
import gpm from _G
import environment, CreateEnvironment from gpm
import isurl, isstring, rawget, getfenv from environment
import async, await, reject from environment.Promise
-- import sub, find, gsub, len, match from string
import getfmain, getfpathi from environment.debug
import format, IsURL from environment.string
import NotImplementedError from environment
import parse from environment.URL
-- import Fetch from environment.http

-- class ModuleURLResolutionError extends environment.Error
-- environment.ModuleURLResolutionError = ModuleURLResolutionError

-- class InvalidModuleSpecifierError extends environment.Error
-- environment.InvalidModuleSpecifierError = InvalidModuleSpecifierError

class ModuleLoadError extends environment.Error
environment.ModuleLoadError = ModuleLoadError

-- class ModuleNotFoundError extends environment.Error
-- environment.ModuleNotFoundError = ModuleNotFoundError

class SourceError extends environment.Error
environment.SourceError = SourceError

:loader = gpm
unless istable( loader )
    loader = gpm.loader = {}

--[[

    file://path/to/file/in/game
    game://path/to/file/in/game
    data://path/to/file/in/data
    lua://path/to/file/in/lua

    Sources: {
        file: Source Obj1
        game: Source Obj1
        data: Source Obj1
        lua: Source Obj1
        http: Source Obj2
        https: Source Obj2
    }

]]

sources = loader.Sources
unless istable( sources )
    sources = loader.Sources = {}

findSource = ( scheme ) ->
    src = sources[ scheme ]
    if src
        return src

    error SourceError "Source for scheme '#{scheme}' not implemented."
    return

loader.FindSource = findSource

registerSource = ( scheme, source ) ->
    sources[ scheme ] = source

loader.RegisterSource = registerSource

class loader.BaseSourceHandler
    __tostring: =>
        return format( "%s: %p", @@__name or "unknown source handler", @ )

    FetchInfo: async ( url, parent_url, parent_pkg, parent_env ) =>
        error NotImplementedError "Source:FetchInfo( url, parent_url, parent_pkg, parent_env )"
        return

    Install: async ( url, info, parent_url, parent_pkg, parent_env ) =>
        error NotImplementedError "Source:Install( url, info, parent_url, parent_pkg, parent_env )"
        return

class loader.BaseSource
    __tostring: =>
        return format( "%s: %p", @@__name or "unknown source", @ )

    new: ( ... ) =>
        @handlers = {}

        for scheme in *{ ... }
            registerSource( scheme, @ )

    RegisterHandler: ( handler ) =>
        @handlers[] = handler

    CallHandler: ( name, url, ... ) =>
        for handler in *@handlers
            if not handler.ShouldHandle or handler\ShouldHandle( url, ... )
                return handler[ name ]( handler, url, ... )

        return reject SourceError "No handler found for URL '#{url}' (" .. name .. ")"

    FetchInfo: ( url, parent_url, parent_pkg, parent_env ) =>
        return @CallHandler( "FetchInfo", url, parent_url, parent_pkg, parent_env )

    Install: ( url, info, parent_url, parent_pkg, parent_env ) =>
        return @CallHandler( "Install", url, info, parent_url, parent_pkg, parent_env )

parseFileURL = ( any ) ->
    if isurl( any )
        return any

    if isstring( any ) and IsURL( any )
        return parse( any )

loader.ParseFileURL = parseFileURL

getFileURL = ( any ) ->
    url = parseFileURL( any )
    unless url
        error SourceError "Invalid URL: #{any}"

    unless url.scheme
        error SourceError "Invalid protocol for URL: #{any}"

    return url

loader.GetFileURL = getFileURL

loader.FetchInfo = async ( url ) ->
    url = getFileURL( url )
    return findSource( url.scheme )\FetchInfo( url )

asyncImport = async ( url, base = "lua:", pkg, env, info ) ->
    fileURL = getFileURL( parse( url, base ) )
    src = findSource( fileURL.scheme )

    unless info
        info = await src\FetchInfo( fileURL, base, pkg, env )

    return src\Install( fileURL, info, base, pkg, env )

loader.AsyncImport = asyncImport

--[[

    tasks = {}
    for package in packages
        tasks[] = asyncImport package, parentURL

    for task in tasks
        task\Catch (err) ->
            print err

    _PKG.name
    _PKG.metadata.name
    _PKG\GetEnvironment! == getfenv(1)
    PARENT_URL

    _PKG == gpm.Package!

    _PKG.Tasks = {
        metadata: Promise 1
        download: Primise 2
    }

    Packages = { }

    -- package://PackageA/module1 -> lua://packages/PackageA/module1/package.lua
    -- lua://niknaks/package.lua

    lua://my_package/init.lua   - single file package
    lua://my_package            - multi file package ( package.lua and other files )

    NewPackage = ( url ) ->
        -- example1: url = "package://PackageA"
        -- example1: url = "lua://my_package"
        url = resolveURL( url )

        -- example1: url = "lua://packages/PackageA"
        -- example2: url = "lua://my_package"

        package = Packages[ url ]
        unless package
            package = gpm.Package( url )
            Packages[ url ] = package

        return package

    Package A:
        Code:
            ents.MyFunc = ->
                print( "FUnc!" )

            print COLLISION_GROUP_CUSTOM

        Depends:
            Package B:
                Globals:
                    markers = {}

    Package C:
        Code:
            print COLLISION_GROUP_CUSTOM
            ents.MyFunc!

        Depends:
            Package D:
                Globals:
                    markers = {}

            Package B:

    Output:
            FUnc!
            1
            2

]]

--[[

-- Simple module loader that takes url and tries to get module entry
loader.LoadURL = async ( urlStr, parentPackage ) ->
    url = URL.parse( urlStr )
    :scheme = url

    local entry_fn
    if scheme == "lua"
        entry_fn = await file.Compile( url.pathname, "LUA" )
        unless entry_fn
            error ModuleLoadError "failed to compile file " .. url.pathname

    elseif scheme == "http" or scheme == "https"
        ext = string.GetExtensionFromFilename( url.pathname )
        if ext ~= "lua"
            error ModuleLoadError "unsupported web url: " .. url.href

        req = await Fetch( url.href )
        unless req and req.code == 200 and req.body
            error ModuleLoadError "failed to fetch " .. url.href

        entry_fn = CompileString( req.body, url.href )
        unless entry_fn
            error ModuleLoadError "failed to compile file " .. url.href
    else
        error ModuleLoadError "unsupported url: " .. url.href

    -- Package environment
    env = parentPackage and parentPackage\GetEnvironment! or CreateEnvironment!

    -- Func environment
    return setfenv( entry_fn, setmetatable(
            {
                _PKG: parentPackage
                _URL: url.href
            },
            {
                __index: env
                __newindex: env
            }
        )
    )

resolvePackagePath = ( currentPath, specifier ) ->
    local filePath
    if currentPath == ""
        filePath = path.Resolve( "packages", specifier )
    else
        filePath = path.Resolve( currentPath, "packages", specifier )

    if file.Exists( filePath, "LUA" )
        return filePath

    if currentPath ~= ""
        return resolvePackagePath( sub( string.GetPathFromFilename( currentPath ), 1, -2 ), specifier )

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
loader.PackageResolve = async ( specifier, parentURL, parentPackage ) ->
    local packageName
    if specifier == ""
        error InvalidModuleSpecifierError specifier

    if string.StartsWith( specifier, "@" )
        unless match( specifier, "/" ) -- check if specifier even has /
            error InvalidModuleSpecifierError specifier

        packageName = match( specifier, "(@[^/]*/[^/]*)" )
    else
        packageName = match( specifier, "([^/]*)" )

    if sub( packageName, 1, 1 ) == "." or match( packageName, "[\\%%]" )
        error InvalidModuleSpecifierError specifier

    packageSubPath = "." .. sub( specifier, len( packageName ) + 1 )
    if sub( packageSubPath, -1 ) == "/"
        error InvalidModuleSpecifierError specifier

    -- TODO make PACKAGE_SELF_RESOLVE
    -- if specifier := packageSelfResolve packageName, packageSubPath, parentURL
    --     return specifier

    parentPath = URL.parse( parentURL )\getPath!
    if parentPath == ""
        parentPath = "./"

    packagePath = resolvePackagePath( parentPath, specifier )
    if packagePath
        pkg = await gpm.ParsePackage( path.Join( packagePath, "package.lua" ) ) -- TODO: lookup package in global table

        -- TODO: If pmeta is not null and pmeta.exports is not null or undefined, then
        -- Return the result of PACKAGE_EXPORTS_RESOLVE(packagePath, packageSubpath, pjson.exports, defaultConditions).
        urlStr = "lua:" .. path.Join( pkg.dir, pkg.entry )

        if packageSubPath ~= "." or pkg.entry
            if parentPackage
                return loader.LoadURL( urlStr, parentPackage )

            return pkg\LoadURL( urlStr )

    error ModuleNotFoundError specifier
    return

-- Simplest vanilla lua `require` implementation
-- Not uses package or any other fancy stuff
-- package.path is hardcoded into it :p
do

    templates = {
        ".lua"
        "/init.lua"
    }

    length = #templates

    if CLIENT
        length += 1
        templates[ length ] = "/cl_init.lua"

    length += 1
    templates[ length ] = "/shared.lua"

    loader.RequireResolve = async ( specifier, parentURL, parentPackage ) ->
        specifier = gsub( specifier, "%.", "/" )
        url = URL.parse( parentURL )

        for index = 1, length
            success, entry = saveAwait loader.LoadURL( url\resolve( specifier .. templates[ index ] ), parentPackage )
            if success and entry
                return entry

-- Simple URL resolver based on https://nodejs.org/api/esm.html#resolution-algorithm-specification
-- without packageResolve since it is more advanced and not needed for now
loader.ResolveURL = ( specifier, parentURL ) ->
    url = URL.parse( specifier )
    if url.scheme
        return url\format!

    -- parent-url: lua:/example/foo.lua
    -- url: ../config.lua
    -- result: lua:/config.lua
    if find( url.pathname, "%.?%.?/", 1, false )
        -- If specifier is relative path then resolve it against parentURL
        return URL.resolve( parentURL, url.pathname )\format!

-- Resolves specifier and returns a promise with entry function
loader.Resolve = async ( specifier, parentURL = "lua:", parentPackage ) ->
    -- First lets try to resolve as URL
    resolved = loader.ResolveURL( specifier, parentURL )
    if resolved
        return loader.LoadURL( resolved, parentPackage )

    -- Try to resolve as vanilla `require`
    entry = await loader.RequireResolve( specifier, parentURL, parentPackage )
    if entry
        return entry

    -- Try to resolve as package
    return loader.PackageResolve( specifier, parentURL, parentPackage )

-- loader.AsyncImport = async ( specifier, parentURL, parentPackage ) ->
--     entry_fn = await loader.Resolve( specifier, parentURL, parentPackage )
--     entry_fn = async entry_fn -- convert entry to async function
--     return entry_fn!

--]]

-- loader.GetParentURL = ->
--     if func := getfmain!
--         -- Get URL from func env
--         env = getfenv( func )
--         if value := env and rawget( env, "_URL" )
--             return value

--         -- Try to resolve URL from func source
--         if folderPath := getfpathi( func )
--             url = parse( folderPath )
--             url.protocol or= "lua"
--             return url.href

--     return "lua:" -- default fallback

-- loader.GetPackage = ->
--     if func := getfmain!
--         env = getfenv( func )
--         return env and rawget( env, "_PKG" )

-- loader.GetEnvironment = ->
--     if func := getfmain!
--         env = getfenv( func )
--         return env and rawget( env, "_ENV" )

gpm.Import = ( url, should_await ) ->
    local env, pkg, base
    if func := getfmain!
        if fenv := getfenv( func )
            mdl = rawget( fenv, "_MODULE" )
            if mdl
                env, base = mdl.env, mdl.url
                pkg = env._PACKAGE

        unless base
            if folderPath := getfpathi( func )
                url = parse( folderPath )
                url.protocol or= "lua"
                base = url.href

    result = asyncImport( url, base, pkg, env, nil )
    if should_await ~= false
        return await( result )

    return result

environment.require = gpm.Import
