_G = _G
import gpm from _G
import environment from gpm
import string, file, path, isurl, isstring, rawget, getfenv, URL from environment
import async, await, reject from environment.Promise
import getfmain, getfpathi from environment.debug
import NotImplementedError, SourceError, ArgAssert from environment
-- import Fetch from environment.http

:loader = gpm
unless istable( loader )
    loader = gpm.loader = {}

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
import CompileLuaString, CompileMoonString, CompileYueString, Version, Logger, JSONToTable from environment.util
import sub, byte, find, match, len, ByteSplit, format from string
import IsFile, IsDir, LuaPath from environment.file
import ModuleError, PackageError from environment
import getDirectory from environment.path
import concat from environment.table

local Package
do

    class Module
        __tostring: =>
            return format( "Module: %p [%s]", @, @name )

        new: ( @location, @url, @env = _G ) =>
            unless isurl( url )
                error InvalidModuleConfigurationError "url is " .. type( url ) .. ", expected URL"

            :pathname = url
            @name = getfpathi( location ) or "unknown"
            setfenv( location, setmetatable({ __module: @, __filename: pathname, __dirname: getDirectory( pathname ) }, { __index: env, __newindex: env }) )
            return

        run: ( ... ) =>
            if result := @result
                return result

            result = @result = async( @location )( ... )
            return result

    loader.Module = Module

    environment.ismodule = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Module

    packages = gpm.Packages
    unless istable( packages )
        packages = gpm.Packages = setmetatable( {}, { __newindex: debug.fempty, __index: ( key ) =>
            tbl = {}
            rawset( @, key, tbl )
            return tbl
        } )

    class Package
        __tostring: =>
            return format( "Package: %p [%s@%s]", @, @name, @version )

        new: ( filePath, info ) =>
            unless istable( info )
                return {
                    path: filePath,
                    exists: false
                }

            @exists = true

            name = info.name
            unless isstring( name )
                name = match( filePath, "packages/(.+)/package%..+$" )

            @name = name

            @exports = info.exports
            @imports = info.imports

            version = info.version
            unless isstring( version )
                version = "0.1.0"

            @version = Version( version )
            @path = filePath

            -- local logger

            -- params = info.logger
            -- if params
            --     logger = Logger( name .. "@" .. version, params.color, params.interpolation )
            -- else
            --     logger = Logger( name .. "@" .. version )

            -- @logger = logger

            @env = setmetatable({ __package: @, Logger: logger }, { __index: environment, __newindex: _G })

            description = info.description
            if isstring( description )
                @description = description

    loader.Package = Package

    environment.ispackage = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Package

-- TODO: after this works as specs intended, optimize it and make better!
class ESM
    DEFAULT_CONDITIONS = {
        [SERVER and "server" or CLIENT and "client" or MENU_DLL and "menu" or "default"]: true,
    }

    -- Just a shortcut so `ESM.resolve ...` can be used instead of creating a new instance.
    @resolve: ( ... ) -> ESM!\resolve( ... )

    -- ESM_RESOLVE(specifier, parentURL)
    resolve: async ( specifier, parentURL ) =>
        @specifier = specifier
        @parentURL = parentURL

        local resolved
        -- resolve
        if isurl( specifier ) or URL.canParse( specifier )
            resolved = URL( specifier )
        elseif string.StartsWith( specifier, "/" ) or string.StartsWith( specifier, "./" ) or string.StartsWith( specifier, "../" )
            resolved = URL( specifier, parentURL )
        elseif string.StartsWith( specifier, "#" )
            resolved = packageImportsResolve( @, specifier, parentURL )
        else
            -- specifier is now a bare specifier
            resolved = packageResolve( @, specifier, parentURL )

        return { :resolved, package: @pjson }

    -- PACKAGE_RESOLVE(packageSpecifier, parentURL)
    packageResolve = ( packageSpecifier, parentURL ) =>
        local packageName
        if packageSpecifier == ""
            error PackageError "specifier is an empty string"

        -- If packageSpecifier is a Node.js builtin module name, then
        -- 1. Return the string "node:" concatenated with packageSpecifier.

        if not string.StartsWith( packageSpecifier, "@" )
            packageName = string.match( packageSpecifier, "(.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the first "/" separator or the end of the string.
        else
            packageName = string.match( packageSpecifier, "(.-/.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the second "/" separator or the end of the string.
            if not packageName -- If packageSpecifier does not contain a "/" separator, then
                error PackageError "invalid specifier '#{packageSpecifier}'"

        if string.StartsWith( packageSpecifier, "." ) or string.find( packageSpecifier, "%", 1, true ) or string.find( packageSpecifier, "\\", 1, true )
            error PackageError "invalid specifier '#{packageSpecifier}'"

        packageSubpath = "." .. string.sub( packageSpecifier, #packageName + 1 )

        if selfURL := packageSelfResolve( @, packageName, packageSubpath, parentURL )
            return selfURL

        local packageURL
        while not packageURL or packageURL.path[1] != "packages" -- While parentURL is not the file system root
            packageURL = URL( "packages/" .. packageName .. "/", parentURL ) -- Let packageURL be the URL resolution of "node_modules/" concatenated with packageSpecifier, relative to parentURL.
            parentURL = URL( "..", parentURL ) -- Set parentURL to the parent folder URL of parentURL.

            if packageURL.scheme == "file" and not file.IsDir( packageURL.pathname ) -- If the folder at packageURL does not exist, then
                continue

            pjson = @pjson = readPackageJSON( @, packageURL )
            if pjson and pjson.exports
                return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

            return URL( packageSubpath, packageURL )

        error PackageError "module not found: '#{packageSpecifier}' from '#{@parentURL}'"
        return

    -- PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL)
    packageSelfResolve = ( packageName, packageSubpath, parentURL ) =>
        packageURL = lookupPackageScope( @, parentURL )
        if not packageURL
            return

        pjson = @pjson = readPackageJSON( @, packageURL )
        if not pjson or not pjson.exports
            return

        if pjson.name == packageName
            return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

    exportsStartsWithDot = ( exports, packageURL ) =>
        if istable( exports )
            local state
            for k, _ in pairs exports
                statsWithDot = string.StartsWith( k, "." )
                if state == nil
                    state = statsWithDot
                elseif state != statsWithDot
                    error PackageError "'#{packageURL}' exports are invalid"
            return state
        -- otherwise exports must be a string
        return string.StartsWith( exports, "." )

    -- PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)
    packageExportsResolve = ( packageURL, subpath, exports ) =>
        startsWithDot = exportsStartsWithDot( @, exports, packageURL )

        if subpath == "."
            local mainExport
            if isstring( exports ) or not startsWithDot
                mainExport = exports
            elseif istable( exports ) and startsWithDot
                mainExport = exports["."]

            if mainExport
                if resolved := packageTargetResolve( @, packageURL, mainExport, nil, false )
                    return resolved
        elseif istable( exports ) and startsWithDot
            if resolved := packageImportsExportsResolve( @, subpath, exports, packageURL, false )
                return resolved

        error PackageError "no exports found for '#{subpath}' in '#{packageURL}'"
        return

    -- PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)
    packageImportsResolve = ( specifier, parentURL ) =>
        if specifier == "#" or string.StartsWith( specifier, "#/" )
            error PackageError "invalid import specifier '" .. specifier .. "'"

        packageURL = lookupPackageScope( @, parentURL )
        if packageURL
            pjson = @pjson = readPackageJSON( @, packageURL )
            if pjson and pjson.imports
                if resolved := packageImportsExportsResolve( @, specifier, pjson.imports, packageURL, true )
                    return resolved

        error PackageError "imports are not defined for '" .. specifier .. "' in #{packageURL or parentURL}"
        return

    -- PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports)
    packageImportsExportsResolve = ( matchKey, matchObj, packageURL, isImports ) =>
        if matchObj[matchKey] and not string.find( matchKey, "*", 1, true )
            target = matchObj[matchKey]
            return packageTargetResolve( @, packageURL, target, nil, isImports )

        -- TODO: Implement pattern matching
        error PackageError "pattern matching is not implemented"
        return

    -- PACKAGE_TARGET_RESOLVE(packageURL, target, patternMatch, isImports, conditions)
    packageTargetResolve = ( packageURL, target, patternMatch, isImports ) =>
        if isstring( target )
            if not string.StartsWith( target, "./" )
                if isImports == false or string.StartsWith( target, "/" ) or string.StartsWith( target, "../" ) or URL.canParse( target )
                    error PackageError "invalid target '#{target}' for '#{packageURL}'"
                if isstring patternMatch
                    return packageResolve( @, string.gsub(target, "*", patternMatch), packageURL )
                return packageResolve( @, target, packageURL )

            -- TODO: If target split on "/" or "\" contains any "", ".", "..", or "node_modules" segments after the first "." segment, case insensitive and including percent encoded variants, throw an Invalid Package Target error.

            resolvedTarget = URL( target, packageURL )
            if patternMatch == nil
                return resolvedTarget

            -- TODO: If patternMatch split on "/" or "\" contains any "", ".", "..", or "node_modules" segments, case insensitive and including percent encoded variants, throw an Invalid Module Specifier error.
            resolvedTarget.pathname = string.gsub( resolvedTarget.pathname, "*", patternMatch )
            return resolvedTarget
        elseif istable( target )
            if #target == 0 -- object
                local defaultValue
                for p, targetValue in pairs target
                    if DEFAULT_CONDITIONS[p]
                        if resolved := packageTargetResolve( @, packageURL, targetValue, patternMatch, isImports )
                            return resolved
                    elseif p == "default"
                        defaultValue = targetValue

                -- resolving "default" at the end because tables in lua are unordered
                if defaultValue
                    return packageTargetResolve( @, packageURL, defaultValue, patternMatch, isImports )
                return nil
            else -- array
                local success, resolved
                for targetValue in *target
                    success, resolved = pcall( packageTargetResolve, @, packageURL, targetValue, patternMatch, isImports )
                    if success and resolved
                        return resolved
                if not success
                    error resolved
                return nil
        elseif target == nil
            return nil

        error PackageError "invalid target '#{target}' for '#{packageURL}'"

    -- LOOKUP_PACKAGE_SCOPE(url)
    lookupPackageScope = ( url ) =>
        if url.scheme != "file"
            error PackageError "unable to lookup package scope for '#{url}' (not a file:/// URL)"

        local scopeURL = URL( "./package.lua", url )
        while scopeURL.path[1] != "package.lua" -- not filesystem root
            if scopeURL.path[ #scopeURL.path - 1 ] == "packages"
                return

            if file.IsFile( scopeURL.pathname )
                return URL( "./", scopeURL )

            scopeURL = URL( "../package.lua", scopeURL )

    -- READ_PACKAGE_JSON(packageURL)
    readPackageJSON = ( packageURL ) =>
        pjsonPath = path.join( packageURL.pathname, "package.lua" )
        unless file.IsFile( pjsonPath )
            return

        filePath, gamePath = file.NormalizeGamePath( pjsonPath )

        withoutExtension, extension = path.stripExtension( filePath )
        if file.IsFile( withoutExtension .. ".yue", gamePath, true )
            extension = "yue"
        elseif file.IsFile( withoutExtension .. ".moon", gamePath, true )
            extension = "moon"

        filePath = withoutExtension .. "." .. extension
        content = await file.AsyncRead( filePath, gamePath, true )

        if extension == "lua"
            firstByte = byte( content, 1 )
            if firstByte == 0x5b --[['[']] or firstByte == 0x7b --[['{']]
                info = JSONToTable( content )
                if info
                    return Package( filePath, info )

        func = switch extension
            when "yue"
                CompileYueString( content, filePath, true )
            when "moon"
                CompileMoonString( content, filePath, true )
            else
                CompileLuaString( content, filePath, true )

        if func
            info = {}
            setfenv( func, info )
            success, result = pcall( func )
            if success
                if istable( result )
                    table.Merge( info, result )

                return Package( filePath, info )

            error PackageError "File '" .. filePath .. "' compilation error: " .. result
            return

        error PackageError "File '" .. filePath .. "' cannot be compiled."
        return

class Require
    PACKAGE_PATHS = { "./?.lua", "./?/init.lua" }

    -- Just a shortcut so `Require.resolve ...` can be used instead of creating a new instance.
    @resolve: ( ... ) -> Require!\resolve( ... )

    resolve: async ( modname, base ) =>
        unless base
            error ModuleError "`require` cannot be used outside of modules"
        if base.scheme != "file"
            error NotImplementedError "cannot use `require` from `#{base}`"

        isOpaque = isRequireSyntax( modname )
        filePath = string.gsub( modname, "%.", "/" )

        if resolved := isOpaque and resolveFile( @, filePath, base )
            return { :resolved }

        success, resolved = try await ESM.resolve( isOpaque and filePath or isOpaque, base )
        if success
            return resolved

        if util.IsBinaryModuleInstalled( modname )
            return { resolved: URL( "dll:" .. modname ) }

        -- TODO: make better errors
        error resolved -- just return error from ESM
    
    isRequireSyntax = ( modname ) -> string.match( modname, "^[%a%d_%-.]+$" )

    resolveFile = ( filePath, base ) =>
        for pattern in *PACKAGE_PATHS
            url = URL( string.gsub(pattern, "%?", filePath), base )
            if file.IsFile( url.pathname )
                return url

do

    import IsURL from string

    sources = loader.Sources
    unless istable( sources )
        sources = loader.Sources = {}

    findSource = loader.FindSource = ( scheme ) ->
        source = sources[ scheme ]
        if source
            return source

        error SourceError "Source for scheme '#{scheme}' not implemented."
        return

    registerSource = loader.RegisterSource = ( scheme, source ) ->
        sources[ scheme ] = source

    class loader.BaseSourceHandler
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source handler", @ )

        FetchInfo: async ( url, parent_url, parent_pkg, parent_env ) =>
            return nil

        Install: async ( url, info, parent_url, parent_pkg, parent_env ) =>
            error NotImplementedError "Source:Install( url, info, parent_url, parent_pkg, parent_env )"
            return

    class loader.BaseSource
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source", @ )

        new: ( ... ) =>
            @handlers = {}

            for scheme in *{ ... }
                registerSource( scheme, @ )

        RegisterHandler: ( handler ) =>
            @handlers[] = handler

        CallHandler: ( name, url, ... ) =>
            for handler in *@handlers
                if not handler.ShouldHandle or handler\ShouldHandle( url, ... )
                    return handler[ name ]( handler, url, ... )

            return reject SourceError "No handler found for URL '#{url}' (" .. name .. ")"

        FetchInfo: ( url, parent_url, parent_pkg, parent_env ) =>
            return @CallHandler( "FetchInfo", url, parent_url, parent_pkg, parent_env )

        Install: ( url, info, parent_url, parent_pkg, parent_env ) =>
            return @CallHandler( "Install", url, info, parent_url, parent_pkg, parent_env )

    parseFileURL = loader.ParseFileURL = ( any ) ->
        if isurl( any )
            return any

        if isstring( any ) and IsURL( any )
            return URL( any )

    getFileURL = loader.GetFileURL = ( any ) ->
        url = parseFileURL( any )
        unless url
            error SourceError "Invalid URL: #{any}"

        unless url.scheme
            error SourceError "Invalid protocol for URL: #{any}"

        return url

    loader.FetchInfo = async ( url, ... ) ->
        url = getFileURL( url )
        return findSource( url.scheme )\FetchInfo( url, ... )

    asyncImport = loader.AsyncImport = async ( specifier, base = URL("file:///lua/"), resolver, parent, env, info ) ->
        :resolved, :package = await resolver( specifier, base )
        source = findSource( resolved.scheme )

        if package -- if package was found, then it must overwrite current env
            env = package.env

        unless info
            info = await source\FetchInfo( resolved, base, parent, env )

        return source\Install( resolved, info, base, parent, env )

    loader.GetModule = (func = getfmain!) ->
        if fenv := func and getfenv( func )
            return rawget( fenv, "__module" )

    loader.GetURL = (func = getfmain!) ->
        if fpath := func and getfpathi( func )
            if string.IsURL( fpath )
                return URL( fpath )

            return URL( "file:///" .. fpath )

    loader.GetFolder = (func = getfmain!) -> -- not compatible with urls
        if fpath := func and getfpathi( func )
            return getDirectory( fpath )

    loader.GetParentURL = (m = loader.GetModule!) -> m and m.url or nil

    loader.GetEnvironment = (m = loader.GetModule!) -> m and m.env or nil

    loader.GetPackage = (env = loader.GetEnvironment!) -> env and env.__package or nil

    loader.GetImportMeta = ->
        local base, parent, env
        if fmain := getfmain!
            if m := loader.GetModule( fmain )
                base = loader.GetParentURL( m )
                env = loader.GetEnvironment( m )
                parent = loader.GetPackage( env )

            base or= loader.GetURL( fmain )

        return base, env, parent

    gpm.Import = ( specifier, should_await ) ->
        base, env, parent = loader.GetImportMeta()

        result = asyncImport( specifier, base, ESM.resolve, parent, env, nil )
        if should_await ~= false
            return await( result )

        return result

    -- TODO: Temporary solution
    -- TODO: make lua-like require
    environment.require = ( modname ) ->
        ArgAssert( modname, 1, "string" )

        base, env, parent = loader.GetImportMeta()
        return await asyncImport( modname, base, Require.resolve, parent, env, nil )

test = async ->
    gpm.Import "package_v2"
    -- package resovle

    -- :resolved, :format, :package = await ESM.resolve( "b/init.lua", URL( "file:/lua/packages/exports/" ) )
    -- source = loader.FindSource(resolved.scheme)
    -- func = await source\FetchInfo(resolved)
    -- print await source\Install(resolved, func)
    return

-- requre( "package:a" )

if SERVER
    test!\Catch( environment.Error.display )
