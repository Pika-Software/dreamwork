gpm = gpm
:Promise, :Error, :path, :string = gpm
:async, :await = Promise

class ModuleURLResolutionError extends Error
gpm.ModuleURLResolutionError = ModuleURLResolutionError

class InvalidModuleSpecifierError extends Error
gpm.InvalidModuleSpecifierError = InvalidModuleSpecifierError

class ModuleLoadError extends Error
gpm.ModuleLoadError = ModuleLoadError

class ModuleNotFoundError extends Error
gpm.ModuleNotFoundError = ModuleNotFoundError

-- https://nodejs.org/api/esm.html#resolution-algorithm-specification
-- Yeah, this loader tries to mimic ESM loader procedure

packageSelfResolve = (package_name, package_subpath, parent_url) -> nil

packageResolve = (specifier, parent_url) ->
    package_name = nil
    if specifier == ""
        error InvalidModuleSpecifierError specifier

    unless string.StartsWith specifier, "@"
        package_name = string.match specifier, "([^/]*)"
    else
        unless string.match specifier, "/" -- check if specifier even has /
            error InvalidModuleSpecifierError specifier
        package_name = string.match specifier, "(@[^/]*/[^/]*)"
    
    if string.StartsWith(package_name, ".") or string.match(package_name, "[\\%%]")
        error InvalidModuleSpecifierError specifier
    
    package_subpath = "." .. string.sub(specifier, #package_name + 1)
    if string.EndsWith package_subpath, "/"
        error InvalidModuleSpecifierError specifier
    
    if self_url = packageSelfResolve package_name, package_subpath, parent_url
        return self_url
    
    parent_url = gpm.URL parent_url
    while parent_url.path and parent_url.path != ""
        parent_url.path = string.sub string.GetPathFromFilename(parent_url.path), 1, -2
        package_url = path.Normalize path.Join parent_url.path, "packages", specifier
        if file.IsDir package_url, "LUA"
            pmeta = gpm.LoadMetadataFromDir package_url
            -- TODO If pjson is not null and pjson.exports is not null or undefined, then
            if package_subpath == "."
                if isstring pmeta.main
                    return "lua://" .. path.Join package_url, pmeta.main
            else
                return "lua://" .. path.Normalize path.Join package_url, package_subpath 

    error ModuleNotFoundError specifier

resolveURL = (specifier, parent_url) ->
    resolved = nil
    format = nil

    -- https://nodejs.org/api/esm.html#resolution-algorithm-specification
    -- should first check if url is a valid url
    if string.IsURL specifier
        resolved = specifier
    -- check if url is a relative path
    else if string.StartsWith(specifier, "./") or string.StartsWith(specifier, "../") or string.StartsWith(specifier, "/")
        filePath = specifier
        if parent_url
            parent_path = gpm.URL parent_url
            if parent_path = parent_path.protocol == "lua" and string.GetPathFromFilename parent_path.path
                filePath = path.Join parent_path, filePath
        
        resolved = "lua://" .. path.Normalize filePath
    -- it is a bare specifier, run package resolve
    else 
        resolved = packageResolve specifier, parent_url

    return resolved, format

asyncImport = async (specifier, parent_url) ->
    url, format = resolveURL specifier, parent_url
    url = gpm.URL url
    unless url.protocol == "lua"
        error ModuleURLResolutionError "cannot resolve url: #{url}"

    entry_fn = CompileFile url.path
    unless entry_fn
        error ModuleLoadError "failed to compile file #{url.path}"
    
    env = setmetatable {}, { __index: _G, __newindex: _G }
    env.require = gpm.Import
    env.Promise = gpm.Promise
    env.await = env.Promise.await
    env.async = env.Promise.async
    setfenv entry_fn, env

    entry_fn = async entry_fn
    return entry_fn!

getParentURL = ->
    -- get url from something like gpm.meta.url
    if current_dir = gpm.debug.getfpath!
        return "lua://" .. current_dir
    return "lua:///" -- default fallback

gpm.Import = (url, should_await = true) ->
    parent_url = getParentURL!
    result = asyncImport url, parent_url
    if should_await then return result\await!
    else return result
