_G = _G
import gpm from _G
import environment from gpm
import debug, string, path, table, file, util, pairs, isurl, isstring, ArgAssert, URL, ModuleError, error, pcall, PackageError, Promise from environment
import NormalizeGamePath, AbsoluteGamePath, Find from file
import stripExtension, getDirectory from path
import await, async from Promise
import getfpath from debug
import IsEmpty from table
import Version from util

file.CreateDir( "/data/gpm/vfs", true )

_G.hook.Add "ShutDown", "GLua Package Manager::VFS", ->
    file.Delete( "/data/gpm/vfs" )
    return nil

if SERVER

    import getCurrentFile, getCurrentDirectory, getFile from path
    import AsyncRead, Exists, LuaGamePaths from file
    import File from environment.addon
    import AddCSLuaFile from _G

    addFile = async ( filePath, gamePath, mountTable ) ->
        content = await AsyncRead( filePath, gamePath, true )
        unless IsBytecode( content )
            mountTable[ "/lua/" .. filePath .. ".lua" ] = content

        return nil

    addFilePath = ( filePath, gamePath, mountTable, isLuaGamePath ) ->
        files, dirs = Find( filePath, gamePath, true )
        basePath = getDirectory( filePath, true )
        searchable = getFile( filePath )

        for index = 1, #files
            fileName, extension = stripExtension( files[ index ] )

            if isLuaGamePath
                if extension == "lua" or Exists( basePath .. fileName .. ".lua", gamePath, true )
                    AddCSLuaFile( basePath .. fileName .. ".lua" )

            elseif extension == "txt"
                await addFile( basePath .. fileName .. "." .. extension, gamePath, mountTable )

        for directoryName in *dirs
            directoryPath = basePath .. directoryName
            if directoryPath == filePath
                addFilePath( directoryPath .. "/*", gamePath, mountTable, isLuaGamePath )
            else
                addFilePath( directoryPath .. "/" .. searchable, gamePath, mountTable, isLuaGamePath )

        return nil

    asyncAddCSLuaFile = async ( filePath, gamePath ) ->
        mountTable = {}
        addFilePath( filePath, gamePath, mountTable, LuaGamePaths[ gamePath ] or false )

        if IsEmpty( mountTable )
            return nil

        f = File!
        f\SetTitle( "gpm.ACSLF::" .. AbsoluteGamePath( filePath, gamePath ) )

        for fileName, content in pairs( mountTable )
            f\SetFile( fileName, content, false )

        for fileName in *await( f\AsyncMount( false ) )
            AddCSLuaFile( fileName )

        return nil

    environment.AddCSLuaFile = ( filePath = "", gamePath, skipNormalize ) ->
        if filePath == "" or getFile( filePath ) == "."
            fenv = getfenv( 2 )
            if m := fenv and fenv.__module
                filePath = m.file
            else
                filePath = getCurrentFile!

        elseif filePath == "./"
            fenv = getfenv( 2 )
            if m := fenv and fenv.__module
                filePath = m.directory .. "/*"
            else
                filePath = getCurrentDirectory( nil, true ) .. "*"

        unless skipNormalize
            filePath, gamePath = NormalizeGamePath( filePath, gamePath )

        return asyncAddCSLuaFile( filePath, gamePath )

else

    environment.AddCSLuaFile = environment.debug.fempty

:loader = gpm
unless istable( loader )
    loader = gpm.loader = {}

-- Modules and Packages are tables with format: [url] = Module/Package
packages = loader.Packages = {}
modules = loader.Modules = {}

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
import sub, byte, find, match, gsub, format, StartsWith, IsURL from string
import IsFile from file

local Module, Package
do

    import getmetatable, setmetatable from _G

    do

        import AsyncWrite, Time from file
        import PathFromURL from string

        startTime = environment.os.time! - ( gpm.StartTime or 0 )

        -- cache files have different paths for client and server
        getCachePath = ( url ) ->
            if CLIENT
                return "/lua/gpm/vfs/" .. stripExtension( PathFromURL( url ) ) .. ".lua"

            return "/data/gpm/vfs/" .. stripExtension( PathFromURL( url ) ) .. ".txt"

        class Module
            __tostring: =>
                return format( "Module: %p [%s]", @, @name )

            new: ( @url, @env = _G ) =>
                unless isurl( url )
                    error ModuleError "url is " .. type( url ) .. ", expected URL"

                @name = "unknown"

                @file = url.pathname
                @directory = getDirectory( __filename, false )

                modules[ url.href ] = @
                return nil

            load: async =>
                if @func
                    return @func

                config = {}
                env = setmetatable({ __module: @, __filename: @file, __dirname: @directory }, { __index: @env, __newindex: @env })

                if @url.scheme == "file"
                    filePath, gamePath = NormalizeGamePath( url.pathname )

                    compileResult = await AsyncCompile( filePath, env, config, gamePath, true )
                    @func = func = compileResult.func
                    @name = getfpath( func ) or "unknown"
                    return func

                error ModuleError "unsupported scheme '" .. @url.scheme .. "' ('" .. @url.href .. "')"
                return nil

            run: ( ... ) =>
                -- if result := @result
                --     return result

                -- result = @result = async( @location )( ... )
                -- return result
                return async( @location )( ... )

            @getAll: -> modules

            @get: ( url ) -> modules[ url.href ]

            -- @getCachePath: getCachePath

            -- @cache: async ( url, content ) ->
            --     filePath = getCachePath( url )
            --     if CLIENT
            --         return filePath

            --     if IsFile( filePath ) and Time( filePath ) >= startTime
            --         return filePath

            --     return AsyncWrite( filePath, content )

            @run: async ( url, env ) ->
                m = modules[ url.href ]
                unless m
                    m = Module( location, url, env )
                    await m\load!

                return m\run!

        loader.Module = Module

        environment.ismodule = ( any ) ->
            metatable = getmetatable( any )
            return metatable and metatable.__class == Module

    import getFileName, getExtension from path
    import STATE_REJECTED from Promise
    import rawset, tobool from _G
    import AsyncCompile from file
    import Merge from table
    import Logger from util

    default = environment.Color( 50, 100, 200 )\DoCorrection!
    environmentMetatable = { __index: environment }

    hooksMeta = {
        __index: ( tbl, key ) ->
            new = {}
            rawset( tbl, key, new )
            return new
    }

    parse = async ( filePath, gamePath, config ) ->
        compileResult = await AsyncCompile( filePath, {}, config, gamePath, true )
        -- await Module.cache( "file://" .. compileResult.path, compileResult.content )
        func = compileResult.func

        info = {}
        setfenv( func, info )
        success, result = pcall( func )
        if success
            if istable( result )
                Merge( info, result )

            if IsEmpty( info )
                error PackageError "file '#{filePath}' does not contain valid package info (empty or cannot be parsed)"
                return nil

            return Package( URL( AbsoluteGamePath( filePath, gamePath ), "file:///" ), info )

        error PackageError "package info '" .. filePath .. "' execution error: " .. result
        return nil

    emptyTable = {}

    class Package
        __tostring: =>
            return format( "Package: %p [%s@%s]", @, @name, @version )

        new: ( @url, info ) =>
            filePath = @file = url.pathname
            @directory = getDirectory( filePath, false )

            unless info
                info = emptyTable

            -- name
            :name = info
            unless isstring( name ) and match( name, "^[a-zA-Z_][%w ~<>_&+%-]*" )
                name = match( filePath, ".*packages/([^/]+)" ) or getFileName( filePath, false )

                if name == ""
                    error PackageError "invalid package name: '" .. name .. "'"

            @name = name

            -- version
            :version = info
            unless isstring( version )
                version = "0.1.0"

            version = Version( version )
            @version = version

            -- autorun
            @autorun = tobool( info.autorun )

            -- send
            if SERVER
                :send = info
                unless istable( send )
                    send = {}

                @send = send

            -- exports
            :exports = info
            if isstring( exports )
                exports = { [ "." ]: exports }
            elseif not istable( exports )
                exports = nil

            @exports = exports

            -- imports
            :imports = info
            if isstring( imports )
                imports = { [ "." ]: imports }
            elseif not istable( imports )
                imports = nil

            @imports = imports

            -- dependencies
            :dependencies = info
            unless istable( dependencies )
                dependencies = nil

            @dependencies = dependencies

            -- description
            :description = info
            unless isstring( description )
                description = "Description not provided"

            @description = description

            -- license
            :license = info
            unless isstring( license )
                license = "License not provided"

            @license = license

            -- homepage
            :homepage = info
            unless isstring( homepage )
                homepage = "Homepage not provided"

            @homepage = homepage

            -- logger
            :logger = info
            unless istable( logger )
                logger = {
                    interpolation: true
                    disabled: false
                    color: default
                }

            @logger = logger

            local packageLogger
            if logger
                if logger.disabled
                    packageLogger = nil
                else
                    packageLogger = Logger( name .. "@" .. version\__tostring!, logger.color, logger.interpolation )
            else
                packageLogger = Logger( name .. "@" .. version\__tostring! )

            @__hooks = setmetatable( {}, hooksMeta )
            @__prefix = @__tostring! .. "::"
            @__timers = {}

            -- package environment
            @env = setmetatable( { __package: @, Logger: packageLogger }, environmentMetatable )

        -- directly reads package info from given filePath and creates Package
        -- do not use this method directly, use Package.read instead
        @parse: parse

        -- Finds a package info in given url.
        -- If package.* file was not given in path, tries to find it.
        -- Also caches the package by URL.
        @read: async ( url ) ->
            if isstring( url )
                url = URL( url )

            unless isurl( url )
                error PackageError "invalid url '" .. url.href .. "'"

            if url.scheme ~= "file"
                -- error PackageError "unsupported scheme '" .. url.scheme .. "' ('" .. url.href .. "')"
                return nil

            unless istable( url.path )
                -- error PackageError "invalid path '" .. url.pathname .. "' ('" .. url.href .. "')"
                return nil

            cached = packages[ url.href ]
            if cached
                if cached.state ~= STATE_REJECTED
                    return cached

                -- clear cache if parsing failed
                packages[ url.href ] = nil

            filePath, gamePath = NormalizeGamePath( url.pathname )
            fileDir = getDirectory( filePath, true )

            -- if not package.* file was given in url, try to find it smartly
            if getFileName( filePath, false ) ~= "package"
                files = Find( fileDir .. "/package.*", gamePath, true )
                if #files == 1
                    filePath = fileDir .. files[ 1 ]

                elseif #files > 1
                    -- Smartly decide which file to use
                    values = {} -- [ext] = filePath
                    for fileName in *files
                        values[ getExtension( fileName, false ) ] = fileName

                    filePath = fileDir .. values.yue or values.moon or values.lua or values[ 1 ]

            unless IsFile( filePath, gamePath, true )
                -- error PackageError "file '" .. filePath .. "' does not exist for packageURL '" .. url.href .. "'"
                return nil

            config = {}
            for key, value in url.searchParams\iterator!
                config[ key ] = value

            -- also cache result so next calls will return current package
            promise = parse( filePath, gamePath, config )
            packages[ url.href ] = promise
            return promise

    environment.ispackage = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Package

-- TODO: after this works as specs intended, optimize it and make better!
local ESM
do

    import canParse from URL
    import IsDir from file

    class ESM
        DEFAULT_CONDITIONS = {
            [SERVER and "server" or CLIENT and "client" or MENU_DLL and "menu" or "default"]: true,
        }

        -- Just a shortcut so `ESM.resolve ...` can be used instead of creating a new instance.
        @resolve: ( ... ) -> ESM!\resolve( ... )

        -- ESM_RESOLVE(specifier, parentURL)
        resolve: async ( specifier, parentURL ) =>
            @specifier = specifier
            @parentURL = parentURL

            local resolved

            -- resolve
            if isurl( specifier ) or canParse( specifier )
                resolved = URL( specifier )
            elseif StartsWith( specifier, "/" ) or StartsWith( specifier, "./" ) or StartsWith( specifier, "../" )
                resolved = URL( specifier, parentURL )
            elseif StartsWith( specifier, "#" )
                resolved = packageImportsResolve( @, specifier, parentURL )
            else
                -- specifier is now a bare specifier
                resolved = packageResolve( @, specifier, parentURL )

            return { :resolved, package: @pjson }

        -- PACKAGE_RESOLVE(packageSpecifier, parentURL)
        packageResolve = ( packageSpecifier, parentURL ) =>
            local packageName
            if packageSpecifier == ""
                error PackageError "specifier is an empty string"

            -- If packageSpecifier is a Node.js builtin module name, then
            -- 1. Return the string "node:" concatenated with packageSpecifier.

            if not StartsWith( packageSpecifier, "@" )
                packageName = match( packageSpecifier, "(.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the first "/" separator or the end of the string.
            else
                packageName = match( packageSpecifier, "(.-/.-)/" ) or packageSpecifier -- Set packageName to the substring of packageSpecifier until the second "/" separator or the end of the string.
                if not packageName -- If packageSpecifier does not contain a "/" separator, then
                    error PackageError "invalid specifier '#{packageSpecifier}'"

            if StartsWith( packageSpecifier, "." ) or find( packageSpecifier, "%", 1, true ) or find( packageSpecifier, "\\", 1, true )
                error PackageError "invalid specifier '#{packageSpecifier}'"

            packageSubpath = "." .. sub( packageSpecifier, #packageName + 1 )

            if selfURL := packageSelfResolve( @, packageName, packageSubpath, parentURL )
                return selfURL

            local packageURL
            while not packageURL or packageURL.path[1] ~= "packages" -- While parentURL is not the file system root
                firstTime = not packageURL

                packageURL = URL( "packages/" .. packageName .. "/", parentURL ) -- Let packageURL be the URL resolution of "node_modules/" concatenated with packageSpecifier, relative to parentURL.
                parentURL = URL( "..", parentURL ) -- Set parentURL to the parent folder URL of parentURL.

                if packageURL.scheme == "file" and not IsDir( packageURL.pathname ) -- If the folder at packageURL does not exist, then
                    if result := firstTime and packageDependenciesResolve( @, packageName, packageSubpath )
                        return result

                    continue

                pjson = @pjson = await Package.read( packageURL )
                if pjson and pjson.exports
                    return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

                return URL( packageSubpath, packageURL )

            error PackageError "package not found: '#{packageSpecifier}' from '#{@parentURL}'"
            return

        -- PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL)
        packageSelfResolve = ( packageName, packageSubpath, parentURL ) =>
            packageURL = lookupPackageScope( @, parentURL )
            if not packageURL
                return

            pjson = @pjson = await Package.read( packageURL )
            if not pjson or not pjson.exports
                return

            if pjson.name == packageName
                return packageExportsResolve( @, packageURL, packageSubpath, pjson.exports )

        packageDependenciesResolve = ( packageName, packageSubpath ) =>
            -- @pjson must be set by packageSelfResolve
            pjson = @pjson
            if not pjson or not istable(pjson.dependencies)
                return

            target = pjson.dependencies[ packageName ]
            if isstring( target )
                return packageDependencyResolve( @, packageName, target, packageSubpath )

        packageDependencyResolve = ( name, target, subpath ) =>
            if not target
                error PackageError "invalid dependency target '#{target}' for '#{name}'"

            -- Retrieving all version of the package
            _, folders = Find( "gpm/vfs/packages/" .. name .. "/*", file.LuaPath, true ) -- lets hope that package installer will create correct versions of the package
            version = Version.select( target, folders )
            unless version
                versions_str = table.concat( folders, ", " )
                error PackageError "could not find installed #{name} with version selector #{target} (available versions: [#{versions_str}])"

            packageURL = URL( "file:///lua/gpm/vfs/packages/" .. name .. "/" .. tostring(version) .. "/" )
            unless IsDir( packageURL.pathname )
                error PackageError "#{packagePath} should exists but it does not :? (#{name} with target #{target})"

            psjon = @pjson = await Package.read( packageURL )
            if pjson and pjson.exports
                return packageExportsResolve( @, packageURL, subpath, pjson.exports )

            return URL( packageSubpath, packageURL )

        exportsStartsWithDot = ( exports, packageURL ) =>
            if istable( exports )
                local state
                for k in pairs( exports )
                    statsWithDot = StartsWith( k, "." )
                    if state == nil
                        state = statsWithDot
                    elseif state ~= statsWithDot
                        error PackageError "'#{packageURL}' exports are invalid"
                return state
            -- otherwise exports must be a string
            return StartsWith( exports, "." )

        -- PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)
        packageExportsResolve = ( packageURL, subpath, exports ) =>
            startsWithDot = exportsStartsWithDot( @, exports, packageURL )

            if subpath == "."
                local mainExport
                if isstring( exports ) or not startsWithDot
                    mainExport = exports
                elseif istable( exports ) and startsWithDot
                    mainExport = exports["."]

                if mainExport
                    if resolved := packageTargetResolve( @, packageURL, mainExport, nil, false )
                        return resolved
            elseif istable( exports ) and startsWithDot
                if resolved := packageImportsExportsResolve( @, subpath, exports, packageURL, false )
                    return resolved

            error PackageError "no exports found for '#{subpath}' in '#{packageURL}'"
            return

        -- PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)
        packageImportsResolve = ( specifier, parentURL ) =>
            if specifier == "#" or StartsWith( specifier, "#/" )
                error PackageError "invalid import specifier '" .. specifier .. "'"

            packageURL = lookupPackageScope( @, parentURL )
            if packageURL
                pjson = @pjson = await Package.read( packageURL )
                if pjson and pjson.imports
                    if resolved := packageImportsExportsResolve( @, specifier, pjson.imports, packageURL, true )
                        return resolved

            error PackageError "imports are not defined for '" .. specifier .. "' in #{packageURL or parentURL}"
            return

        -- PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports)
        packageImportsExportsResolve = ( matchKey, matchObj, packageURL, isImports ) =>
            if matchObj[matchKey] and not find( matchKey, "*", 1, true )
                target = matchObj[matchKey]
                return packageTargetResolve( @, packageURL, target, nil, isImports )

            -- TODO: Implement pattern matching
            error PackageError "pattern matching is not implemented"
            return

        -- PACKAGE_TARGET_RESOLVE(packageURL, target, patternMatch, isImports, conditions)
        packageTargetResolve = ( packageURL, target, patternMatch, isImports ) =>
            if isstring( target )
                unless StartsWith( target, "./" )
                    if isImports == false or StartsWith( target, "/" ) or StartsWith( target, "../" ) or canParse( target )
                        error PackageError "invalid target '#{target}' for '#{packageURL}'"
                        return nil

                    if isstring( patternMatch )
                        return packageResolve( @, gsub( target, "*", patternMatch ), packageURL )

                    return packageResolve( @, target, packageURL )

                -- TODO: If target split on "/" or "\" contains any "", ".", "..", or "node_modules" segments after the first "." segment, case insensitive and including percent encoded variants, throw an Invalid Package Target error.

                resolvedTarget = URL( target, packageURL )
                if patternMatch == nil
                    return resolvedTarget

                -- TODO: If patternMatch split on "/" or "\" contains any "", ".", "..", or "node_modules" segments, case insensitive and including percent encoded variants, throw an Invalid Module Specifier error.
                resolvedTarget.pathname = gsub( resolvedTarget.pathname, "*", patternMatch )
                return resolvedTarget

            if istable( target )
                if #target == 0 -- object
                    local defaultValue
                    for p, targetValue in pairs( target )
                        if DEFAULT_CONDITIONS[ p ]
                            if resolved := packageTargetResolve( @, packageURL, targetValue, patternMatch, isImports )
                                return resolved

                        elseif p == "default"
                            defaultValue = targetValue

                    -- resolving "default" at the end because tables in lua are unordered
                    if defaultValue
                        return packageTargetResolve( @, packageURL, defaultValue, patternMatch, isImports )

                    return nil

                -- array
                local success, resolved
                for targetValue in *target
                    success, resolved = pcall( packageTargetResolve, @, packageURL, targetValue, patternMatch, isImports )
                    if success and resolved
                        return resolved

                unless success
                    error resolved
                    return nil

                return nil

            if target == nil
                return nil

            error PackageError "invalid target '#{target}' for '#{packageURL}'"
            return nil

        -- LOOKUP_PACKAGE_SCOPE(url)
        lookupPackageScope = ( url ) =>
            if url.scheme ~= "file"
                error PackageError "unable to lookup package scope for '#{url}' (not a file:/// URL)"

            local scopeURL = URL( "./package.lua", url )
            while scopeURL.path[1] ~= "package.lua" -- not filesystem root
                if scopeURL.path[ #scopeURL.path - 1 ] == "packages"
                    return nil

                if IsFile( scopeURL.pathname )
                    return URL( "./", scopeURL )

                scopeURL = URL( "../package.lua", scopeURL )

    loader.ESM = ESM

local Require
do

    import NotImplementedError from environment
    import IsBinaryModuleInstalled from util

    PACKAGE_PATHS = { "./?.lua", "./?/init.lua" }

    isRequireSyntax = ( modname ) ->
        return match( modname, "^[%a%d_%-.]+$" )

    resolveFile = ( filePath, base ) =>
        for pattern in *PACKAGE_PATHS
            url = URL( gsub( pattern, "%?", filePath ), base )
            if IsFile( url.pathname )
                return url

        return nil

    class Require
        -- Just a shortcut so `Require.resolve ...` can be used instead of creating a new instance.
        @resolve: ( ... ) -> Require!\resolve( ... )

        resolve: async ( modname, base ) =>
            unless base
                error ModuleError "`require` cannot be used outside of modules"

            if base.scheme ~= "file"
                error NotImplementedError "cannot use `require` from `#{base}`"

            isOpaque = isRequireSyntax( modname )
            filePath = gsub( modname, "%.", "/" )

            if resolved := isOpaque and resolveFile( @, filePath, base )
                return { :resolved }

            if StartsWith( filePath, "gpm/" ) or StartsWith( filePath, "gmod/" )
                protocol, filePath = match( filePath, "^(.-)/(.*)" )
                filePath = URL( protocol .. ":///" .. filePath ).href

            if filePath == "gpm" or filePath == "gmod"
                filePath ..= ":///"

            success, resolved = try await ESM.resolve( isOpaque and filePath or modname, base )
            if success
                return resolved

            if IsBinaryModuleInstalled( modname )
                return { resolved: URL( "dll:" .. modname ) }

            -- TODO: make better errors
            error resolved -- just return error from ESM
            return

    loader.Require = Require

class Include
    -- Just a shortcut so `Include.resolve ...` can be used instead of creating a new instance.
    @resolve: ( ... ) -> Include!\resolve( ... )

    resolve: async ( fileName, base ) =>
        if base and base.scheme == "file"
            resolved = URL( fileName, base )
            if resolved.path[ 1 ] == "lua" and IsFile( resolved.pathname )
                return { :resolved }

        resolved = URL( fileName, "file:///lua/" )
        if resolved.path[ 1 ] == "lua" and IsFile( resolved.pathname )
            return { :resolved }

        return ESM.resolve( fileName, base )

loader.Include = Include

local findSource
do

    import SourceError from environment
    import reject from Promise

    sources = loader.Sources
    unless istable( sources )
        sources = loader.Sources = {}

    findSource = loader.FindSource = ( scheme ) ->
        source = sources[ scheme ]
        if source
            return source

        error SourceError "Source for scheme '#{scheme}' not implemented."
        return

    registerSource = loader.RegisterSource = ( scheme, source ) ->
        sources[ scheme ] = source

    class loader.BaseSourceHandler
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source handler", @ )

        FetchInfo: ( url, base ) =>
            return nil

        Install: ( url, info ) =>
            return nil

        Run: ( url, info, env, parent ) =>
            return nil

    class loader.BaseSource
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source", @ )

        new: ( ... ) =>
            @handlers = {}

            for scheme in *{ ... }
                registerSource( scheme, @ )

        RegisterHandler: ( handler ) =>
            @handlers[] = handler

        CallHandler: ( name, url, ... ) =>
            for handler in *@handlers
                if not handler.ShouldHandle or handler\ShouldHandle( url, ... )
                    return handler[ name ]( handler, url, ... )

            return reject SourceError "No handler found for URL '#{url}' (" .. name .. ")"

        FetchInfo: ( url, base ) =>
            return @CallHandler( "FetchInfo", url, base )

        Install: ( url, info ) =>
            return @CallHandler( "Install", url, info )

        Run: ( url, info, env, parent ) =>
            return @CallHandler( "Run", url, info, env, parent )

    class loader.Source
        __tostring: =>
            return format( "%s %p", @__name, @ )

        new: ( ... ) =>
            for protocol in *{ ... }
                if isurl( protocol )
                    protocol = protocol.scheme

                old = sources[ protocol ]
                if old
                    Logger\Warn( "Protocol '#{old}' has been overwritten by '#{protocol}'." )

                sources[ protocol ] = @
                Logger\Debug( "  - #{@} was registered for #{protocol}:"  )

        @get: ( protocol ) ->
            if isurl( protocol )
                protocol = protocol.scheme

            return sources[ protocol ]

        --[[

            -- Sources API

            WebSource: "http", "https"
            http://dom.com/path/to/

            isPackage = path.GetFile( pathname ) == ""
            url.path[#url.path] == "" -- is directory

            -- GetWorkingDirectory( url: URL ) => URL file:/// *SHARED
            -- FetchInfo { package: Package, metadata: {...} } *SERVER
            -- Install *SERVER

            pkg = Package( ... )
            files = {...}

            data/gpm/vfs/packages/package1/0.1.0/package.lua

            data/gpm/vfs/packages/package1/0.1.0/package.lua -- server
            lua/gpm/vfs/packages/package1/0.1.0/package.lua -- client

            client:
            server:
            menu:

            gpm/vfs/modules/github/ukgamer/gpm/path/to/file.lua
            gpm/vfs/modules/com/github/ukgamer/gpm/ .. package.lua

            gpm/vfs/modules/com/github/ukgamer/gpm/ => {
                folder/file.lua
                package.lua
                init.lua
            }

            -- packages/units/package.lua
            dependencies = {
                ["ukgamer"] = "github:ukgamer/gpm/main/lua/package/package1", -- packages/units/packages/ukgamer
                package1: "^1.0.0" 1.2.3 1.2.0 1.4.0
            }

            packages/pkg1/packages/units@1.0.1
            -- packages/pkg2/packages/units@2.0.3
            -- packages/pkg3/packages/units@2.0.3 2.0.4
            packages/pkg4/packages/units@1.0.1
            packages/units@2.0.3

            gpm.Import "ukgamer" -> gpm/vfs/github/ukgamer/gpm/path/to/file.lua
        ]]

    parseFileURL = loader.ParseFileURL = ( any ) ->
        if isurl( any )
            return any

        if isstring( any ) and IsURL( any )
            return URL( any )

    getFileURL = loader.GetFileURL = ( any ) ->
        url = parseFileURL( any )
        unless url
            error SourceError "Invalid URL: #{any}"
            return nil

        unless url.scheme
            error SourceError "Invalid protocol for URL: #{any}"
            return nil

        return url

    loader.FetchInfo = async ( url, base, env, parent ) ->
        url = getFileURL( url )
        return findSource( url.scheme )\FetchInfo( url, base, env, parent )

    asyncImport = loader.AsyncImport = async ( specifier, resolver, info, base = URL( "file:///lua/" ), env, parent ) ->
        :resolved, :package = await resolver( specifier, base )

        -- if package was found, then it must overwrite current env
        if package
            env = package.env or env

        print("asyncImport", package, env, resolved) -- location, url, env
        return Module.run( resolved, package, env )

        -- source = findSource( resolved.scheme )
        -- info or= await source\FetchInfo( resolved, base )
        -- info = await source\Install( resolved, info )
        -- return source\Run( resolved, info, env, parent )

    local getImportMeta
    do

        import getfenv, rawget from _G
        import getfmain from debug

        getModule = loader.GetModule = ( func = getfmain! ) ->
            if fenv := func and getfenv( func )
                return rawget( fenv, "__module" )

        getURL = loader.GetURL = ( func = getfmain! ) ->
            if fpath := func and getfpath( func )
                if fenv := getfenv( func )
                    if m := rawget( fenv, "__module" )
                        if url := m.url
                            return url

                if IsURL( fpath )
                    return URL( fpath )

                return URL( "file:///" .. fpath )

        getParentURL = loader.GetParentURL = ( m = getModule! ) ->
            return m and m.url or nil

        getEnvironment = loader.GetEnvironment = ( m = getModule! ) ->
            return m and m.env or nil

        getPackage = loader.GetPackage = ( env = getEnvironment! ) ->
            return env and env.__package or nil

        getImportMeta = loader.GetImportMeta = ->
            local base, parent, env
            if fmain := getfmain!
                if m := getModule( fmain )
                    base = getParentURL( m )
                    env = getEnvironment( m )
                    parent = getPackage( env )

                base or= getURL( fmain )

            return base, env, parent

    gpm.Import = ( specifier ) ->
        ArgAssert( specifier, 1, "string" )
        return asyncImport( specifier, ESM.resolve, nil, getImportMeta! )

    -- just for a .lua users
    environment.import = ( specifier ) ->
        ArgAssert( specifier, 1, "string" )
        return await asyncImport( specifier, ESM.resolve, nil, getImportMeta! )

    environment.require = ( modname ) ->
        ArgAssert( modname, 1, "string" )
        return await asyncImport( modname, Require.resolve, nil, getImportMeta! )

    environment.include = environment.dofile = ( fileName ) ->
        ArgAssert( fileName, 1, "string" )
        return await asyncImport( fileName, Include.resolve, nil, getImportMeta! )

-- packages autorun
do

    import display from environment.Error
    import allSettled from Promise
    import concat from table
    import Logger from gpm

    loader.Startup = async ->
        _, folders = Find( "packages/*", file.LuaPath, true )
        Logger\Info( "Parsing `packages/` directory..." )
        base = URL( "file:///lua/packages/" )

        readTasks, taskCount = {}, 0
        for folderName in *folders
            taskCount += 1
            readTasks[ taskCount ] = Package.read( URL( folderName .. "/", base ) ) -- TODO: addcsluafile

        -- no :>
        pkgs, pkgCount = {}, 0

        for result in *await( allSettled( readTasks ) )
            if result.value
                pkgCount += 1
                pkgs[ pkgCount ] = result.value

            elseif result.status == "rejected"
                display( result.reason )

        -- TODO: Resolve dependencies
        -- ukdev: I think we need make dependencies resolving in package loading process, because dependencies also can have their dependencies
        -- retr0: Proper way to do this is to create dedicated function ReasolveDependencies, which can recursevly resolve dependencies
        -- retr0: I will implement this, no problem
        -- gLua Package Manager or GLua Package Manager? :D
        -- gpm GPM :>

        if pkgCount == 0
            Logger\Info( "No packages found :<" )
            return nil

        -- Package structure logging
        Logger\Info( "Directory 'packages/' have in total %d packages", pkgCount )

        importTasks, taskCount = {}, 0

        for index = 1, pkgCount
            pkg = pkgs[ index ]

            flags, count = {}, 0
            if pkg.autorun
                count += 1
                flags[ count ] = "autorun"

                taskCount += 1
                importTasks[ taskCount ] = pkg

            if count == 0
                Logger\Info( "    - %s [%s]", pkg.name, pkg.version )
            else
                Logger\Info( "    - %s [%s] (%s)", pkg.name, pkg.version, concat( flags, ", ", 1, count ) )

            -- print dependencies

        -- Autorun packages
        if taskCount == 0
            Logger\Info( "No packages to execute :<" )
            return nil

        Logger\Info( "Executing %d autorun packages...", taskCount )

        for index = 1, taskCount
            pkg = importTasks[ index ]
            importTasks[ index ] = loader.AsyncImport( pkg.name, ESM.resolve, nil, pkg.url, pkg.env )

        -- Handle all failed startups
        for result in *await( allSettled( importTasks ) )
            if result.status == "rejected"
                display( result.reason )
