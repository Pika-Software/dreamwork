_G = _G
import gpm from _G
import environment from gpm
import string, file, isurl, isstring, rawget, getfenv, URL from environment
import async, await, reject from environment.Promise
import getfmain, getfpathi from environment.debug
import NotImplementedError from environment
-- import Fetch from environment.http

-- class ModuleURLResolutionError extends environment.Error
-- environment.ModuleURLResolutionError = ModuleURLResolutionError

-- class InvalidModuleSpecifierError extends environment.Error
-- environment.InvalidModuleSpecifierError = InvalidModuleSpecifierError

class ModuleLoadError extends environment.Error
environment.ModuleLoadError = ModuleLoadError

-- class ModuleNotFoundError extends environment.Error
-- environment.ModuleNotFoundError = ModuleNotFoundError

class SourceError extends environment.Error
environment.SourceError = SourceError

:loader = gpm
unless istable( loader )
    loader = gpm.loader = {}

do

    import format, IsURL from string

    --[[

        file:///lua/path/to/file.lua
        lua:///path/to/file.lua

        Sources: {
            file: Source Obj1
            game: Source Obj1
            data: Source Obj1
            lua: Source Obj1
            http: Source Obj2
            https: Source Obj2
        }

    ]]

    sources = loader.Sources
    unless istable( sources )
        sources = loader.Sources = {}

    findSource = loader.FindSource = ( scheme ) ->
        source = sources[ scheme ]
        if source
            return source

        error SourceError "Source for scheme '#{scheme}' not implemented."
        return

    registerSource = loader.RegisterSource = ( scheme, source ) ->
        sources[ scheme ] = source

    defaultFetchInfo = async ( url, parent_url, parent_pkg, parent_env ) =>
        error NotImplementedError "Source:FetchInfo( url, parent_url, parent_pkg, parent_env )"
        return

    class loader.BaseSourceHandler
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source handler", @ )

        FetchInfo: defaultFetchInfo

        Install: async ( url, info, parent_url, parent_pkg, parent_env ) =>
            error NotImplementedError "Source:Install( url, info, parent_url, parent_pkg, parent_env )"
            return

    class loader.BaseSource
        __tostring: =>
            return format( "%s: %p", @@__name or "unknown source", @ )

        new: ( ... ) =>
            @handlers = {}

            for scheme in *{ ... }
                registerSource( scheme, @ )

        RegisterHandler: ( handler ) =>
            @handlers[] = handler

        CallHandler: ( name, url, ... ) =>
            for handler in *@handlers
                if not handler.ShouldHandle or handler\ShouldHandle( url, ... )
                    return handler[ name ]( handler, url, ... )

            return reject SourceError "No handler found for URL '#{url}' (" .. name .. ")"

        FetchInfo: ( url, parent_url, parent_pkg, parent_env ) =>
            return @CallHandler( "FetchInfo", url, parent_url, parent_pkg, parent_env )

        Install: ( url, info, parent_url, parent_pkg, parent_env ) =>
            return @CallHandler( "Install", url, info, parent_url, parent_pkg, parent_env )

    parseFileURL = loader.ParseFileURL = ( any ) ->
        if isurl( any )
            return any

        if isstring( any ) and IsURL( any )
            return URL( any )

    getFileURL = loader.GetFileURL = ( any ) ->
        url = parseFileURL( any )
        unless url
            error SourceError "Invalid URL: #{any}"

        unless url.scheme
            error SourceError "Invalid protocol for URL: #{any}"

        return url

    loader.FetchInfo = async ( url, ... ) ->
        url = getFileURL( url )

        source = findSource( url.scheme )
        if source.FetchInfo ~= defaultFetchInfo
            return source\FetchInfo( url, ... )

    asyncImport = loader.AsyncImport = async ( url, base = "file:///lua/", parent, env, info ) ->
        url = getFileURL( URL( url, base ) )
        source = findSource( url.scheme )

        if not info and source.FetchInfo ~= defaultFetchInfo
            info = await source\FetchInfo( url, base, parent, env )

        return source\Install( url, info, base, parent, env )

    loader.GetModule = ->
        if func := getfmain!
            if fenv := getfenv( func )
                return rawget( fenv, "__module" )

    loader.GetURL = ->
        if func := getfmain!
            if folderPath := getfpathi( func )
                return URL( "file:" .. folderPath )

    loader.GetFolder = ->
        if func := getfmain!
            if folderPath := getfpathi( func )
                return getDirectory( folderPath )

    loader.GetPackage = ->
        if func := getfmain!
            if fenv := getfenv( func )
                return fenv.__package

    loader.GetEnvironment = ->
        if func := getfmain!
            if fenv := getfenv( func )
                if mdl := rawget( fenv, "__module" )
                    return mdl.env

    gpm.Import = ( url, should_await ) ->
        local base, parent, env
        if func := getfmain!
            if fenv := getfenv( func )
                mdl = rawget( fenv, "__module" )
                if mdl
                    base, env = mdl.url, mdl.env
                    if env
                        parent = env.__package

            unless base
                if folderPath := getfpathi( func )
                    base = URL( "file:" .. folderPath )

        result = asyncImport( url, base, parent, env, nil )
        if should_await ~= false
            return await( result )

        return result

    -- TODO: Temporary solution
    environment.require = gpm.Import

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
loader.PackageResolve = async ( specifier, parentURL, parentPackage ) ->
    local packageName
    if specifier == ""
        error InvalidModuleSpecifierError specifier

    if string.StartsWith( specifier, "@" )
        unless match( specifier, "/" ) -- check if specifier even has /
            error InvalidModuleSpecifierError specifier

        packageName = match( specifier, "(@[^/]*/[^/]*)" )
    else
        packageName = match( specifier, "([^/]*)" )

    if sub( packageName, 1, 1 ) == "." or match( packageName, "[\\%%]" )
        error InvalidModuleSpecifierError specifier

    packageSubPath = "." .. sub( specifier, len( packageName ) + 1 )
    if sub( packageSubPath, -1 ) == "/"
        error InvalidModuleSpecifierError specifier

    -- TODO make PACKAGE_SELF_RESOLVE
    -- if specifier := packageSelfResolve packageName, packageSubPath, parentURL
    --     return specifier

    parentPath = URL.parse( parentURL )\getPath!
    if parentPath == ""
        parentPath = "./"

    packagePath = resolvePackagePath( parentPath, specifier )
    if packagePath
        pkg = await gpm.ParsePackage( path.Join( packagePath, "package.lua" ) ) -- TODO: lookup package in global table

        -- TODO: If pmeta is not null and pmeta.exports is not null or undefined, then
        -- Return the result of PACKAGE_EXPORTS_RESOLVE(packagePath, packageSubpath, pjson.exports, defaultConditions).
        urlStr = "lua:" .. path.Join( pkg.dir, pkg.entry )

        if packageSubPath ~= "." or pkg.entry
            if parentPackage
                return loader.LoadURL( urlStr, parentPackage )

            return pkg\LoadURL( urlStr )

    error ModuleNotFoundError specifier
    return

-- Simplest vanilla lua `require` implementation
-- Not uses package or any other fancy stuff
-- package.path is hardcoded into it :p
do

    templates = {
        ".lua"
        "/init.lua"
    }

    length = #templates

    if CLIENT
        length += 1
        templates[ length ] = "/cl_init.lua"

    length += 1
    templates[ length ] = "/shared.lua"

    loader.RequireResolve = async ( specifier, parentURL, parentPackage ) ->
        specifier = gsub( specifier, "%.", "/" )
        url = URL.parse( parentURL )

        for index = 1, length
            success, entry = saveAwait loader.LoadURL( url\resolve( specifier .. templates[ index ] ), parentPackage )
            if success and entry
                return entry

-- Simple URL resolver based on https://nodejs.org/api/esm.html#resolution-algorithm-specification
-- without packageResolve since it is more advanced and not needed for now
loader.ResolveURL = ( specifier, parentURL ) ->
    url = URL.parse( specifier )
    if url.scheme
        return url\format!

    -- parent-url: lua:/example/foo.lua
    -- url: ../config.lua
    -- result: lua:/config.lua
    if find( url.pathname, "%.?%.?/", 1, false )
        -- If specifier is relative path then resolve it against parentURL
        return URL.resolve( parentURL, url.pathname )\format!

-- Resolves specifier and returns a promise with entry function
loader.Resolve = async ( specifier, parentURL = "lua:", parentPackage ) ->
    -- First lets try to resolve as URL
    resolved = loader.ResolveURL( specifier, parentURL )
    if resolved
        return loader.LoadURL( resolved, parentPackage )

    -- Try to resolve as vanilla `require`
    entry = await loader.RequireResolve( specifier, parentURL, parentPackage )
    if entry
        return entry

    -- Try to resolve as package
    return loader.PackageResolve( specifier, parentURL, parentPackage )

-- loader.AsyncImport = async ( specifier, parentURL, parentPackage ) ->
--     entry_fn = await loader.Resolve( specifier, parentURL, parentPackage )
--     entry_fn = async entry_fn -- convert entry to async function
--     return entry_fn!

--]]

-- loader.GetParentURL = ->
--     if func := getfmain!
--         -- Get URL from func env
--         env = getfenv( func )
--         if value := env and rawget( env, "_URL" )
--             return value

--         -- Try to resolve URL from func source
--         if folderPath := getfpathi( func )
--             url = parse( folderPath )
--             url.protocol or= "lua"
--             return url.href

--     return "lua:" -- default fallback

-- loader.GetPackage = ->
--     if func := getfmain!
--         env = getfenv( func )
--         return env and rawget( env, "_PKG" )

-- loader.GetEnvironment = ->
--     if func := getfmain!
--         env = getfenv( func )
--         return env and rawget( env, "_ENV" )

gpm.Import = ( url, should_await ) ->
    local env, pkg, base
    if func := getfmain!
        if fenv := getfenv( func )
            mdl = rawget( fenv, "__module" )
            if mdl
                env, base = mdl.env, mdl.url
                pkg = env.__package

        unless base
            if folderPath := getfpathi( func )
                url = parse( folderPath )
                url.protocol or= "lua"
                base = url.href

    result = asyncImport( url, base, pkg, env, nil )
    if should_await ~= false
        return await( result )

    return result

environment.require = gpm.Import
