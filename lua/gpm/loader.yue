import URL, Promise, Error, path, string, debug, file from gpm
import async, await from Promise

gpm.loader or= {}

class ModuleURLResolutionError extends Error
gpm.ModuleURLResolutionError = ModuleURLResolutionError

class InvalidModuleSpecifierError extends Error
gpm.InvalidModuleSpecifierError = InvalidModuleSpecifierError

class ModuleLoadError extends Error
gpm.ModuleLoadError = ModuleLoadError

class ModuleNotFoundError extends Error
gpm.ModuleNotFoundError = ModuleNotFoundError

--[[

    tasks = {}
    for package in packages
        tasks[] = asyncImport package, parent_url

    for task in tasks
        task\Catch (err) ->
            print err

    PKG.name
    PKG.metadata.name
    PKG.env == getfenv(1)
    PARENT_URL

    PKG == gpm.Package!

    PKG.Tasks = {
        metadata: Promise 1
        download: Primise 2
    }

    Packages = { }

    -- package://PackageA/module1 -> lua://packages/PackageA/module1/package.lua
    -- lua://niknaks/package.lua

    lua://my_package/init.lua   - single file package
    lua://my_package            - multi file package ( package.lua and other files )

    NewPackage = ( url ) ->
        -- example1: url = "package://PackageA"
        -- example1: url = "lua://my_package"
        url = resolveURL( url )

        -- example1: url = "lua://packages/PackageA"
        -- example2: url = "lua://my_package"

        package = Packages[ url ]
        unless package
            package = gpm.Package( url )
            Packages[ url ] = package

        return package

    Package A:
        Code:
            ents.MyFunc = ->
                print( "FUnc!" )

            print COLLISION_GROUP_CUSTOM

        Depends:
            Package B:
                Globals:
                    markers = {}

    Package C:
        Code:
            print COLLISION_GROUP_CUSTOM
            ents.MyFunc!

        Depends:
            Package D:
                Globals:
                    markers = {}

            Package B:

    Output:
            FUnc!
            1
            2

]]

-- Simple module loader that takes url and tries to get module entry
gpm.loader.LoadURL = async ( urlStr, parent_package ) ->
    url = URL( urlStr )

    local entry_fn
    if url.scheme == "lua"
        entry_fn = await file.Compile( url.pathname, "LUA" )
        unless entry_fn
            error ModuleLoadError "failed to compile file #{url.pathname}"

    elseif url.scheme == "http" or url.scheme == "https"
        ext = string.GetExtensionFromFilename url.pathname
        if ext ~= "lua"
            error ModuleLoadError "unsupported web url: " .. url.href

        req = await gpm.http.Fetch( url.href )
        unless req and req.code == 200 and req.body
            error ModuleLoadError "failed to fetch " .. url.href

        entry_fn = CompileString req.body, url.href
        unless entry_fn
            error ModuleLoadError "failed to compile file " .. url.href

    else
        error ModuleLoadError "unsupported url: " .. url.href

    genv = parent_package and parent_package.env or gpm.Package.CreateEnvironment!
    env = setmetatable {
        PKG: parent_package
        URL: url.href
    }, { __index: genv, __newindex: genv }

    return setfenv entry_fn, env

-- Simple URL resolver based on https://nodejs.org/api/esm.html#resolution-algorithm-specification
-- without packageResolve since it is more advanced and not needed for now
gpm.loader.ResolveURL = ( specifier, parent_url ) ->
    url = URL( specifier )
    if #url.scheme ~= 0
        return url.href

    -- parent-url: lua:/example/foo.lua
    -- url: ../config.lua
    -- result: lua:/config.lua
    if string.StartsWith(url.pathname, "./") or string.StartsWith(url.pathname, "../") or string.StartsWith(url.pathname, "/")
        -- If specifier is relative path then resolve it against parent_url
        return url\parse( parent_url, url.pathname ).href

-- Simplest vanilla lua `require` implementation
-- Not uses package or any other fancy stuff
-- package.path is hardcoded into it :p
gpm.loader.RequireResolve = async ( specifier, parent_url, parent_package ) ->
    specifier = string.gsub( specifier, "%.", "/" ) -- replace all dots with slashes
    url = URL( parent_url )

    -- yup, it is hard coded for now
    for template in string.gmatch( "?.lua;?/init.lua", "[^;]+" )
        success, entry = try await gpm.loader.LoadURL( url\parse( string.gsub( template, "?", specifier ) ), parent_package )
        if success and entry
            return entry

-- Resolves specifier as it is package specifier
-- See https://nodejs.org/api/esm.html#resolution-algorithm-specification PACKAGE_RESOLVE
gpm.loader.PackageResolve = async (specifier, parent_url, parent_package) ->
    print specifier, parent_url, parent_package

    --[[
        [ERROR] addons/glua-package-manager-v2/lua/gpm/loader.yue:13: InvalidModuleSpecifierError: ./submodule.lua
        1. unknown - addons/glua-package-manager-v2/lua/gpm/loader.yue:13
        2. xpcall - [C]:-1
        3. unknown - addons/glua-package-manager-v2/lua/gpm/libs/promise.yue:1

    ]]

    package_name = nil
    if url == ""
        error InvalidModuleSpecifierError specifier

    if string.StartsWith specifier, "@"
        unless string.match specifier, "/" -- check if specifier even has /
            error InvalidModuleSpecifierError specifier

        package_name = string.match specifier, "(@[^/]*/[^/]*)"
    else
        package_name = string.match specifier, "([^/]*)"

    if string.StartsWith(package_name, ".") or string.match(package_name, "[\\%%]")
        error InvalidModuleSpecifierError specifier

    package_subpath = "." .. string.sub(specifier, #package_name + 1)
    if string.EndsWith package_subpath, "/"
        error InvalidModuleSpecifierError specifier

    -- TODO make PACKAGE_SELF_RESOLVE
    -- if self_url := packageSelfResolve package_name, package_subpath, parent_url
    --     return self_url

    filePath = URL( parent_url ).pathname

    if filePath == ""
        filePath = "./"

    while filePath ~= ""
        filePath = string.sub( string.GetPathFromFilename( filePath ), 1, -2 )
        package_url = path.Resolve( filePath, "packages", specifier )
        unless file.Exists( package_url, "LUA" )
            continue

        pkg = gpm.ParsePackage( path.Join( package_url, "package.lua" ) ) -- TODO lookup package in global table

        -- TODO If pmeta is not null and pmeta.exports is not null or undefined, then
        -- Return the result of PACKAGE_EXPORTS_RESOLVE(packageURL, packageSubpath, pjson.exports, defaultConditions).
        if package_subpath == "."
            if pkg.entry
                return pkg\LoadURL "lua:" .. path.Join( pkg.dir, pkg.entry )

        else
            return pkg\LoadURL "lua:" .. path.Join( pkg.dir, pkg.entry )

    error ModuleNotFoundError specifier

-- Resolves specifier and returns a promise with entry function
gpm.loader.Resolve = async (specifier, parent_url = "lua:", parent_package) ->
    -- First lets try to resolve as URL
    resolved = gpm.loader.ResolveURL( specifier, parent_url )
    if resolved
        return gpm.loader.LoadURL resolved, parent_package

    -- Try to resolve as vanilla `require`
    entry = await gpm.loader.RequireResolve( specifier, parent_url, parent_package )
    if entry
        return entry

    -- Try to resolve as package
    return gpm.loader.PackageResolve( specifier, parent_url, parent_package )

gpm.loader.AsyncImport = async (specifier, parent_url, parent_package) ->
    entry_fn = await gpm.loader.Resolve specifier, parent_url, parent_package
    entry_fn = async entry_fn -- convert entry to async function
    return entry_fn!

gpm.loader.GetParentURL = ->
    if entry := debug.getfmain!
        -- Get URL from entry env
        entry_env = getfenv entry
        if value := entry_env and rawget entry_env, "URL"
            return value

        -- Try to resolve URL from entry source
        if current_dir := debug.getfpathi entry
            current_dir = gpm.url.parse current_dir
            current_dir.scheme or= "lua"
            return current_dir\build!

    return "lua:" -- default fallback

gpm.loader.GetPackage = ->
    if entry := debug.getfmain!
        entry_env = getfenv entry
        return entry_env and rawget entry_env, "PKG"

gpm.Import = (url, should_await = true) ->
    parent_url = gpm.loader.GetParentURL!
    parent_pkg = gpm.loader.GetPackage!
    result = gpm.loader.AsyncImport url, parent_url, parent_pkg

    if should_await
        return result\await!

    return result
