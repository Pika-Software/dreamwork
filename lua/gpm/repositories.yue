_G = _G
import gpm from _G
import Query from _G.sql
import environment from gpm
import istable, util, CLIENT, SERVER, MENU_DLL from environment
import JSONToTable, Version from util

if SERVER or MENU_DLL
    Query( "CREATE TABLE IF NOT EXISTS `gpm.table_version` ( Name TEXT PRIMARY KEY NOT NULL, Version INT )" )
    Query( "CREATE TABLE IF NOT EXISTS `gpm.repository` ( ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, URL TEXT UNIQUE NOT NULL )" )
    Query( "CREATE TABLE IF NOT EXISTS `gpm.packages` ( ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, Name TEXT NOT NULL, URL TEXT UNIQUE NOT NULL, Version TEXT NOT NULL, Installed BOOLEAN DEFAULT 0 NOT NULL, RepositoryID INTEGER DEFAULT 0 NOT NULL, FOREIGN KEY(RepositoryID) REFERENCES `gpm.repository` (ID) )" )

repositories = gpm.Repositories
unless istable( repositories )
    repositories = gpm.Repositories = {}

list = repositories.List
unless istable( list )
    if SERVER or MENU_DLL
        list = Query( "SELECT * FROM `gpm.repository`" ) or {}

        count = #list
        if count == 0
            Query( "INSERT INTO `gpm.repository` ( URL ) VALUES ( 'https://raw.githubusercontent.com/Pika-Software/gpm-repositories/main/main.json' )" )
            list = Query( "SELECT * FROM `gpm.repository`" ) or {}

        for index = 1, count
            repository = list[ index ]
            packages = Query( "SELECT * FROM `gpm.packages` WHERE RepositoryID = " .. repository.ID ) or {}

            for package in *packages
                package.Version = Version( package.Version )
                package.Installed = package.Installed == 1
                package.RepositoryID = repository
                package.RepositoryID = nil

            repository.Packages = packages

        repositories.List = list

    if SERVER
        environment.file.Set( "/lua/gpm/vfs/repositories.lua", "return '" .. util.TableToJSON( repositories, false ) .. "'", "GLua Package Manager::Repositories" )
        _G.AddCSLuaFile( "lua/gpm/vfs/repositories.lua" )

    if CLIENT
        list = JSONToTable( include( "gpm/vfs/repositories.lua" ) )
        repositories.List = list

import await, async, SafeAwait, AllSettled from environment.Promise
import IsURL, match, find from environment.string
import sort from environment.table
import URL, pairs from environment

local request
do

    import CachedFetch from environment.http

    local api_token
    if SERVER
        api_token = _G.CreateConVar( "gpm_github_token", "", _G.bit.bor( _G.FCVAR_ARCHIVE, _G.FCVAR_PROTECTED ), "https://github.com/settings/tokens" )

    request = ( href ) ->
        local headers
        if api_token
            token = api_token\GetString!
            if token and token ~= ""
                headers = { Authorization: "Bearer " .. token }

        return CachedFetch( href, headers )

apis = repositories.APIs
unless istable( apis )
    apis = repositories.APIs = {}

apis["github.com"] = ( url, name, parent ) ->
    if url.scheme ~= "https"
        return nil

    user, repository = match( url.pathname, "^/([^/]+)/([^/]+)/?$" )
    unless user and repository
        return nil

    name or= repository

    ok, response = SafeAwait( request( "https://api.github.com/repos/" .. user .. "/" .. repository .. "/tags" ) )
    if not ok or response.status ~= 200
        return nil

    tags = JSONToTable( response.body )
    unless tags
        return nil

    versions, length = {}, 0
    for tag in *tags
        length += 1
        versions[ length ] = {
            Name: name,
            Installed: false,
            Repository: parent,
            Version: Version( tag.name ),
            URL: tag.zipball_url
        }

    return versions

local fetchPackages
do

    import getExtension from environment.path
    import isstring from environment

    fetchPackages = repositories.FetchPackages = async ( url, name, parent ) ->
        if IsURL( url )
            if isstring( url )
                url = URL( url )

            fn = apis[ url.hostname ]
            if fn
                return fn( url, name, parent )

            if getExtension( url.pathname ) == "json"
                ok, response = SafeAwait( request( url.href ) )
                if not ok or response.status ~= 200
                    return nil

            tbl = JSONToTable( response.body )
            unless tbl
                return nil

            versions, length = {}, 0
            for version, href in pairs( tbl )
                length += 1
                versions[ length ] = {
                    Name: name,
                    Installed: false,
                    Repository: parent,
                    Version: Version( version ),
                    URL: href
                }

            return versions

        return nil

searchPackages = repositories.SearchPackages = ( repository, pattern, version, withPattern ) ->
    latest = version == "latest"
    packages, count = {}, 0

    for package in *repository.Packages
        if pattern
            if withPattern
                unless find( package.Name, pattern, 1, false )
                    continue

            elseif package.Name ~= pattern
                continue

        if version and not ( latest or package.Version % version )
            continue

        count += 1
        packages[ count ] = package

    sort( packages, ( a, b ) -> a.Version > b.Version )

    if latest and count > 1
        for index = 2, count
            packages[ index ] = nil

    return packages

performPackage = repositories.PerformPackage = ( repository, package ) ->
    unless package
        return nil

    name, version = package.Name, package.Version
    packages = repository.Packages
    exists = false

    for other in *packages
        if other.Name == name and other.Version == version
            other.URL = package.URL
            exists = true
            break

    if exists
        return nil

    packages[] = package
    return nil

syncSQL = repositories.SyncSQL = ( repository ) ->
    if CLIENT
        return nil

    Query( "BEGIN;" )
    repositoryID = repository.ID
    Query( "INSERT OR REPLACE INTO `gpm.repository` ( ID, URL ) VALUES ( " .. repositoryID .. ", '" .. repository.URL .. "' )" )

    for package in *repository.Packages
        packageID = package.ID
        if packageID
            Query( "INSERT OR REPLACE INTO `gpm.packages` ( ID, RepositoryID, URL, Installed ) VALUES ( " .. packageID .. ", " .. repositoryID .. ", '" .. package.URL .. "', " .. ( package.Installed and "1" or "0" ) .. " )" )
        else
            Query( "INSERT OR REPLACE INTO `gpm.packages` ( RepositoryID, Name, Version, URL ) VALUES ( " .. repositoryID .. ", '" .. package.Name .. "', '" .. tostring( package.Version ) .. "', '" .. package.URL .. "' )" )

    Query( "COMMIT;" )
    return nil

updateRepository = repositories.UpdateRepository = async ( repository, map, pattern, withPattern ) ->
    tasks, length = {}, 0
    if pattern
        for name, href in pairs( map )
            if withPattern
                if find( name, pattern, 1, false )
                    length += 1
                    tasks[ length ] = fetchPackages( href, name, repository )

            elseif name == pattern
                length += 1
                tasks[ length ] = fetchPackages( href, name, repository )

    else
        for name, href in pairs( map )
            length += 1
            tasks[ length ] = fetchPackages( href, name, repository )

    if length == 0
        return nil

    if length == 1
        packages = await( tasks[ 1 ] )
        if packages
            for package in *packages
                performPackage( repository, package )

            syncSQL( repository )

        return nil

    for result in *await( AllSettled( tasks ) )
        packages = result.value
        if packages
            for package in *packages
                performPackage( repository, package )

            syncSQL( repository )

    return nil

fetchRepository = repositories.FetchRepository = async ( repository, specifier, withPattern, offlineMode ) ->
    packages = repository.Packages

    unless specifier
        if offline
            return packages

        success, response = SafeAwait( request( repository.URL ) )
        if not success or response.status ~= 200
            return packages

        map = JSONToTable( response.body, true, true )
        unless map
            return packages

        await updateRepository( repository, map, nil, false )
        return packages

    name, version = match( specifier, "^([^@]+)@(.+)$" )
    if offline
        return searchPackages( repository, name, version, withPattern )

    success, response = SafeAwait( request( repository.URL ) )
    if not success or response.status ~= 200
        return searchPackages( repository, name, version, withPattern )

    map = JSONToTable( response.body, true, true )
    unless map
        return searchPackages( repository, name, version, withPattern )

    await updateRepository( repository, map, name, withPattern )
    return searchPackages( repository, name, version, withPattern )

repositories.LookupRepositories = async ( specifier, offlineMode, withPattern = false ) ->
    tasks, length = {}, 0
    for repository in *list
        length += 1
        tasks[ length ] = fetchRepository( repository, specifier, withPattern, offlineMode )

    if length == 0
        return tasks

    if length == 1
        return await( tasks[ 1 ] )

    packages, length = {}, 0
    for promise in *await( AllSettled( tasks ) )
        :value = promise
        if value
            for package in *value
                length += 1
                packages[ length ] = package

    return packages
