_G = _G
import gpm from _G
import Query from _G.sql
import environment from gpm
import istable, util, CLIENT, SERVER, MENU_DLL, ArgAssert from environment
import JSONToTable, Version from util

if SERVER or MENU_DLL
    Query( "CREATE TABLE IF NOT EXISTS `gpm.table_version` ( Name TEXT PRIMARY KEY NOT NULL, Version INT )" )
    Query( "CREATE TABLE IF NOT EXISTS `gpm.repository` ( ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, URL TEXT UNIQUE NOT NULL )" )
    Query( "CREATE TABLE IF NOT EXISTS `gpm.packages` ( ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, Name TEXT NOT NULL, URL TEXT UNIQUE NOT NULL, Version TEXT NOT NULL, Installed BOOLEAN DEFAULT 0 NOT NULL, RepositoryID INTEGER DEFAULT 0 NOT NULL, FOREIGN KEY(RepositoryID) REFERENCES `gpm.repository` (ID) )" )

repositories = gpm.Repositories
unless istable( repositories )
    repositories = gpm.Repositories = {}

list = repositories.List
unless istable( list )
    if SERVER or MENU_DLL
        list = Query( "SELECT * FROM `gpm.repository`" ) or {}

        count = #list
        if count == 0
            Query( "INSERT INTO `gpm.repository` ( URL ) VALUES ( 'https://raw.githubusercontent.com/Pika-Software/gpm-repositories/main/main.json' )" )
            list = Query( "SELECT * FROM `gpm.repository`" ) or {}
            count = #list

        for index = 1, count
            repository = list[ index ]
            packages = Query( "SELECT * FROM `gpm.packages` WHERE RepositoryID = " .. repository.ID ) or {}

            for package in *packages
                package.Version = Version( package.Version )
                package.Installed = package.Installed == 1
                package.RepositoryID = repository
                package.RepositoryID = nil

            repository.Packages = packages

        repositories.List = list

    if SERVER
        environment.file.Set( "/lua/gpm/vfs/repositories.lua", "return '" .. util.TableToJSON( repositories, false ) .. "'", "GLua Package Manager::Repositories" )
        _G.AddCSLuaFile( "lua/gpm/vfs/repositories.lua" )

    if CLIENT
        list = JSONToTable( include( "gpm/vfs/repositories.lua" ) )
        repositories.List = list

import await, async, SafeAwait, AllSettled from environment.Promise
import IsURL, match, find from environment.string
import sort from environment.table
import URL, pairs from environment

local request
do

    import CachedFetch from environment.http

    local api_token
    if SERVER
        api_token = _G.CreateConVar( "gpm_github_token", "", _G.bit.bor( _G.FCVAR_ARCHIVE, _G.FCVAR_PROTECTED ), "https://github.com/settings/tokens" )

    request = ( href ) ->
        local headers
        if api_token
            token = api_token\GetString!
            if token and token ~= ""
                headers = { Authorization: "Bearer " .. token }

        return CachedFetch( href, headers )

apis = repositories.APIs
unless istable( apis )
    apis = repositories.APIs = {}

apis["github.com"] = ( url, name, parent ) ->
    if url.scheme ~= "https"
        return nil

    user, repository = match( url.pathname, "^/([^/]+)/([^/]+)/?$" )
    unless user and repository
        return nil

    name or= repository

    ok, response = SafeAwait( request( "https://api.github.com/repos/" .. user .. "/" .. repository .. "/tags" ) )
    if not ok or response.status ~= 200
        return nil

    tags = JSONToTable( response.body )
    unless tags
        return nil

    versions, length = {}, 0
    for tag in *tags
        length += 1
        versions[ length ] = {
            Name: name,
            Installed: false,
            Repository: parent,
            Version: Version( tag.name ),
            URL: user .. "/" .. repository .. "/" .. tag.name
        }

    return versions

local fetchPackages
do

    import getExtension from environment.path
    import isstring from environment

    fetchPackages = repositories.FetchPackages = async ( url, name, parent ) ->
        if IsURL( url )
            if isstring( url )
                url = URL( url )

            fn = apis[ url.hostname ]
            if fn
                return fn( url, name, parent )

            if getExtension( url.pathname ) == "json"
                ok, response = SafeAwait( request( url.href ) )
                if not ok or response.status ~= 200
                    return nil

            tbl = JSONToTable( response.body )
            unless tbl
                return nil

            versions, length = {}, 0
            for version, href in pairs( tbl )
                length += 1
                versions[ length ] = {
                    Name: name,
                    Installed: false,
                    Repository: parent,
                    Version: Version( version ),
                    URL: href
                }

            return versions

        return nil

sort_fn = ( a, b ) ->
    return a.Version > b.Version

searchPackages = repositories.SearchPackages = ( repository, name, version, withPattern ) ->
    latest = version == "latest"
    packages, count = {}, 0

    for package in *repository.Packages
        if name
            if withPattern
                unless find( package.Name, name, 1, false )
                    continue

            elseif package.Name ~= name
                continue

        if version and not ( latest or package.Version % version )
            continue

        count += 1
        packages[ count ] = package

    sort( packages, sort_fn )

    if latest and count > 1
        for index = 2, count
            packages[ index ] = nil

    return packages

performPackage = repositories.PerformPackage = ( repository, package ) ->
    unless package
        return nil

    name, version = package.Name, package.Version
    packages = repository.Packages
    exists = false

    for other in *packages
        if other.Name == name and other.Version == version
            other.URL = package.URL
            exists = true
            break

    if exists
        return nil

    packages[] = package
    return nil

syncSQL = repositories.SyncSQL = ( repository ) ->
    if CLIENT
        return nil

    -- TODO: WIP waiting retro's cool sql library

    -- Query( "BEGIN;" )
    -- repositoryID = repository.ID
    -- Query( "INSERT OR REPLACE INTO `gpm.repository` ( ID, URL ) VALUES ( " .. repositoryID .. ", '" .. repository.URL .. "' )" )

    -- for package in *repository.Packages
    --     packageID = package.ID
    --     if packageID
    --         Query( "REPLACE INTO `gpm.packages` ( ID, Name, URL, Version, Installed, RepositoryID ) VALUES ( " .. packageID .. ", '" .. package.Name .. "', '" .. package.URL .. "', '" .. tostring( package.Version ) .. "', " .. ( package.Installed and 1 or 0 ) .. ", " .. repositoryID .. " )" )
    --     else
    --         Query( "INSERT INTO `gpm.packages` ( Name, URL, Version, Installed, RepositoryID ) VALUES ( '" .. package.Name .. "', '" .. package.URL .. "', '" .. tostring( package.Version ) .. "', " .. ( package.Installed and 1 or 0 ) .. ", " .. repositoryID .. " )" )

    -- Query( "COMMIT;" )
    -- return nil

updateRepository = repositories.UpdateRepository = async ( repository, map, pattern, withPattern ) ->
    tasks, length = {}, 0
    if pattern
        for name, href in pairs( map )
            if withPattern
                if find( name, pattern, 1, false )
                    length += 1
                    tasks[ length ] = fetchPackages( href, name, repository )

            elseif name == pattern
                length += 1
                tasks[ length ] = fetchPackages( href, name, repository )

    else
        for name, href in pairs( map )
            length += 1
            tasks[ length ] = fetchPackages( href, name, repository )

    if length == 0
        return nil

    if length == 1
        packages = await( tasks[ 1 ] )
        if packages
            for package in *packages
                performPackage( repository, package )

            syncSQL( repository )

        return nil

    for result in *await( AllSettled( tasks ) )
        packages = result.value
        if packages
            for package in *packages
                performPackage( repository, package )

            syncSQL( repository )

    return nil

fetchRepository = repositories.FetchRepository = async ( repository, name, version, withPattern, offlineMode ) ->
    packages = repository.Packages

    unless name or version
        if offline
            return packages

        success, response = SafeAwait( request( repository.URL ) )
        if not success or response.status ~= 200
            return packages

        map = JSONToTable( response.body, true, true )
        unless map
            return packages

        await updateRepository( repository, map, nil, false )
        return packages

    if offline
        return searchPackages( repository, name, version, withPattern )

    success, response = SafeAwait( request( repository.URL ) )
    if not success or response.status ~= 200
        return searchPackages( repository, name, version, withPattern )

    map = JSONToTable( response.body, true, true )
    unless map
        return searchPackages( repository, name, version, withPattern )

    await updateRepository( repository, map, name, withPattern )
    return searchPackages( repository, name, version, withPattern )

lookupRepositories = repositories.LookupRepositories = async ( name, version, offlineMode, withPattern = false ) ->
    tasks, length = {}, 0
    for repository in *list
        length += 1
        tasks[ length ] = fetchRepository( repository, name, version, withPattern, offlineMode )

    if length == 0
        return tasks

    if length == 1
        return await( tasks[ 1 ] )

    packages, length = {}, 0
    for promise in *await( AllSettled( tasks ) )
        :value = promise
        if value
            for package in *value
                length += 1
                packages[ length ] = package

    sort( packages, sort_fn )
    return packages

do

    str_sort = ( a, b ) ->
        return a < b

    import Find from _G.file
    import tostring from _G

    repositories.FindPackage = async ( name, version, offlineMode, withPattern ) ->
        ArgAssert( name, 1, "string" )

        packageName = name
        if withPattern
            _, folders = Find( "gpm/vfs/packages/*", "LUA" )
            for folderName in *folders
                if find( folderName, name, 1, false )
                    packageName = folderName
                    break

        _, versions = Find( "gpm/vfs/packages/" .. packageName .. "/*", "LUA" )
        if #versions > 0
            sort( versions, str_sort )

            local versionObj
            if version
                ArgAssert( version, 2, "string" )

                for folderName in *versions
                    versionObj = Version( folderName )
                    if versionObj % version
                        break

            else
                versionObj = Version( versions[ 1 ] )

            if versionObj
                return {
                    Name: packageName,
                    URL: "file:///lua/gpm/vfs/packages/" .. packageName .. "/" .. tostring( versionObj ),
                    Version: versionObj
                }

        package = await( lookupRepositories( name, version, offlineMode, withPattern ) )[ 1 ]
        if package
            return package
