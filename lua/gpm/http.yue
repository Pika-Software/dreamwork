import ArgAssert, Promise, Logger, http, util from gpm
import HTTPError from Promise
isstring = isstring
isnumber = isnumber

http.UserAgent = string.format( "GLua Package Manager/%s - Garry's Mod/%s", gpm.VERSION, VERSIONSTR )

client, clientName, returnsState, userAgentKey = HTTP, "Garry's Mod", true, nil
do

    clients = {
        {
            Name: "reqwest"
            Client: "reqwest"
            Available: SERVER
            ReturnsState: false
            UserAgentKey: "User-Agent"
        },
        {
            Name: "chttp"
            Client: "CHTTP"
            Available: CLIENT or SERVER
            ReturnsState: false
        }
    }

    for item in *clients
        if item.Available and ( util.IsBinaryModuleInstalled( item.Name ) and pcall( require, item.Name ) )
            client, clientName, returnsState, userAgentKey = _G[ item.Client ], item.Name, item.ReturnsState, item.UserAgentKey
            break

    Logger\Info( "'%s' was connected as HTTP client.", clientName )

local HTTP
do

    http_timeout = CreateConVar( "http_timeout", "10", FCVAR_ARCHIVE, "Default http timeout for gpm http library.", 3, 300 )

    request = ( parameters, p ) ->
        if client( parameters ) or not returnsState
            Logger\Debug( "%s HTTP request to '%s', using '%s', with timeout %d seconds.", parameters.method, parameters.url, clientName, parameters.timeout )
        else
            p\Reject( HTTPError "failed to make http request" )

    queue = {}
    util.NextTick ->
        for func in *queue
            func!

        queue = nil

    HTTP = ( parameters ) ->
        ArgAssert( parameters, 1, "table" )
        p = Promise!

        unless isstring( parameters.method )
            parameters.method = "GET"

        unless isnumber( parameters.timeout )
            parameters.timeout = http_timeout\GetInt!

        if userAgentKey
            parameters.headers[ userAgentKey ] = http.UserAgent

        parameters.success = ( code, body, headers ) ->
            p\Resolve( { :code, :body, :headers } )

        parameters.failed = ( msg ) ->
            p\Reject( HTTPError msg )
            return

        if queue
            queue[] = ->
                request( parameters )
        else
            request( parameters )

        return p

    gpm.HTTP = HTTP

do

    tbl = setmetatable( {}, { __mode: "v" } )

    http.Fetch = ( url, headers, timeout ) ->
        tbl.url = url
        tbl.method = "GET"
        tbl.headers = headers
        tbl.timeout = timeout
        tbl.parameters = nil
        return HTTP( tbl )

    http.Post = ( url, parameters, headers, timeout ) ->
        tbl.url = url
        tbl.method = "POST"
        tbl.headers = headers
        tbl.timeout = timeout
        tbl.parameters = parameters
        return HTTP( tbl )
