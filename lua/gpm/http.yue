_G = _G
import gpm from _G
import environment, Logger from gpm
import ArgAssert, Promise, http, isstring, isnumber, istable from environment

unless isstring( http.UserAgent )
    http.UserAgent = "GLua Package Manager/" .. gpm.VERSION .. " - Garry's Mod/" .. VERSIONSTR

class HTTPError extends environment.Error
environment.HTTPError = HTTPError

client, clientName, returnsState, userAgentKey = _G.HTTP, "Garry's Mod", true, nil
do

    clients = {
        {
            Name: "reqwest"
            Client: "reqwest"
            Available: SERVER
            ReturnsState: false
            UserAgentKey: "User-Agent"
        },
        {
            Name: "chttp"
            Client: "CHTTP"
            Available: CLIENT or SERVER
            ReturnsState: false
        }
    }

    for item in *clients
        if item.Available and ( util.IsBinaryModuleInstalled( item.Name ) and pcall( require, item.Name ) )
            client, clientName, returnsState, userAgentKey = _G[ item.Client ], item.Name, item.ReturnsState, item.UserAgentKey
            break

    Logger\Info( "'%s' was connected as HTTP client.", clientName )

local HTTP
do

    http_timeout = CreateConVar( "http_timeout", "10", FCVAR_ARCHIVE, "Default http timeout for gpm http library.", 3, 300 )

    request = ( parameters, p ) ->
        if client( parameters ) or not returnsState
            Logger\Debug( "%s HTTP request to '%s', using '%s', with timeout %d seconds.", parameters.method, parameters.url, clientName, parameters.timeout )
        else
            p\Reject( HTTPError "failed to make http request" )

    queue = {}
    timer.Simple 0, ->
        for func in *queue
            func!

        queue = nil

    HTTP = ( parameters ) ->
        ArgAssert( parameters, 1, "table" )
        p = Promise!

        unless isstring( parameters.method )
            parameters.method = "GET"

        unless isnumber( parameters.timeout )
            parameters.timeout = http_timeout\GetInt!

        if userAgentKey
            unless istable( parameters.headers )
                parameters.headers = {}

            parameters.headers[ userAgentKey ] = http.UserAgent

        parameters.success = ( status, body, headers ) ->
            p\Resolve( { :status, :body, :headers } )
            return

        parameters.failed = ( msg ) ->
            p\Reject( HTTPError msg )
            return

        if queue
            queue[] = ->
                request( parameters )
        else
            request( parameters )

        return p

    environment.HTTP = HTTP

do

    tbl = setmetatable( {}, { __mode: "v" } )

    http.Fetch = ( url, headers, timeout ) ->
        tbl.url = url
        tbl.method = "GET"
        tbl.headers = headers
        tbl.timeout = timeout
        tbl.parameters = nil
        return HTTP( tbl )

    http.Post = ( url, parameters, headers, timeout ) ->
        tbl.url = url
        tbl.method = "POST"
        tbl.headers = headers
        tbl.timeout = timeout
        tbl.parameters = parameters
        return HTTP( tbl )
