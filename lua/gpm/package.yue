gpm = gpm
import file, path, metaworks, Logger, Promise, Table, Error from gpm
import async, await from Promise
istable = istable

packages = Table( gpm, "Packages" )

class InvalidPackageConfigurationError extends Error
gpm.InvalidPackageConfigurationError = InvalidPackageConfigurationError

--[[
    Packages: {
        package_name: {
            1.0.0: Package Object1
            2.0.0: Package Object2
            1.1.0: Package Object3
        }
    }
]]

-- class Package
--     new: ( url ) =>
--         @url = url
--         @name = "unknown"
--         @version = "unknown"
--         @dependencies = {}
--         @environment = {}

--     GetInfo: =>
--         p = @info
--         if p ~= nil
--             return p
--         p = @source\GetInfo( @ )
--         @info = p
--         return p

--     Install: =>

-- gpm.Package = Package

--[[

    https://github.com/user/repos -> GitHub Type -> https://github.com/user/repos.zip -> HTTP Type -> ...

    gpm.Install = ( url ) ->
        protocol, filePath = string.match( url, "^(%w+)%:%/%/(%w+)$" )
        for source in *sources
            if table.HasValue( source.Protocols, protocol, true )
                return source.Process( protocol, filePath )

--]]

gpm.Environment = setmetatable( {
    metaworks: gpm.metaworks
    await: Promise.await
    async: Promise.async
    require: (...) -> gpm.Import ...
    string: gpm.string
    Promise: Promise
    table: gpm.table
    debug: gpm.debug
    math: gpm.math
    path: gpm.path
    file: gpm.file
    http: gpm.http
    util: gpm.util
}, { __index: _G } )

-- Maybe gpm.Package must be a just metadata from package.lua
class gpm.Package
    new: ( @meta = {}, @path ) =>
        if not istable @meta
            error InvalidPackageConfigurationError "metadata is #{type @meta}, expected table"

        @env = @@CreateEnvironment!
        @parse!

    -- TODO: Make smart metatable
    CreateEnvironment: -> setmetatable {}, { __index: gpm.Environment }
    GetEntry: (meta) -> meta.entry or "init.lua"

    parse: =>
        @name = @meta.name or @path or "unknown"
        @version = @meta.version or "0.0.1"
        @dir = string.GetPathFromFilename @path
        @entry = @@GetEntry @meta

    __tostring: => "Package #{@name}@#{@version}"

    LoadURL: (url) => gpm.loader.LoadURL url, @
    Import: (url, should_await = true) =>
        parent_url = gpm.loader.GetParentURL!
        result = gpm.loader.AsyncImport url, parent_url, @

        if should_await
            return result\await!
        return result

gpm.ParsePackageMeta = (path) ->
    meta = {}

    entry = CompileFile path
    unless entry
        return nil

    setfenv entry, meta
    unless success, reason = try entry!
        error InvalidPackageConfigurationError reason

    if SERVER
        AddCSLuaFile path

    return meta

gpm.ParsePackage = (path) -> gpm.Package gpm.ParsePackageMeta(path), path

--[[
    gpm.PACKAGE_LOAD_TASKS = {}

    loadAsyncDataInner = async () ->
        -- ...

    gpm.LoadAsyncData = (url) ->
        if not gpm.PACKAGE_LOAD_TASKS[url]
            gpm.PACKAGE_LOAD_TASKS[url] = loadAsyncDataInner url
        return gpm.PACKAGE_LOAD_TASKS[url]
]]
