gpm = gpm
:fs, :path, :metaworks, :Logger, :Promise, :Table, :Error = gpm
luaGameDir = fs.LuaGameDir
istable = istable

packages = Table( gpm, "Packages" )

class InvalidPackageConfigurationError extends Error
gpm.InvalidPackageConfigurationError = InvalidPackageConfigurationError

--[[
    Packages: {
        package_name: {
            1.0.0: Package Object1
            2.0.0: Package Object2
            1.1.0: Package Object3
        }
    }
]]

-- class Package
--     new: ( url ) =>
--         @url = url
--         @name = "unknown"
--         @version = "unknown"
--         @dependencies = {}
--         @environment = {}

--     GetInfo: =>
--         p = @info
--         if p ~= nil
--             return p
--         p = @source\GetInfo( @ )
--         @info = p
--         return p

--     Install: =>

-- gpm.Package = Package

--[[

    https://github.com/user/repos -> GitHub Type -> https://github.com/user/repos.zip -> HTTP Type -> ...

    gpm.Install = ( url ) ->
        protocol, filePath = string.match( url, "^(%w+)%:%/%/(%w+)$" )
        for source in *sources
            if table.HasIValue( source.Protocols, protocol )
                return source.Process( protocol, filePath )

--]]

setupEnv = (func) ->
    setfenv func, setmetatable {
        require: gpm.Import
        Promise: gpm.Promise
        await: gpm.Promise.await
        async: gpm.Promise.async
    }, { __index: _G, __newindex: _G }

-- Maybe gpm.Package must be a just metadata from package.lua
class gpm.Package
    METADATA_KEYS: {
        "name": true
        "version": true
        "description": true
        "main": true
        "dependencies": true
    }

    new: ( data ) =>
        @metadata = data or {}
        @env = {}

    __index: ( key ) =>
        if @METADATA_KEYS[key]
            return @metadata[key]


readMetadataFromLua = (path) ->
    meta = {}
    entry = CompileFile path
    unless entry
        return nil
    setfenv entry, meta
    unless success, reason = try entry!
        error InvalidPackageConfigurationError reason

    if SERVER then AddCSLuaFile path
    return meta

gpm.LoadMetadataFromDir = (dir) ->
    pmeta_path = path.Join dir, "package.lua"
    unless file.Exists pmeta_path, "LUA"
        return nil

    meta = readMetadataFromLua pmeta_path
    unless meta
        error InvalidPackageConfigurationError "failed to parse #{pmeta_path}"

    meta.dir = dir
    meta.main or= "init.lua"
    return gpm.Package meta

--[[
    gpm.PACKAGE_LOAD_TASKS = {}

    loadAsyncDataInner = async () ->
        -- ...

    gpm.LoadAsyncData = (url) ->
        if not gpm.PACKAGE_LOAD_TASKS[url]
            gpm.PACKAGE_LOAD_TASKS[url] = loadAsyncDataInner url
        return gpm.PACKAGE_LOAD_TASKS[url]
]]
