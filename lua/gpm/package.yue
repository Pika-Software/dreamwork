_G = _G
import gpm from _G
import environment, loader from gpm
import async, await, string, file, path, metaworks, table, istable, rawset, Logger from environment
import format, gsub, GetPathFromFilename from string

:packages = gpm
unless istable( packages )
    packages = gpm.Packages = {}

class InvalidPackageConfigurationError extends environment.Error
environment.InvalidPackageConfigurationError = InvalidPackageConfigurationError

--[[
    Packages: {
        package_name: {
            1.0.0: Package Object1
            2.0.0: Package Object2
            1.1.0: Package Object3
        }
    }
]]

-- class Package
--     new: ( url ) =>
--         @url = url
--         @name = "unknown"
--         @version = "unknown"
--         @dependencies = {}
--         @environment = {}

--     GetInfo: =>
--         p = @info
--         if p ~= nil
--             return p
--         p = @source\GetInfo( @ )
--         @info = p
--         return p

--     Install: =>

-- gpm.Package = Package

--[[

    https://github.com/user/repos -> GitHub Type -> https://github.com/user/repos.zip -> HTTP Type -> ...

    gpm.Install = ( url ) ->
        protocol, filePath = string.match( url, "^(%w+)%:%/%/(%w+)$" )
        for source in *sources
            if table.HasValue( source.Protocols, protocol, true )
                return source.Process( protocol, filePath )

--]]

createEnvironment = ->
    return metaworks.Environment( environment, { :_G } )

gpm.CreateEnvironment = createEnvironment

-- Maybe gpm.Package must be a just metadata from package.lua
class Package
    new: ( @metadata = {}, @import_path ) =>
        unless istable( @metadata )
            error InvalidPackageConfigurationError "metadata is " .. type( @metadata ) .. ", expected table"

        @environment = createEnvironment!
        @parse!

    GetEnvironment: =>
        return @environment

    GetEntry: ( metadata ) ->
        return metadata.entry or "init.lua"

    parse: =>
        :import_path, :metadata = @
        @name = metadata.name or gsub( import_path, "/", "_" ) or "unknown"
        @dir = GetPathFromFilename( import_path )
        @version = metadata.version or "0.0.1"
        @entry = @@GetEntry( metadata )

    __tostring: =>
        return format( "Package: %p [%s@%s]", @, @name, @version )

    LoadURL: ( url ) =>
        return loader.LoadURL( url, @ )

    Import: ( url, should_await = true ) =>
        result = loader.AsyncImport( url, loader.GetParentURL!, @ )

        if should_await
            return result\await!

        return result

gpm.Package = Package

environment.ispackage = ( any ) ->
    metatable = getmetatable( any )
    return metatable and metatable.__class == Package

gpm.ParsePackageMeta = async ( metaPath ) ->
    func = await file.Compile( metaPath, "LUA" )

    metadata = {}
    setfenv( func, metadata )

    success, result = pcall( func )
    unless success
        error InvalidPackageConfigurationError result

    if istable( result )
        table.Merge( metadata, result )

    table.LowerKeyNames( metadata )
    return metadata

gpm.ParsePackage = async ( importPath ) ->
    return Package( await( gpm.ParsePackageMeta( importPath ) ), importPath )

--[[
    gpm.PACKAGE_LOAD_TASKS = {}

    loadAsyncDataInner = async () ->
        -- ...

    gpm.LoadAsyncData = (url) ->
        if not gpm.PACKAGE_LOAD_TASKS[url]
            gpm.PACKAGE_LOAD_TASKS[url] = loadAsyncDataInner url
        return gpm.PACKAGE_LOAD_TASKS[url]
]]
