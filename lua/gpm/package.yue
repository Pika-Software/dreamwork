_G = _G

import gpm, setmetatable, setfenv from _G
import environment from gpm

import async, await, debug,
    string, file,
    table, istable, rawset,
    Error, type,
    isstring from environment

import format from string
import Environment, Link from environment.metaworks
import getfpathi from debug

class InvalidPackageConfigurationError extends Error
environment.InvalidPackageConfigurationError = InvalidPackageConfigurationError

class InvalidModuleConfigurationError extends Error
environment.InvalidModuleConfigurationError = InvalidModuleConfigurationError

--[[
    Packages: {
        package_name: {
            1.0.0: Package Object1
            2.0.0: Package Object2
            1.1.0: Package Object3
        }
    }

--]]

--[[

    package = [
        file1: Module
        file2: Module
        ...
    ]

]]

class Module
    __tostring: =>
        return format( "Module: %p [%s]", @, @name )

    new: ( @location, @url, @env = _G ) =>
        unless isstring( url )
            error InvalidModuleConfigurationError "url is " .. type( url ) .. ", expected URL"

        @name = getfpathi( location ) or "unknown"
        setfenv( location, setmetatable({ _MODULE: @ }, { __index: env, __newindex: env }) )
        return

gpm.Module = Module

--[[

    parent1 = [
        parent2 = [
            child1,
            child2
        ]
    ]

]]

packages = gpm.Packages
unless istable( packages )
    packages = gpm.Packages = setmetatable( {}, { __newindex: debug.fempty, __index: ( key ) =>
        tbl = {}
        rawset( @, key, tbl )
        return tbl
    } )

local ispackage

class Package
    __tostring: =>
        return format( "Package: %p [%s@%s]", @, @name, @version )

    new: ( location, url, parent, metadata ) =>
        unless istable( metadata )
            error InvalidPackageConfigurationError "metadata is " .. type( metadata ) .. ", expected table"

        name = @name = metadata.name or getfpathi( location ) or "unknown"
        version = @version = metadata.version or "0.1.0"
        packages[ name ][ version ] = @

        env = @env = Environment( environment, { :_G, _PACKAGE: @ } )
        @entry = Module( location, url, env )

        parents = @parents = {}
        @children = {}

        if ispackage( parent )
            parents[] = parent
            parent.children[] = @
            Link( parent.env, env )

gpm.Package = Package

ispackage = environment.ispackage = ( any ) ->
    metatable = getmetatable( any )
    return metatable and metatable.__class == Package

gpm.ParsePackageMeta = async ( metaPath ) ->
    func = await file.Compile( metaPath, "LUA" )

    metadata = {}
    setfenv( func, metadata )

    success, result = pcall( func )
    unless success
        error InvalidPackageConfigurationError result

    if istable( result )
        table.Merge( metadata, result )

    table.LowerKeyNames( metadata )
    return metadata

gpm.ParsePackage = async ( importPath ) ->
    return Package( await( gpm.ParsePackageMeta( importPath ) ), importPath )

--[[
    gpm.PACKAGE_LOAD_TASKS = {}

    loadAsyncDataInner = async () ->
        -- ...

    gpm.LoadAsyncData = (url) ->
        if not gpm.PACKAGE_LOAD_TASKS[url]
            gpm.PACKAGE_LOAD_TASKS[url] = loadAsyncDataInner url
        return gpm.PACKAGE_LOAD_TASKS[url]
]]
