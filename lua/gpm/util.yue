MENU_DLL = MENU_DLL
CLIENT = CLIENT
SERVER = SERVER

if SERVER
    AddCSLuaFile!

setmetatable = setmetatable
ipairs = ipairs
error = error
type = type
gpm = gpm

gpm_Table = ( tbl, name, func, ... ) ->
    result = tbl[ name ]
    if type( result ) ~= "table"
        if func
            result = func( ... )
        else
            result = { ... }
        tbl[ name ] = result
    return result
gpm.Table = gpm_Table

types = gpm_Table( gpm, "Types", ->
    return {
        Indexes: {}
        Names: {
            [-1]: "unknown"
            [0]: "nil"
            [1]: "boolean"
            [2]: "light userdata"
            [3]: "number"
            [4]: "string"
            [5]: "table"
            [6]: "function"
            [7]: "userdata"
            [8]: "thread"
            [9]: "Entity"
            [10]: "Vector"
            [11]: "Angle"
            [12]: "PhysObj"
            [13]: "ISave"
            [14]: "IRestore"
            [15]: "CTakeDamageInfo"
            [16]: "CEffectData"
            [17]: "CMoveData"
            [18]: "CRecipientFilter"
            [19]: "CUserCmd"
            [21]: "IMaterial"
            [22]: "Panel"
            [23]: "CLuaParticle"
            [24]: "CLuaEmitter"
            [25]: "ITexture"
            [26]: "bf_read"
            [27]: "ConVar"
            [28]: "IMesh"
            [29]: "VMatrix"
            [30]: "CSoundPatch"
            [31]: "pixelvis_handle_t"
            [32]: "dlight_t"
            [33]: "IVideoWriter"
            [34]: "File"
            [35]: "CLuaLocomotion"
            [36]: "PathFollower"
            [37]: "CNavArea"
            [38]: "IGModAudioChannel"
            [39]: "CNavLadder"
            [40]: "CNewParticleEffect"
            [41]: "ProjectedTexture"
            [42]: "PhysCollide"
            [43]: "SurfaceInfo"
            [255]: "Color"
        }
    } )

typeNames = types.Names
indexes = types.Indexes

gpm_type = nil
do

    TYPE_USERDATA = TYPE_USERDATA
    TYPE_TABLE = TYPE_TABLE
    TypeID = TypeID

    gpm_TypeID = ( any ) ->
        id = TypeID any
        if id == TYPE_TABLE or id == TYPE_USERDATA
            for data in *indexes
                unless data[ 1 ]( any )
                    continue
                return data[ 2 ]
        return id
    gpm.TypeID = gpm_TypeID

    gpm_type = ( any ) ->
        return typeNames[ gpm_TypeID( any ) ] or "unknown"
    gpm.type = gpm_type

string = gpm_Table( gpm, "string", ->
    return setmetatable( {}, { __index: string } )
)

string.StartsWith = string.StartsWith or string.StartWith

do
    string_match = string.match
    string.IsURL = ( str ) ->
        if string_match( str, "[a-z]+://[^ >,;]+" ) ~= nil
            return true
        return false

string_format = string.format
string_lower = string.lower
string_sub = string.sub

debug = gpm_Table( gpm, "debug", ->
    return setmetatable( {}, { __index: debug } )
)

debug.fempty = ->
debug.fcall = ( func, ... ) ->
    return func( ... )
debug_getinfo = debug.getinfo

gpm_ArgAssert = ( value, argNum, expected, errorlevel ) ->
    valueType, expectedType = gpm_type( value ), gpm_type( expected )
    if expectedType == "table"
        str, len = "[ ", #expected
        for index = 1, len
            typeName = expected[ index ]

            if valueType == typeName
                return value
            elseif index ~= len
                str = str .. typeName .. ", "

        expected = str .. " ]"
    elseif expectedType == "function"
        expected = expected( value, argNum )
        if type( expected ) ~= "string"
            return value
    elseif valueType == expected
        return value

    dinfo = debug_getinfo( 2, "n" )
    error( string_format( "bad argument #%d to \'%s\' (%s expected, got %s)", argNum, dinfo and dinfo.name or "func", expected, valueType ), errorlevel or 3 )
gpm.ArgAssert = gpm_ArgAssert

table = gpm_Table( gpm, "table", ->
    return setmetatable( {}, { __index: table } )
)

table.HasIValue = ( tbl, any ) ->
    for value in *tbl
        if value == any
            return true
    return false

table_remove = table.remove
table.RemoveByIValue = ( tbl, any ) ->
    for index, value in ipairs( tbl )
        if value == any
            return table_remove( tbl, index )

string_Split = string.Split
table.Lookup = ( tbl, str, default ) ->
    for key in *string_Split( str, "." )
        tbl = tbl[ key ]
        unless tbl
            return default
    return tbl

table.SetValue = ( tbl, str, value, ifEmpty ) ->
    keys = string_Split( str, "." )
    len = #keys

    for index = 1, len
        key = keys[ index ]
        if index == len then
            oldValue = tbl[ key ]
            if oldValue ~= nil and ifEmpty
                return oldValue

            tbl[ key ] = value
            return value

        nextValue = tbl[ key ]
        if nextValue == nil
            tbl[ key ] = {}
        elseif type( nextValue ) ~= "table"
            return

        tbl = tbl[ key ]

table_Lower = ( tbl ) ->
    for key, value in pairs( tbl )
        if type( value ) == "table"
            value = table_Lower( value )

        keyType = type( key )
        if keyType == "string"
            tbl[ string_lower( key ) ] = value
            tbl[ key ] = nil
        elseif keyType == "table"
            tbl[ table_Lower( key ) ] = value
            tbl[ key ] = nil

    return tbl
table.Lower = table_Lower

table.RemoveByFunction = ( tbl, func ) ->
    result, fulfilled = {}, false
    while not fulfilled
        fulfilled = true

        for index, value in ipairs( tbl )
            if func( index, value )
                result[ #result + 1 ] = table.remove( tbl, index )
                fulfilled = false
                break

    return result

table.unpack = unpack

gpm_AddType = ( typeName, func ) ->
    gpm_ArgAssert( typeName, 1, "string" )
    gpm_ArgAssert( func, 2, "function" )

    nextIndex = 256
    for key, name in pairs( typeNames )
        if typeName == name
            nextIndex = key
            break
        elseif key >= nextIndex
            nextIndex = key + 1
    typeNames[ nextIndex ] = typeName

    for index, data in ipairs( indexes )
        if nextIndex == data[ 2 ]
            table_remove( indexes, index )
            break

    indexes[] = { func, nextIndex }
    return nextIndex
gpm.AddType = gpm_AddType

getmetatable = getmetatable

gpm_IsColor = nil
do

    meta = FindMetaTable( "Color" )

    gpm_IsColor = ( any ) ->
        if getmetatable( any ) == meta
            return true
        elseif type( any ) == "table"
            return type( any.r ) == "number" and type( any.g ) == "number" and type( any.b ) == "number"
        return false
    gpm_AddType( "Color", gpm_IsColor )
    gpm.IsColor = gpm_IsColor

paths = gpm_Table( gpm, "paths" )
string_gsub = string.gsub

paths_Fix = ( filePath ) ->
    return string_lower( string_gsub( filePath, "[/\\]+", "/" ) )
paths.Fix = paths_Fix

paths.Join = ( ... ) ->
    arguments, filePath = { ... }, nil
    length = #arguments

    for index = 1, length
        if filePath ~= nil
            filePath = filePath .. arguments[ index ]
        else
            filePath = arguments[ index ]
        if index == length
            return paths_Fix( filePath )
        filePath = filePath .. "/"

paths_Localize = ( filePath ) ->
    return string_gsub( string_gsub( string_gsub( filePath, "^cache/%w+/", "" ), "^addons/[%w%-_]-/", "" ), "^lua/", "" )
paths.Localize = paths_Localize

debug.getfpath = ->
    for i = 2, 6
        info = debug_getinfo( i, "S" )
        unless info
            break

        if info.what == "main"
            return paths_Localize( paths_Fix( info.short_src ) )

do

    string_GetExtensionFromFilename = string.GetExtensionFromFilename

    paths.ToLua = ( filePath ) ->
        extension = string_GetExtensionFromFilename( filePath )
        if extension ~= "lua"
            if extension
                filePath = string_gsub( filePath, "%..+$", ".lua" )
            else
                filePath = filePath .. ".lua"
        return filePath

do

    math = gpm_Table( gpm, "math", ->
        return setmetatable( {}, { __index: math } )
    )

    math.inf = 1 / 0
    math.nan = 0 / 0

do

    util = gpm_Table( gpm, "util", ->
        return setmetatable( {}, { __index: util } )
    )

    do
        tonumber = tonumber
        util.Version = ( number ) ->
            unless number
                return "unknown"
            elseif type( number ) == "string"
                return number

            version = string_format( "%06d", number )
            return string_format( "%d.%d.%d", tonumber( string_sub( version, 0, 2 ) ), tonumber( string_sub( version, 3, 4 ) ), tonumber( string_sub( version, 5 ) ) )

    do
        timer_Simple = timer.Simple
        util.NextTick = ( func, a, b, c, d ) ->
            gpm_ArgAssert( func, 1, "function" )
            timer_Simple( 0, ->
                func( a, b, c, d )
            )

    do

        file_Exists = file.Exists

        util.IsLuaModuleInstalled = ( name ) ->
            return file_Exists( "includes/modules/" .. name .. ".lua", "LUA" )

        isWindows, isLinux = system.IsWindows!, system.IsLinux!
        jit_versionnum, jit_arch = jit.versionnum, jit.arch

        suffix = ( { "osx64", "osx", "linux64", "linux", "win64", "win32" } )[ ( isWindows and 4 or 0 ) + ( isLinux and 2 or 0 ) + ( jit_arch == "x86" and 1 or 0 ) + 1 ]
        fmt = "lua/bin/gm" .. ( ( CLIENT and not MENU_DLL ) and "cl" or "sv" ) .. "_%s_%s.dll"

        util.IsBinaryModuleInstalled = ( name ) ->
            gpm_ArgAssert( name, 1, "string" )
            if file_Exists( string_format( fmt, name, suffix ), "GAME" )
                return true
            elseif jit_versionnum ~= 20004 and jit_arch == "x86" and isLinux
                return file_Exists( string_format( fmt, name, "linux32" ), "GAME" )
            return false

    do

        CompileString = CompileString

        moonloader_ToLua = nil
        if type( moonloader ) == "table"
            moonloader_ToLua = moonloader.ToLua

        util.CompileMoonString = ( moonCode, identifier, handleError ) ->
            unless moonloader_ToLua
                error( "Attempting to compile a Moonscript file fails, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

            luaCode, msg = moonloader_ToLua( moonCode )
            msg = msg or "MoonScript to Lua code compilation failed."

            unless luaCode
                error( msg )

            func = CompileString( luaCode, identifier, handleError )
            if type( func ) ~= "function"
                error( msg )

            return func

    do

        string_byte = string.byte
        string_len = string.len
        math_Clamp = math.Clamp

        class ByteStream
            new: ( data ) =>
                @Data = data
                @Pointer = 1
                @Length = string_len( data )

            Close: =>
                @Pointer = 1
                @Length = 0
                @Data = ""

            Size: =>
                return @Length

            Tell: =>
                return @Pointer

            Seek: ( pos ) =>
                @Pointer = math_Clamp( pos or 1, 1, @Length )

            Skip: ( length ) =>
                @Seek( @Pointer + ( length or 1 ) )

            EndOfFile: =>
                return @Pointer >= @Length

            ReadByte: ( length ) =>
                pointer = @Pointer
                @Skip( length )
                return string_byte( @Data, pointer, length )

            ReadBool: =>
                return @ReadByte! ~= 0

            Read: ( length ) =>
                data, pointer, fileLength, result = @Data, @Pointer, @Length, nil
                while ( length > 0 and pointer < fileLength )
                    unless result
                        result = data[ pointer ]
                    else
                        result = result .. data[ pointer ]
                    length -= 1
                    pointer += 1
                @Seek( pointer )
                return result

            ReadUInt: ( length ) =>
                uInt = 0
                for i = 1, length
                    uInt = uInt + @ReadByte! * 0x100 ^ ( i - 1 )
                return uInt

            ReadULong: =>
                return @ReadUInt( 4 )

            ReadUShort: =>
                return @ReadUInt( 2 )

            ReadString: =>
                startPos, length = @Tell!, -1

                while not @EndOfFile! and @ReadByte! ~= 0
                    length += 1

                @Seek( startPos )
                data = @Read( length )
                @Skip( 1 )
                return data

        util.ByteStream = ByteStream

    do

        Color = Color

        colors = gpm_Table( gpm, "Colors", ->
            return {
                SecondaryText: Color( 150, 150, 150 )
                PrimaryText: Color( 200, 200, 200 )
                White: Color( 255, 255, 255 )
                Info: Color( 70, 135, 255 )
                Warn: Color( 255, 130, 90 )
                Error: Color( 250, 55, 40 )
                Debug: Color( 0, 200, 150 )
                gpm: Color( 180, 180, 255 )
            } )

        state, stateColor, whiteColor = gpm.State, colors.State, colors.White
        if type( state ) ~= "string"
            if MENU_DLL
                state, stateColor = "Menu", Color( 75, 175, 80 )
            elseif CLIENT
                state, stateColor = "Client", Color( 225, 170, 10 )
            elseif SERVER
                state, stateColor = "Server", Color( 5, 170, 250 )
            gpm.State, colors.State = state or "unknown", stateColor or whiteColor

        debugFilter = ->
            return gpm.Developer > 0

        primaryTextColor = colors.PrimaryText
        secondaryTextColor = colors.SecondaryText
        state = string.upper( state )
        os_date = os.date
        select = select
        MsgC = MsgC

        infoColor = colors.Info
        warnColor = colors.Warn
        errorColor = colors.Error
        debugColor = colors.Debug

        class Logger
            __tostring: () => "Logger [" .. @GetName! .. "]"

            new: ( name, color, func ) =>
                @DebugFilter = type( func ) == "function" and func or debugFilter
                @Name = type( name ) == "string" and name or "unknown"
                @Color = gpm_IsColor( color ) and color or whiteColor
                @TextColor = primaryTextColor

            GetName: => @Name
            SetName: ( str ) =>
                gpm_ArgAssert( str, 1, "string" )
                @Name = str

            GetColor: => @Color
            SetColor: ( color ) =>
                gpm_ArgAssert( color, 1, "Color" )
                @Color = color

            GetTextColor: => @TextColor
            SetTextColor: ( color ) =>
                gpm_ArgAssert( color, 1, "Color" )
                @TextColor = color

            GetDebugFilter: => @DebugFilter
            SetDebugFilter: ( func ) =>
                gpm_ArgAssert( func, 1, "function" )
                @DebugFilter = func

            Log: ( color, level, str, ... ) =>
                gpm_ArgAssert( color, 1, "Color" )
                gpm_ArgAssert( level, 2, "string" )

                if select( "#", ... ) > 0
                    str = string_format( str, ... )
                MsgC( secondaryTextColor, os_date( "%d-%m-%Y %H:%M:%S " ), stateColor, "[" .. state .. "] ", color, level, secondaryTextColor, " --> ", @Color, @Name, secondaryTextColor, " : ", @TextColor, str, "\n" )

            Info: ( str, ... ) =>
                @Log( infoColor, "INFO ", str, ... )

            Warn: ( str, ... ) =>
                @Log( warnColor, "WARN ", str, ... )

            Error: ( str, ... ) =>
                @Log( errorColor, "ERROR", str, ... )

            Debug: ( str, ... ) =>
                if @DebugFilter( str, ... ) then
                    @Log( debugColor, "DEBUG", str, ... )

        gpm.Logger = Logger( "gpm@" .. gpm.VERSION, colors.gpm )
        util.Logger = Logger