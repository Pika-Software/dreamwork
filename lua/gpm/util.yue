setmetatable = setmetatable
isfunction = isfunction
isstring = isstring
isnumber = isnumber
tonumber = tonumber
istable = istable
error = error
pairs = pairs
gpm = gpm

gTable = ( tbl, name, func, ... ) ->
    result = tbl[ name ]
    unless istable( result )
        if isfunction( func )
            result = func( ... )
        else
            result = {}

        tbl[ name ] = result

    return result

gpm.Table = gTable

gTable gpm, "__types", ->
    return {
        Functions: {}

        Indexes: setmetatable( {
            "unknown": -1
            "nil": 0
            "boolean": 1
            "light userdata": 2
            "number": 3
            "string": 4
            "table": 5
            "function": 6
            "userdata": 7
            "thread": 8
            "Entity": 9
            "Vector": 10
            "Angle": 11
            "PhysObj": 12
            "ISave": 13
            "IRestore": 14
            "CTakeDamageInfo": 15
            "CEffectData": 16
            "CMoveData": 17
            "CRecipientFilter": 18
            "CUserCmd": 19
            "IMaterial": 21
            "Panel": 22
            "CLuaParticle": 23
            "CLuaEmitter": 24
            "ITexture": 25
            "bf_read": 26
            "ConVar": 27
            "IMesh": 28
            "VMatrix": 29
            "CSoundPatch": 30
            "pixelvis_handle_t": 31
            "dlight_t": 32
            "IVideoWriter": 33
            "File": 34
            "CLuaLocomotion": 35
            "PathFollower": 36
            "CNavArea": 37
            "IGModAudioChannel": 38
            "CNavLadder": 39
            "CNewParticleEffect": 40
            "ProjectedTexture": 41
            "PhysCollide": 42
            "SurfaceInfo": 43
            "Color": 255
        }, {
            __index: ->
                return -1
        } )

        Names: setmetatable( {
            [ -1 ]: "unknown"
            [ 0 ]: "nil"
            [ 1 ]: "boolean"
            [ 2 ]: "light userdata"
            [ 3 ]: "number"
            [ 4 ]: "string"
            [ 5 ]: "table"
            [ 6 ]: "function"
            [ 7 ]: "userdata"
            [ 8 ]: "thread"
            [ 9 ]: "Entity"
            [ 10 ]: "Vector"
            [ 11 ]: "Angle"
            [ 12 ]: "PhysObj"
            [ 13 ]: "ISave"
            [ 14 ]: "IRestore"
            [ 15 ]: "CTakeDamageInfo"
            [ 16 ]: "CEffectData"
            [ 17 ]: "CMoveData"
            [ 18 ]: "CRecipientFilter"
            [ 19 ]: "CUserCmd"
            [ 21 ]: "IMaterial"
            [ 22 ]: "Panel"
            [ 23 ]: "CLuaParticle"
            [ 24 ]: "CLuaEmitter"
            [ 25 ]: "ITexture"
            [ 26 ]: "bf_read"
            [ 27 ]: "ConVar"
            [ 28 ]: "IMesh"
            [ 29 ]: "VMatrix"
            [ 30 ]: "CSoundPatch"
            [ 31 ]: "pixelvis_handle_t"
            [ 32 ]: "dlight_t"
            [ 33 ]: "IVideoWriter"
            [ 34 ]: "File"
            [ 35 ]: "CLuaLocomotion"
            [ 36 ]: "PathFollower"
            [ 37 ]: "CNavArea"
            [ 38 ]: "IGModAudioChannel"
            [ 39 ]: "CNavLadder"
            [ 40 ]: "CNewParticleEffect"
            [ 41 ]: "ProjectedTexture"
            [ 42 ]: "PhysCollide"
            [ 43 ]: "SurfaceInfo"
            [ 255 ]: "Color"
        }, {
            __index: ->
                return "unknown"
        } )
    }

string = gTable gpm, "string", ->
    return setmetatable( {}, { __index: string } )

table = gTable gpm, "table", ->
    return setmetatable( {}, { __index: table } )

math = gTable gpm, "math", ->
    return setmetatable( {}, { __index: math } )

debug = gTable gpm, "debug", ->
    return setmetatable( {}, { __index: debug } )

http = gTable gpm, "http", ->
    return setmetatable( {}, { __index: http } )

util = gTable gpm, "util", ->
    return setmetatable( {}, { __index: util } )

string.StartsWith = string.StartsWith or string.StartWith

table.unpack = unpack

math.inf = 1 / 0
math.nan = 0 / 0

math.Clamp = ( number, min, max ) ->
	if number < min
        return min

    if number > max
        return max

    return number

debug.fempty = ->

util.CompileMoonString = ->
    error( "Attempt to compile MoonScript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

util.CompileYueString = ->
    error( "Attempt to compile Yuescript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

do

    import match from string

    string.IsURL = ( str ) ->
        return match( str, "^[a-z%+]+%:[^ >,;]+" ) ~= nil

import byte, char, sub, gsub, format, len, find from string
import concat, remove from table
import getinfo from debug

-- Custom variable types
do

    types = gpm.__types
    type2Name, type2Index, typeFunctions = types.Names, types.Indexes, types.Functions

    metadataTypes = { "userdata": true, "table": true }
    type = type

    typeID = ( value ) ->
        typeName = type( value )
        if metadataTypes[ typeName ]
            for funcData in *typeFunctions
                if funcData and funcData[ 1 ]( value )
                    return funcData[ 2 ]

        return type2Index[ typeName ]

    gpm.TypeID = typeID

    gpm.type = ( value ) ->
        return type2Name[ typeID( value ) ]

    gpm.AddType = ( typeName, func ) ->
        assert( isstring( typeName ), "bad argument #1 to \'AddType\' (string expected)" )
        assert( isfunction( func ), "bad argument #2 to \'AddType\' (function expected)" )

        typeIndex = 256

        for index, name in pairs( type2Name )
            if typeName == name
                typeIndex = index
                break
            elseif index >= typeIndex
                typeIndex = index + 1

        type2Name[ typeIndex ] = typeName
        type2Index[ typeName ] = typeIndex

        length = #typeFunctions
        for index = 1, length
            funcData = typeFunctions[ index ]
            if funcData and funcData[ 2 ] == typeIndex
                remove( typeFunctions, index )
                length -= 1
                break

        typeFunctions[ length + 1 ] = { func, typeIndex }
        return typeIndex

split = ( str, separator = " ", withPattern ) ->
    withPattern = withPattern ~= true
    result, length = {}, 0

    if len( separator ) == 0
        for index = 1, len( str )
            length += 1
            result[ length ] = sub( str, index, index )

        return result, length

    pointer = 1

    for _ = 1, len( str )
        startPos, endPos = find( str, separator, pointer, withPattern )
        unless startPos
            break

        length += 1
        result[ length ] = sub( str, pointer, startPos - 1 )
        pointer = endPos + 1

    length += 1
    result[ length ] = sub( str, pointer )

    return result, length

string.Explode = split
string.Split = split

string.Extract = ( str, pattern, default ) ->
    startPos, endPos, matched = find( str, pattern, 1, false )
    if startPos
        return sub( str, 1, startPos - 1 ) .. sub( str, endPos + 1 ), matched or default

    return str, default

local ArgAssert
do

    import type from gpm

    ArgAssert = ( value, argNum, expected, errorlevel ) ->
        valueType = type( value )

        if valueType == expected
            return value

        elseif isfunction( expected )
            expected = expected( value, argNum, valueType )
            unless isstring( expected )
                return value

        elseif istable( expected )
            for index = 1, #expected
                if valueType == expected[ index ]
                    return value

            expected = "[ " .. concat( expected, "/" ) .. " ]"

        error "bad argument #" .. argNum .. " to \'" .. ( getinfo( 2, "n" ).name or "unknown" ) .. "\' (" .. expected .. " expected, got " .. valueType .. ")", errorlevel or 3

    gpm.ArgAssert = ArgAssert

table.HasValue = ( tbl, any, isSequential ) ->
	if isSequential
		for index = 1, #tbl
			if tbl[ index ] == any
                return true

    else

        for _, value in pairs( tbl )
            if value == any
                return true

	return false

table.Empty = ( tbl ) ->
    for key in pairs( tbl )
        tbl[ key ] = nil

table.GetKeyCount = ( tbl ) ->
    length = 0

    for _ in pairs( tbl )
        length += 1

    return length

table.GetKeys = ( tbl ) ->
    result, length = {}, 0

    for key in pairs( tbl )
        length += 1
        result[ length ] = key

    return result, length

table.GetValues = ( tbl ) ->
    result, length = {}, 0

    for _, value in pairs( tbl )
        length += 1
        result[ length ] = value

    return result, length

do

    next = next

    table.IsEmpty = ( tbl ) ->
        return next( tbl ) == nil

table.IsSequential = ( tbl ) ->
    index = 1

    for _ in pairs( tbl )
        if tbl[ index ] == nil
            return false

        index += 1

    return true

table.RemoveByValue = ( tbl, any, isSequential ) ->
    if isSequential
        for index = 1, #tbl
            if tbl[ index ] == any
                return remove( tbl, index )

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil
                return value

    return nil

table.RemoveSameValues = ( tbl, any, isSequential ) ->
    if isSequential
        ::removed::

        for index = 1, #tbl
            if tbl[ index ] == any
                remove( tbl, index )
                goto removed

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil

    return nil

table.GetValue = ( tbl, str ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        tbl = tbl[ sub( str, pointer, startPos - 1 ) ]
        if tbl == nil
            return

        pointer = startPos + 1

    return tbl[ sub( str, pointer ) ]

table.SetValue = ( tbl, str, value ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        key = sub( str, pointer, startPos - 1 )
        pointer = startPos + 1

        if tbl[ key ] == nil
            tbl[ key ] = {}

        tbl = tbl[ key ]

    tbl[ sub( str, pointer ) ] = value

do

    import random from math
    index, length = 1, 0

    table.Shuffle = ( tbl ) ->
        length = #tbl
        for i = length, 1, -1
            index = random( 1, length )
            tbl[ i ], tbl[ index ] = tbl[ index ], tbl[ i ]

        return tbl

    do

        keys = setmetatable( {}, { __mode: "v" } )

        table.Random = ( tbl, isSequential ) ->
            if isSequential
                length = #tbl
                if length == 0
                    return nil, nil

                if length == 1
                    index = 1
                else
                    index = random( 1, length )

            else

                length = 0
                for key in pairs( tbl )
                    length += 1
                    keys[ length ] = key

                if length == 0
                    return nil, nil

                if length == 1
                    index = keys[ 1 ]
                else
                    index = keys[ random( 1, length ) ]

            return tbl[ index ], index

do

    import lower from string

    lowerKeyNames = ( tbl ) ->
        for key, value in pairs( tbl )
            if istable( value )
                value = lowerKeyNames( value )

            if isstring( key )
                tbl[ lower( key ) ] = value
                tbl[ key ] = nil
            elseif istable( key )
                tbl[ lowerKeyNames( key ) ] = value
                tbl[ key ] = nil

        return tbl

    table.LowerKeyNames = lowerKeyNames

local iscolor
do

    getmetatable = getmetatable
    metatable = FindMetaTable( "Color" )

    iscolor = ( value ) ->
        if getmetatable( value ) == metatable
            return true

        if istable( value )
            return isnumber( value.r ) and isnumber( value.g ) and isnumber( value.b )

        return false

    gpm.AddType( "Color", iscolor )
    gpm.iscolor = iscolor

do

    path = gTable( gpm, "path" )

    do

        import StripExtension from string

        path.ReplaceExtension = ( filePath, newExtension ) ->
            return StripExtension( filePath ) .. "." .. newExtension

    fix = ( filePath ) ->
        return gsub( gsub( filePath, "[/\\]+", "/" ), "^/+", "" ), nil

    path.Fix = fix

    localizeLua = ( filePath ) ->
        return gsub( gsub( fix( filePath ), "^.-lua/", "" ), "^.-gamemode/", "" ), nil

    path.LocalizeLua = localizeLua

    path.Join = ( ... ) ->
        return fix( concat( { ... }, "/" ) )

    path.Resolve = ( ... ) ->
        buffer, length = {}, 0
        args = { ... }

        for index = 1, #args
            arg = tostring( args[ index ] )
            if sub( arg, 1, 1 ) == "/"
                length = 1
                if sub( args[ 1 ], 1, 1 ) ~= "/"
                    buffer[ length ] = sub( arg, 2 )
                else
                    buffer[ length ] = arg
            else
                length += 1
                buffer[ length ] = arg

        filePath = concat( buffer, "/", 1, length )

        segments, segmentCount = split( filePath, "[/\\]+", true )
        if segmentCount == 0
            return filePath

        for index = 1, length
            buffer[ index ] = nil

        length = 0

        for index = 1, segmentCount
            segment = segments[ index ]
            if segment ~= "."
                if segment == ".."
                    if length ~= 0
                        length -= 1
                else
                    length += 1
                    buffer[ length ] = segment

        if length == 0
            return ""

        return concat( buffer, "/", 1, length )

    getfmain = ->
        for level = 2, 16
            info = getinfo( level, "fS" )
            unless info
                break

            if info.what == "main"
                return info.func

    debug.getfmain = getfmain

    getfpathi = ( level ) ->
        info = getinfo( level, "S" )
        if info.what == "main"
            return localizeLua( fix( sub( info.source, 2 ) ) )

    debug.getfpathi = getfpathi

    debug.getfpath = ->
        main = getfmain!
        if main
            return getfpathi( main )

do

    -- https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
    -- https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
    codes = {

        --[[--------------------
            Successful 2XX
        --------------------]]--
        [ 200 ]: { "OK", "The resource has been obtained" }
        [ 201 ]: { "Created", "The request succeeded, and a new resource was created as a result" }
        [ 202 ]: { "Accepted", "The request has been received but not yet acted upon" }
        [ 203 ]: { "Non-Authoritative Information", "This response code means the returned metadata is not exactly the same as is available from the origin server" }
        [ 204 ]: { "No Content", "The request has been send with no errors also there is no content to send for this request, but the headers may be useful" }
        [ 205 ]: { "Reset Content", "This response tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI" }
        [ 206 ]: { "Partial Content", "The request has succeeded and the body contains the requested ranges of data, as described in the Range header of the request" }
        [ 207 ]: { "Multi-Status", "This response code indicates that there might be a mixture of responses" }
        [ 208 ]: { "Already Reported", "This response code is used in a 207 (207 Multi-Status) response to save space and avoid conflicts" }

        --[[--------------------
            Client Error 4XX
        --------------------]]--
        [ 400 ]: { "Bad Request", "The server was unable to interpret the request given invalid syntax" }
        [ 401 ]: { "Unauthorized", "Authentication is required to get the requested response" }
        [ 403 ]: { "Forbidden", "You don't have the necessary permissions for certain content, so the server is refusing to grant an appropriate response" }
        [ 404 ]: { "Not Found", "The server was unable to find the requested content" }
        [ 405 ]: { "Method Not Allowed", "The requested method is known to the server but it has been disabled and cannot be used" }
        [ 408 ]: { "Request Timeout", "A timeout has occurred while processing an HTTP request" }
        [ 409 ]: { "Conflict", "The server encountered a conflict with the request sent with the current state of the server" }
        [ 410 ]: { "Gone", "The requested content has been deleted from the server" }
        [ 411 ]: { "Length Required", "The server rejected the request because the Content-Length is not defined" }
        [ 418 ]: { "I'm a teapot", "This client error response code indicates that the server refuses to brew coffee because it is, permanently, a teapot." }
        [ 429 ]: { "Rate limit reached for requests", "This error message indicates that you have hit your assigned rate limit for the API" }

        --[[--------------------
            Server Error 5XX
        --------------------]]--
        [ 500 ]: { "Internal Server Error", "This response means that the server encountered an unexpected condition that prevented it from fulfilling the request" }
        [ 501 ]: { "Not Implemented", "This response means that the server does not support the functionality required to fulfill the request" }
        [ 502 ]: { "Bad Gateway", "This response means that the server, while acting as a gateway or proxy, received an invalid response from the upstream server" }
        [ 503 ]: { "Service Unavailable", "This response means that the server is not ready to handle the request" }
        [ 504 ]: { "Gateway Timeout", "This response means that the server, while acting as a gateway or proxy, did not get a response in time from the upstream server that it needed in order to complete the request" }
        [ 505 ]: { "HTTP Version Not Supported", "This response status code indicates that the HTTP version used in the request is not supported by the server" }
        [ 507 ]: { "Insufficient Storage", "This operation couldn't succeed, maybe because the request it's too large to fit on a disk" }
        [ 508 ]: { "Loop Detected", "This status indicates that the entire operation failed, the server terminated an operation because it encountered an infinite loop" }

    }

    http.Codes = codes

    http.GetStatusDescription = ( code ) ->
        data = codes[ code ]
        if data
            return data[ 1 ], data[ 2 ]

do

    import gmatch from string
    import tohex from bit

    encodeChar = ( str ) ->
        return "%" .. tohex( byte( str ), 2 )

    encode = ( str, pattern ) ->
        return gsub( str, "[^%w" .. ( pattern or "%-%._~+" ) .. "]", encodeChar ), nil

    http.Encode = encode

    decodeChar = ( str ) ->
        return char( tonumber( str, 16 ) )

    decode = ( str ) ->
        return gsub( str, "%%(%x%x)", decodeChar ), nil

    http.Decode = decode

    http.ParseQueryValue = ( str ) ->
        tbl, length = {}, 0
        for value in gmatch( str, "\"(.-)\"" )
            length += 1
            tbl[ length ] = decode( value )

        return tbl, length

    http.ParseQuery = ( str ) ->
        result, length = {}, 0
        for key, value in gmatch( str, "([^&=?]-)=([^&=?]+)" )
            length += 1
            result[ length ] = { decode( key ), decode( value ) }

        return result, length

    queryKeySymbols = "%-%_%."
    queryValueSymbols = "%!%$%'%(%)%*%,%-%.%:%;%@%_%~"

    http.ListToQueryValue = ( lst ) ->
        length = #lst
        if length == 0
            return ""

        for index = 1, length
            lst[ index ] = "\"" .. encode( lst[ index ], queryValueSymbols ) .. "\""

        return "[" .. concat( lst, ",", 1, length ) .. "]"

    http.Query = ( query, length ) ->
        length = length or #query

        if length == 0
            return "", length

        if length == 1
            data = query[ length ]
            return "?" .. encode( data[ 1 ], queryKeySymbols ) .. "=" .. encode( data[ 2 ], queryValueSymbols ), length

        result = {}
        for index = 1, length
            data = query[ index ]
            result[ index ] = encode( data[ 1 ], queryKeySymbols ) .. "=" .. encode( data[ 2 ], queryValueSymbols )

        return "?" .. concat( result, "&", 1, length ), length

class util.Stack
    __tostring: =>
        return format( "Stack: %p [%d/%d]", @, @Pointer, @Length )

    new: ( length ) =>
        @Length = ( isnumber( length ) and length > 0 ) and length or -1
        @Pointer = 0

    isEmpty: =>
        return @Pointer == 0

    isFull: =>
        return @Pointer == @Length

    peek: =>
        return @[ @Pointer ]

    push: ( value ) =>
        pointer = @Pointer
        if pointer ~= @Length
            pointer += 1
            @[ pointer ] = value
            @Pointer = pointer

        return pointer

    pop: =>
        pointer = @Pointer
        if pointer == 0
            return nil

        @Pointer = pointer - 1
        value = @[ pointer ]
        @[ pointer ] = nil
        return value

    empty: =>
        for index = 1, @Pointer
            @[ index ] = nil

        @Pointer = 0

do

    import abs, floor, ldexp from math
    import band, rshift from bit

    buffer = setmetatable( {}, { __mode: "v" } )
    boolean = { [ 0 ]: false, [ 1 ]: true }

    class util.ByteStream
        __tostring: =>
            return format( "ByteStream: %p [%d/%d]", @, @Pointer, @Length )

        new: ( data ) =>
            if isstring( data )
                @Length = len( data )
                @Data = data
            else
                @Length = 0
                @Data = ""

            @Pointer = 0

        Close: =>
            @Pointer = 0

        Flush: =>
            @Pointer = 0
            @Length = 0
            @Data = ""

        Size: =>
            return @Length

        Tell: =>
            return @Pointer

        Seek: ( pointer ) =>
            if pointer
                ArgAssert( pointer, 2, "number" )

                if pointer < 0
                    pointer = 0
                elseif pointer > @Length
                    pointer = @Length

            else
                pointer = 0

            @Pointer = pointer
            return pointer

        Skip: ( bytes ) =>
            if bytes
                ArgAssert( bytes, 2, "number" )
            else
                bytes = 1

            return @Seek( @Pointer + bytes )

        EndOfFile: =>
            return @Pointer >= @Length

        -- Binary data
        Read: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes <= 0 or @EndOfFile!
                return

            pointer = @Pointer
            @Skip( bytes )

            return sub( @Data, pointer + 1, pointer + bytes )

        Write: ( data ) =>
            length, size = @Length, len( data )
            @Data = sub( @Data, 1, @Pointer ) .. data .. sub( @Data, @Pointer + 1, length )
            @Length = length + size
            return @Skip( size )

        -- String
        ReadString: =>
            pointer, length = @Pointer, @Length
            if pointer >= length
                return

            bytes, data = 0, @Data
            for index = pointer, length
                if byte( data, index + 1 ) == 0
                    break

                bytes += 1

            if bytes == 0
                return

            return @Read( bytes ), @Skip( 1 )

        WriteString: ( str ) =>
            return @Write( str .. "\0" )

        -- Byte
        ReadByte: =>
            if @EndOfFile!
                return

            return byte( @Data, @Skip( 1 ) )

        WriteByte: ( number ) =>
            return @Write( char( number ) )

        -- Boolean
        ReadBool: =>
            return boolean[ @ReadByte! or -1 ]

        WriteBool: ( bool ) =>
            return @WriteByte( bool and 1 or 0 )

        -- UInt
        ReadUInt: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return

            uint = 0
            for index = 1, bytes
                number = @ReadByte!
                if number == nil
                    return

                uint += number * 0x100 ^ ( index - 1 )

            return uint

        WriteUInt: ( number, bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return @Pointer

            for index = 1, bytes
                buffer[ index ] = char( band( number, 0xFF ) )
                number = rshift( number, 8 )

            return @Write( concat( buffer, "", 1, bytes ) )

        -- UShort
        ReadUShort: =>
            return @ReadUInt( 2 )

        WriteUShort: ( number ) =>
            return @WriteUInt( number, 2 )

        -- ULong
        ReadULong: =>
            return @ReadUInt( 4 )

        WriteULong: ( number ) =>
            return @WriteUInt( number, 4 )

        -- UInt64
        ReadUInt64: =>
            return @ReadUInt( 8 )

        WriteUInt64: ( number ) =>
            @WriteUInt( number, 8 )

        -- Int
        ReadInt: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return

            uint = @ReadUInt( bytes )
            if uint == nil
                return

            max = 0x100 ^ abs( bytes )
            if uint >= ( max / 2 )
                return uint - max

            return uint

        WriteInt: ( number, bytes ) =>
            for index = 1, bytes
                buffer[ index ] = char( number % 0x100 )
                number = floor( number / 0x100 )

            return @Write( concat( buffer, "", 1, bytes ) )

        -- Short
        ReadShort: =>
            return @ReadInt( 2 )

        WriteShort: ( number ) =>
            return @WriteInt( number, 2 )

        -- Long
        ReadLong: =>
            return @ReadInt( 4 )

        WriteLong: ( number ) =>
            return @WriteInt( number, 4 )

        -- Int64
        ReadInt64: =>
            return @ReadInt( 8 )

        WriteInt64: ( number ) =>
            return @WriteInt( number, 8 )

        -- Float
        ReadFloat: =>
            binary = @Read( 4 )
            if not binary or len( binary ) ~= 4
                return

            byte1, byte2, byte3, byte4 = byte( binary, 1, 4 )
            exponent = byte4 % 0x80 * 2 + floor( byte3 / 0x80 ) - 0x7F
            if exponent == 0x7F
                return 0

            return ldexp( ldexp( byte3 % 0x80 * 0x10000 + byte2 * 0x100 + byte1, -23 ) + 1, exponent ) * ( byte4 < 0x80 and 1 or -1 )

util.Version = ( number ) ->
    if isstring( number )
        return number

    if isnumber( number )
        version = format( "%06d", number )
        return sub( version, 0, 2 ) .. "." .. sub( version, 3, 4 ) .. "." .. sub( version, 5 )

    return "unknown"

do

    import Simple from timer

    util.NextTick = ( func, a, b, c, d, e, f ) ->
        ArgAssert( func, 1, "function" )
        Simple 0, ->
            func( a, b, c, d, e, f )

do

    import Exists from file

    util.IsLuaModuleInstalled = ( name ) ->
        return Exists( "includes/modules/" .. name .. ".lua", "LUA" )

if SERVER

    import Fix, ReplaceExtension from gpm.path
    AddCSLuaFile = AddCSLuaFile
    import Find from file

    addCSLuaFolder = ( folderPath ) ->
        folderPath = Fix( folderPath .. "/" )

        files, folders = Find( folderPath .. "*", "lsv" )
        for folderName in *folders
            addCSLuaFolder( folderPath .. folderName )

        for fileName in *files
            AddCSLuaFile( folderPath .. ReplaceExtension( fileName, "lua" ) )

    util.AddCSLuaFolder = addCSLuaFolder

do

    Color = Color

    colors = gTable gpm, "Colors", ->
        return {
            SecondaryText: Color( 150, 150, 150 )
            PrimaryText: Color( 200, 200, 200 )
            White: Color( 255, 255, 255 )
            Info: Color( 70, 135, 255 )
            Warn: Color( 255, 130, 90 )
            Error: Color( 250, 55, 40 )
            Debug: Color( 0, 200, 150 )
            gpm: Color( 180, 180, 255 )
        }

    :PrimaryText, :SecondaryText, :Info, :Warn, :Error, :Debug, :White = colors

    unless isstring( gpm.RealmName )
        if MENU_DLL
            gpm.RealmName, colors.Realm = "Menu", Color( 75, 175, 80 )
        elseif CLIENT
            gpm.RealmName, colors.Realm = "Client", Color( 225, 170, 10 )
        elseif SERVER
            gpm.RealmName, colors.Realm = "Server", Color( 5, 170, 250 )
        else
           gpm.RealmName, colors.Realm = "Unknown", White

    local log
    do

        import date from os
        MsgC = MsgC

        realmName = "[" .. string.upper( gpm.RealmName ) .. "] "
        realmColor = colors.Realm

        log = ( color, level, str, ... ) =>
            ArgAssert( color, 1, "Color" )
            ArgAssert( level, 2, "string" )
            MsgC( SecondaryText, date( "%d-%m-%Y %H:%M:%S " ), realmColor, realmName, color, level, SecondaryText, " --> ", @color, @name, SecondaryText, " : ", @text_color, format( str, ... ), "\n" )
            return

    debugFilter = ->
        return gpm.Developer > 0

    class Logger
        __tostring: =>
            return format( "Logger: %p [%s]", @, @name )

        new: ( name, color, func ) =>
            @name = isstring( name ) and name or "unknown"
            @color = iscolor( color ) and color or White
            @debug_filter = isfunction( func ) and func or debugFilter
            @text_color = PrimaryText

        -- Logger Name
        GetName: =>
            return @name

        SetName: ( str ) =>
            ArgAssert( str, 1, "string" )
            @name = str

        -- Logger Color
        GetColor: =>
            return @color

        SetColor: ( color ) =>
            ArgAssert( color, 1, "Color" )
            @color = color

        -- Logger Text Color
        GetTextColor: =>
            return @text_color

        SetTextColor: ( color ) =>
            ArgAssert( color, 1, "Color" )
            @text_color = color

        -- Logger Debug Filter
        GetDebugFilter: =>
            return @debug_filter

        SetDebugFilter: ( func ) =>
            ArgAssert( func, 1, "function" )
            @debug_filter = func

        -- Logger Functions
        Log: log

        Info: ( ... ) =>
            log( @, Info, " INFO ", ... )

        Warn: ( ... ) =>
            log( @, Warn, " WARN ", ... )

        Error: ( ... ) =>
            log( @, Error, "ERROR ", ... )

        Loaded: ( ... ) =>
            log( @, Debug, "LOADED", ... )

        Debug: ( ... ) =>
            if @debug_filter( ... )
                log( @, Debug, "DEBUG ", ... )

    gpm.Logger = Logger( "gpm@" .. gpm.VERSION, colors.gpm )
    util.Logger = Logger
