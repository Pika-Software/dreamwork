setmetatable = setmetatable
isfunction = isfunction
isstring = isstring
isnumber = isnumber
tonumber = tonumber
istable = istable
error = error
pairs = pairs
gpm = gpm

Table = ( tbl, name, func, ... ) ->
    result = tbl[ name ]
    unless istable( result )
        if isfunction( func )
            result = func( ... )
        else
            result = {}

        tbl[ name ] = result

    return result

gpm.Table = Table

Names, Indexes = nil, nil
do

    types = Table gpm, "Types", -> {
        Indexes: {}
        Names: {
            [-1]: "unknown"
            [0]: "nil"
            [1]: "boolean"
            [2]: "light userdata"
            [3]: "number"
            [4]: "string"
            [5]: "table"
            [6]: "function"
            [7]: "userdata"
            [8]: "thread"
            [9]: "Entity"
            [10]: "Vector"
            [11]: "Angle"
            [12]: "PhysObj"
            [13]: "ISave"
            [14]: "IRestore"
            [15]: "CTakeDamageInfo"
            [16]: "CEffectData"
            [17]: "CMoveData"
            [18]: "CRecipientFilter"
            [19]: "CUserCmd"
            [21]: "IMaterial"
            [22]: "Panel"
            [23]: "CLuaParticle"
            [24]: "CLuaEmitter"
            [25]: "ITexture"
            [26]: "bf_read"
            [27]: "ConVar"
            [28]: "IMesh"
            [29]: "VMatrix"
            [30]: "CSoundPatch"
            [31]: "pixelvis_handle_t"
            [32]: "dlight_t"
            [33]: "IVideoWriter"
            [34]: "File"
            [35]: "CLuaLocomotion"
            [36]: "PathFollower"
            [37]: "CNavArea"
            [38]: "IGModAudioChannel"
            [39]: "CNavLadder"
            [40]: "CNewParticleEffect"
            [41]: "ProjectedTexture"
            [42]: "PhysCollide"
            [43]: "SurfaceInfo"
            [255]: "Color"
        }
    }

    :Names, :Indexes = types

do

    TYPE_USERDATA = TYPE_USERDATA
    TYPE_TABLE = TYPE_TABLE
    TypeID = TypeID

    id, data = nil, nil

    typeID = ( any ) ->
        id = TypeID( any )
        if id == TYPE_TABLE or id == TYPE_USERDATA
            for index = 1, #Indexes
                data = Indexes[ index ]
                if data ~= nil and data[ 1 ]( any )
                    return data[ 2 ]

        return id

    gpm.TypeID = typeID

    gpm.type = ( any ) ->
        return Names[ typeID( any ) ] or "unknown"

string = Table gpm, "string", ->
    return setmetatable( {}, { __index: string } )

table = Table gpm, "table", ->
    return setmetatable( {}, { __index: table } )

math = Table gpm, "math", ->
    return setmetatable( {}, { __index: math } )

debug = Table gpm, "debug", ->
    return setmetatable( {}, { __index: debug } )

http = Table gpm, "http", ->
    return setmetatable( {}, { __index: http } )

util = Table gpm, "util", ->
    return setmetatable( {}, { __index: util } )

string.StartsWith = string.StartsWith or string.StartWith

table.unpack = unpack

math.inf = 1 / 0
math.nan = 0 / 0

debug.fempty = ->

util.CompileMoonString = ->
    error( "Attempt to compile MoonScript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

util.CompileYueString = ->
    error( "Attempt to compile Yuescript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

do

    import match from string

    string.IsURL = ( str ) ->
        return match( str, "^[a-z%+]+%:[^ >,;]+" ) ~= nil

import byte, char, sub, gsub, format, len, find from string
import concat, remove from table
import getinfo from debug

split = ( str, separator = " ", withPattern ) ->
    withPattern = withPattern ~= true
    result, length = {}, 0

    if len( separator ) == 0
        for index = 1, len( str )
            length += 1
            result[ length ] = sub( str, index, index )

        return result, length

    pointer = 1

    for index = 1, len( str )
        startPos, endPos = find( str, separator, pointer, withPattern )
        unless startPos
            break

        length += 1
        result[ length ] = sub( str, pointer, startPos - 1 )
        pointer = endPos + 1

    length += 1
    result[ length ] = sub( str, pointer )

    return result, length

string.Explode = split
string.Split = split

string.Extract = ( str, pattern, default ) ->
    startPos, endPos, matched = find( str, pattern, 1, false )
    if startPos
        return sub( str, 1, startPos - 1 ) .. sub( str, endPos + 1 ), matched or default

    return str, default

ArgAssert = nil
do

    import type from gpm

    ArgAssert = ( value, argNum, expected, errorlevel ) ->
        valueType = type( value )

        if valueType == expected
            return value

        elseif isfunction( expected )
            expected = expected( value, argNum, valueType )
            unless isstring( expected )
                return value

        elseif istable( expected )
            for index = 1, #expected
                if valueType == expected[ index ]
                    return value

            expected = "[ " .. concat( expected, "/" ) .. " ]"

        error "bad argument #" .. argNum .. " to \'" .. ( getinfo( 2, "n" ).name or "unknown" ) .. "\' (" .. expected .. " expected, got " .. valueType .. ")", errorlevel or 3

    gpm.ArgAssert = ArgAssert

table.HasValue = ( tbl, any, isSequential ) ->
	if isSequential
		for index = 1, #tbl
			if tbl[ index ] == any
                return true

        return false

    for _, value in pairs( tbl )
        if value == any
            return true

	return false

table.Empty = ( tbl ) ->
    for key in pairs( tbl )
        tbl[ key ] = nil

table.RemoveByIValue = ( tbl, any ) ->
    for index = 1, #tbl
        if tbl[ index ] == any
            return remove( tbl, index )

table.GetValue = ( tbl, str, default ) ->
    keys, length = split( str, "." )
    for index = 1, length
        tbl = tbl[ keys[ index ] ]
        unless tbl
            return default

    return tbl

table.SetValue = ( tbl, str, value, ifEmpty ) ->
    keys, length = split( str, "." )
    for index = 1, length
        key = keys[ index ]
        if index == length
            oldValue = tbl[ key ]
            if oldValue ~= nil and ifEmpty
                return oldValue

            tbl[ key ] = value
            return value

        nextValue = tbl[ key ]
        if nextValue == nil
            tbl[ key ] = {}
        elseif not istable( nextValue )
            return

        tbl = tbl[ key ]

do

    import lower from string

    lowerTableKeys = ( tbl ) ->
        for key, value in pairs( tbl )
            if istable( value )
                value = lowerTableKeys( value )

            if isstring( key )
                tbl[ lower( key ) ] = value
                tbl[ key ] = nil
            elseif istable( key )
                tbl[ lowerTableKeys( key ) ] = value
                tbl[ key ] = nil

        return tbl

    table.LowerKeys = lowerTableKeys

gpm.AddType = ( typeName, func ) ->
    ArgAssert( typeName, 1, "string" )
    ArgAssert( func, 2, "function" )

    nextIndex = 256
    for key, value in pairs( Names )
        if typeName == value
            nextIndex = key
            break
        elseif key >= nextIndex
            nextIndex = key + 1

    Names[ nextIndex ] = typeName

    length = #Indexes
    for index = 1, length
        data = Indexes[ index ]
        if data ~= nil and data[ 2 ] == nextIndex
            remove( Indexes, index )
            length -= 1
            break

    Indexes[ length + 1 ] = { func, nextIndex }
    return nextIndex

iscolor = nil
do

    getmetatable = getmetatable
    metatable = FindMetaTable( "Color" )

    iscolor = ( value ) ->
        if getmetatable( value ) == metatable
            return true

        if istable( value )
            return isnumber( value.r ) and isnumber( value.g ) and isnumber( value.b )

        return false

    gpm.AddType( "Color", iscolor )
    gpm.iscolor = iscolor

do

    import StripExtension from string

    path = Table( gpm, "path" )

    fix = ( filePath ) ->
        return gsub( gsub( filePath, "[/\\]+", "/" ), "^/+", "" ), nil

    path.Fix = fix

    localizeLua = ( filePath ) ->
        return gsub( gsub( fix( filePath ), "^.-lua/", "" ), "^.-gamemode/", "" ), nil

    path.LocalizeLua = localizeLua

    path.Join = ( ... ) ->
        return fix( concat( { ... }, "/" ) )

    path.ReplaceExtension = ( filePath, newExtension ) ->
        return StripExtension( filePath ) .. "." .. newExtension

    path.Resolve = ( ... ) ->
        buffer, length = {}, 0
        args = { ... }

        for index = 1, #args
            arg = tostring( args[ index ] )
            if sub( arg, 1, 1 ) == "/"
                length = 1
                if sub( args[ 1 ], 1, 1 ) ~= "/"
                    buffer[ length ] = sub( arg, 2 )
                else
                    buffer[ length ] = arg
            else
                length += 1
                buffer[ length ] = arg

        filePath = concat( buffer, "/", 1, length )

        segments, segmentCount = split( filePath, "[/\\]+", true )
        if segmentCount == 0
            return filePath

        for index = 1, length
            buffer[ index ] = nil

        length = 0

        for index = 1, segmentCount
            segment = segments[ index ]
            if segment ~= "."
                if segment == ".."
                    if length ~= 0
                        length -= 1
                else
                    length += 1
                    buffer[ length ] = segment

        if length == 0
            return ""

        return concat( buffer, "/", 1, length )

    getfmain = ->
        for level = 2, 16
            info = getinfo( level, "fS" )
            unless info
                break

            if info.what == "main"
                return info.func

    debug.getfmain = getfmain

    getfpathi = ( level ) ->
        info = getinfo( level, "S" )
        if info.what == "main"
            return localizeLua( fix( sub( info.source, 2 ) ) )

    debug.getfpathi = getfpathi

    debug.getfpath = ->
        main = getfmain!
        if main
            return getfpathi( main )

do

    -- https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
    -- https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
    codes = {

        --[[--------------------
            Successful 2XX
        --------------------]]--
        [ 200 ]: { "OK", "The resource has been obtained" }
        [ 201 ]: { "Created", "The request succeeded, and a new resource was created as a result" }
        [ 202 ]: { "Accepted", "The request has been received but not yet acted upon" }
        [ 203 ]: { "Non-Authoritative Information", "This response code means the returned metadata is not exactly the same as is available from the origin server" }
        [ 204 ]: { "No Content", "The request has been send with no errors also there is no content to send for this request, but the headers may be useful" }
        [ 205 ]: { "Reset Content", "This response tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI" }
        [ 206 ]: { "Partial Content", "The request has succeeded and the body contains the requested ranges of data, as described in the Range header of the request" }
        [ 207 ]: { "Multi-Status", "This response code indicates that there might be a mixture of responses" }
        [ 208 ]: { "Already Reported", "This response code is used in a 207 (207 Multi-Status) response to save space and avoid conflicts" }

        --[[--------------------
            Client Error 4XX
        --------------------]]--
        [ 400 ]: { "Bad Request", "The server was unable to interpret the request given invalid syntax" }
        [ 401 ]: { "Unauthorized", "Authentication is required to get the requested response" }
        [ 403 ]: { "Forbidden", "You don't have the necessary permissions for certain content, so the server is refusing to grant an appropriate response" }
        [ 404 ]: { "Not Found", "The server was unable to find the requested content" }
        [ 405 ]: { "Method Not Allowed", "The requested method is known to the server but it has been disabled and cannot be used" }
        [ 408 ]: { "Request Timeout", "A timeout has occurred while processing an HTTP request" }
        [ 409 ]: { "Conflict", "The server encountered a conflict with the request sent with the current state of the server" }
        [ 410 ]: { "Gone", "The requested content has been deleted from the server" }
        [ 411 ]: { "Length Required", "The server rejected the request because the Content-Length is not defined" }
        [ 418 ]: { "I'm a teapot", "This client error response code indicates that the server refuses to brew coffee because it is, permanently, a teapot." }
        [ 429 ]: { "Rate limit reached for requests", "This error message indicates that you have hit your assigned rate limit for the API" }

        --[[--------------------
            Server Error 5XX
        --------------------]]--
        [ 500 ]: { "Internal Server Error", "This response means that the server encountered an unexpected condition that prevented it from fulfilling the request" }
        [ 501 ]: { "Not Implemented", "This response means that the server does not support the functionality required to fulfill the request" }
        [ 502 ]: { "Bad Gateway", "This response means that the server, while acting as a gateway or proxy, received an invalid response from the upstream server" }
        [ 503 ]: { "Service Unavailable", "This response means that the server is not ready to handle the request" }
        [ 504 ]: { "Gateway Timeout", "This response means that the server, while acting as a gateway or proxy, did not get a response in time from the upstream server that it needed in order to complete the request" }
        [ 505 ]: { "HTTP Version Not Supported", "This response status code indicates that the HTTP version used in the request is not supported by the server" }
        [ 507 ]: { "Insufficient Storage", "This operation couldn't succeed, maybe because the request it's too large to fit on a disk" }
        [ 508 ]: { "Loop Detected", "This status indicates that the entire operation failed, the server terminated an operation because it encountered an infinite loop" }

    }

    http.Codes = codes

    http.GetStatusDescription = ( code ) ->
        data = codes[ code ]
        if data
            return data[ 1 ], data[ 2 ]

do

    import gmatch from string
    import tohex from bit

    encodeChar = ( str ) ->
        return "%" .. tohex( byte( str ), 2 )

    encode = ( str, pattern ) ->
        return gsub( str, "[^%w" .. ( pattern or "%-%._~+" ) .. "]", encodeChar ), nil

    http.Encode = encode

    decodeChar = ( str ) ->
        return char( tonumber( str, 16 ) )

    decode = ( str ) ->
        return gsub( str, "%%(%x%x)", decodeChar ), nil

    http.Decode = decode

    http.ParseQueryValue = ( str ) ->
        tbl, length = {}, 0
        for value in gmatch( str, "\"(.-)\"" )
            length += 1
            tbl[ length ] = decode( value )

        return tbl, length

    http.ParseQuery = ( str ) ->
        result, length = {}, 0
        for key, value in gmatch( str, "([^&=?]-)=([^&=?]+)" )
            length += 1
            result[ length ] = { decode( key ), decode( value ) }

        return result, length

    queryKeySymbols = "%-%_%."
    queryValueSymbols = "%!%$%'%(%)%*%,%-%.%:%;%@%_%~"

    http.ListToQueryValue = ( lst ) ->
        length = #lst
        if length == 0
            return ""

        for index = 1, length
            lst[ index ] = "\"" .. encode( lst[ index ], queryValueSymbols ) .. "\""

        return "[" .. concat( lst, ",", 1, length ) .. "]"

    http.Query = ( query, length ) ->
        length = length or #query

        if length == 0
            return "", length

        if length == 1
            data = query[ length ]
            return "?" .. encode( data[ 1 ], queryKeySymbols ) .. "=" .. encode( data[ 2 ], queryValueSymbols ), length

        result = {}
        for index = 1, length
            data = query[ index ]
            result[ index ] = encode( data[ 1 ], queryKeySymbols ) .. "=" .. encode( data[ 2 ], queryValueSymbols )

        return "?" .. concat( result, "&", 1, length ), length

class util.Stack
    __tostring: =>
        return format( "Stack: %p [%d/%d]", @, @Pointer, @Length )

    new: ( length ) =>
        @Length = ( isnumber( length ) and length > 0 ) and length or -1
        @Pointer = 0

    isEmpty: =>
        return @Pointer == 0

    isFull: =>
        return @Pointer == @Length

    peek: =>
        return @[ @Pointer ]

    push: ( value ) =>
        pointer = @Pointer
        if pointer ~= @Length
            pointer += 1
            @[ pointer ] = value
            @Pointer = pointer

        return pointer

    pop: =>
        pointer = @Pointer
        if pointer ~= 0
            @Pointer = pointer - 1
            value = @[ pointer ]
            @[ pointer ] = nil
            return value

    empty: =>
        for index = 1, @Pointer
            @[ index ] = nil

        @Pointer = 0

do

    import abs, floor, ldexp from math
    import band, rshift from bit

    buffer = setmetatable( {}, { __mode: "v" } )
    boolean = { [ 0 ]: false, [ 1 ]: true }

    class util.ByteStream
        __tostring: =>
            return format( "ByteStream: %p [%d/%d]", @, @Pointer, @Length )

        new: ( data ) =>
            if isstring( data )
                @Length = len( data )
                @Data = data
            else
                @Length = 0
                @Data = ""

            @Pointer = 0

        Close: =>
            @Pointer = 0

        Flush: =>
            @Pointer = 0
            @Length = 0
            @Data = ""

        Size: =>
            return @Length

        Tell: =>
            return @Pointer

        Seek: ( pointer ) =>
            if pointer
                ArgAssert( pointer, 2, "number" )

                if pointer < 0
                    pointer = 0
                elseif pointer > @Length
                    pointer = @Length

            else
                pointer = 0

            @Pointer = pointer
            return pointer

        Skip: ( bytes ) =>
            if bytes
                ArgAssert( bytes, 2, "number" )
            else
                bytes = 1

            return @Seek( @Pointer + bytes )

        EndOfFile: =>
            return @Pointer >= @Length

        -- Binary data
        Read: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes <= 0 or @EndOfFile!
                return

            pointer = @Pointer
            @Skip( bytes )

            return sub( @Data, pointer + 1, pointer + bytes )

        Write: ( data ) =>
            length, size = @Length, len( data )
            @Data = sub( @Data, 1, @Pointer ) .. data .. sub( @Data, @Pointer + 1, length )
            @Length = length + size
            return @Skip( size )

        -- String
        ReadString: =>
            pointer, length = @Pointer, @Length
            if pointer >= length
                return

            bytes, data = 0, @Data
            for index = pointer, length
                if byte( data, index + 1 ) == 0
                    break

                bytes += 1

            if bytes == 0
                return

            return @Read( bytes ), @Skip( 1 )

        WriteString: ( str ) =>
            return @Write( str .. "\0" )

        -- Byte
        ReadByte: =>
            if @EndOfFile!
                return

            return byte( @Data, @Skip( 1 ) )

        WriteByte: ( number ) =>
            return @Write( char( number ) )

        -- Boolean
        ReadBool: =>
            return boolean[ @ReadByte! or -1 ]

        WriteBool: ( bool ) =>
            return @WriteByte( bool and 1 or 0 )

        -- UInt
        ReadUInt: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return

            uint = 0
            for index = 1, bytes
                number = @ReadByte!
                if number == nil
                    return

                uint += number * 0x100 ^ ( index - 1 )

            return uint

        WriteUInt: ( number, bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return @Pointer

            for index = 1, bytes
                buffer[ index ] = char( band( number, 0xFF ) )
                number = rshift( number, 8 )

            return @Write( concat( buffer, "", 1, bytes ) )

        -- UShort
        ReadUShort: =>
            return @ReadUInt( 2 )

        WriteUShort: ( number ) =>
            return @WriteUInt( number, 2 )

        -- ULong
        ReadULong: =>
            return @ReadUInt( 4 )

        WriteULong: ( number ) =>
            return @WriteUInt( number, 4 )

        -- UInt64
        ReadUInt64: =>
            return @ReadUInt( 8 )

        WriteUInt64: ( number ) =>
            @WriteUInt( number, 8 )

        -- Int
        ReadInt: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return

            uint = @ReadUInt( bytes )
            if uint == nil
                return

            max = 0x100 ^ abs( bytes )
            if uint >= ( max / 2 )
                return uint - max

            return uint

        WriteInt: ( number, bytes ) =>
            for index = 1, bytes
                buffer[ index ] = char( number % 0x100 )
                number = floor( number / 0x100 )

            return @Write( concat( buffer, "", 1, bytes ) )

        -- Short
        ReadShort: =>
            return @ReadInt( 2 )

        WriteShort: ( number ) =>
            return @WriteInt( number, 2 )

        -- Long
        ReadLong: =>
            return @ReadInt( 4 )

        WriteLong: ( number ) =>
            return @WriteInt( number, 4 )

        -- Int64
        ReadInt64: =>
            return @ReadInt( 8 )

        WriteInt64: ( number ) =>
            return @WriteInt( number, 8 )

        -- Float
        ReadFloat: =>
            binary = @Read( 4 )
            if not binary or len( binary ) ~= 4
                return

            byte1, byte2, byte3, byte4 = byte( binary, 1, 4 )
            exponent = byte4 % 0x80 * 2 + floor( byte3 / 0x80 ) - 0x7F
            if exponent == 0x7F
                return 0

            return ldexp( ldexp( byte3 % 0x80 * 0x10000 + byte2 * 0x100 + byte1, -23 ) + 1, exponent ) * ( byte4 < 0x80 and 1 or -1 )

util.Version = ( number ) ->
    if isstring( number )
        return number

    if isnumber( number )
        version = format( "%06d", number )
        return sub( version, 0, 2 ) .. "." .. sub( version, 3, 4 ) .. "." .. sub( version, 5 )

    return "unknown"

do

    import Simple from timer

    util.NextTick = ( func, a, b, c, d, e, f ) ->
        ArgAssert( func, 1, "function" )
        Simple 0, ->
            func( a, b, c, d, e, f )

do

    import Exists from file

    util.IsLuaModuleInstalled = ( name ) ->
        return Exists( "includes/modules/" .. name .. ".lua", "LUA" )

if SERVER

    import Fix, ReplaceExtension from gpm.path
    AddCSLuaFile = AddCSLuaFile
    import Find from file

    addCSLuaFolder = ( folderPath ) ->
        folderPath = Fix( folderPath .. "/" )

        files, folders = Find( folderPath .. "*", "lsv" )
        for folderName in *folders
            addCSLuaFolder( folderPath .. folderName )

        for fileName in *files
            AddCSLuaFile( folderPath .. ReplaceExtension( fileName, "lua" ) )

    util.AddCSLuaFolder = addCSLuaFolder

do

    Color = Color

    colors = Table gpm, "Colors", ->
        return {
            SecondaryText: Color( 150, 150, 150 )
            PrimaryText: Color( 200, 200, 200 )
            White: Color( 255, 255, 255 )
            Info: Color( 70, 135, 255 )
            Warn: Color( 255, 130, 90 )
            Error: Color( 250, 55, 40 )
            Debug: Color( 0, 200, 150 )
            gpm: Color( 180, 180, 255 )
        }

    :PrimaryText, :SecondaryText, :Info, :Warn, :Error, :Debug, :White = colors

    unless isstring( gpm.RealmName )
        if MENU_DLL
            gpm.RealmName, colors.Realm = "Menu", Color( 75, 175, 80 )
        elseif CLIENT
            gpm.RealmName, colors.Realm = "Client", Color( 225, 170, 10 )
        elseif SERVER
            gpm.RealmName, colors.Realm = "Server", Color( 5, 170, 250 )
        else
           gpm.RealmName, colors.Realm = "Unknown", White

    local log
    do

        import date from os
        MsgC = MsgC

        realmName = "[" .. string.upper( gpm.RealmName ) .. "] "
        realmColor = colors.Realm

        log = ( color, level, str, ... ) =>
            ArgAssert( color, 1, "Color" )
            ArgAssert( level, 2, "string" )
            MsgC( SecondaryText, date( "%d-%m-%Y %H:%M:%S " ), realmColor, realmName, color, level, SecondaryText, " --> ", @color, @name, SecondaryText, " : ", @text_color, format( str, ... ), "\n" )
            return

    debugFilter = ->
        return gpm.Developer > 0

    class Logger
        __tostring: =>
            return format( "Logger: %p [%s]", @, @name )

        new: ( name, color, func ) =>
            @name = isstring( name ) and name or "unknown"
            @color = iscolor( color ) and color or White
            @debug_filter = isfunction( func ) and func or debugFilter
            @text_color = PrimaryText

        -- Logger Name
        GetName: =>
            return @name

        SetName: ( str ) =>
            ArgAssert( str, 1, "string" )
            @name = str

        -- Logger Color
        GetColor: =>
            return @color

        SetColor: ( color ) =>
            ArgAssert( color, 1, "Color" )
            @color = color

        -- Logger Text Color
        GetTextColor: =>
            return @text_color

        SetTextColor: ( color ) =>
            ArgAssert( color, 1, "Color" )
            @text_color = color

        -- Logger Debug Filter
        GetDebugFilter: =>
            return @debug_filter

        SetDebugFilter: ( func ) =>
            ArgAssert( func, 1, "function" )
            @debug_filter = func

        -- Logger Functions
        Log: log

        Info: ( ... ) =>
            log( @, Info, " INFO ", ... )

        Warn: ( ... ) =>
            log( @, Warn, " WARN ", ... )

        Error: ( ... ) =>
            log( @, Error, "ERROR ", ... )

        Loaded: ( ... ) =>
            log( @, Debug, "LOADED", ... )

        Debug: ( ... ) =>
            if @debug_filter( ... )
                log( @, Debug, "DEBUG ", ... )

    gpm.Logger = Logger( "gpm@" .. gpm.VERSION, colors.gpm )
    util.Logger = Logger
