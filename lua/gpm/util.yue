setmetatable = setmetatable
isfunction = isfunction
isstring = isstring
isnumber = isnumber
istable = istable
error = error
pairs = pairs
gpm = gpm

Table = ( tbl, name, func, ... ) ->
    result = tbl[ name ]
    unless istable( result )
        if isfunction( func )
            result = func( ... )
        else
            result = {}

        tbl[ name ] = result

    return result

gpm.Table = Table

Names, Indexes = nil, nil
do

    types = Table gpm, "Types", -> {
        Indexes: {}
        Names: {
            [-1]: "unknown"
            [0]: "nil"
            [1]: "boolean"
            [2]: "light userdata"
            [3]: "number"
            [4]: "string"
            [5]: "table"
            [6]: "function"
            [7]: "userdata"
            [8]: "thread"
            [9]: "Entity"
            [10]: "Vector"
            [11]: "Angle"
            [12]: "PhysObj"
            [13]: "ISave"
            [14]: "IRestore"
            [15]: "CTakeDamageInfo"
            [16]: "CEffectData"
            [17]: "CMoveData"
            [18]: "CRecipientFilter"
            [19]: "CUserCmd"
            [21]: "IMaterial"
            [22]: "Panel"
            [23]: "CLuaParticle"
            [24]: "CLuaEmitter"
            [25]: "ITexture"
            [26]: "bf_read"
            [27]: "ConVar"
            [28]: "IMesh"
            [29]: "VMatrix"
            [30]: "CSoundPatch"
            [31]: "pixelvis_handle_t"
            [32]: "dlight_t"
            [33]: "IVideoWriter"
            [34]: "File"
            [35]: "CLuaLocomotion"
            [36]: "PathFollower"
            [37]: "CNavArea"
            [38]: "IGModAudioChannel"
            [39]: "CNavLadder"
            [40]: "CNewParticleEffect"
            [41]: "ProjectedTexture"
            [42]: "PhysCollide"
            [43]: "SurfaceInfo"
            [255]: "Color"
        }
    }

    :Names, :Indexes = types

do

    TYPE_USERDATA = TYPE_USERDATA
    TYPE_TABLE = TYPE_TABLE
    TypeID = TypeID

    id, data = nil, nil

    gpm_TypeID = ( any ) ->
        id = TypeID( any )
        if id == TYPE_TABLE or id == TYPE_USERDATA
            for index = 1, #Indexes
                data = Indexes[ index ]
                if data ~= nil and data[ 1 ]( any )
                    return data[ 2 ]

        return id

    gpm.TypeID = gpm_TypeID

    gpm.type = ( any ) ->
        return Names[ gpm_TypeID( any ) ] or "unknown"

string = Table gpm, "string", ->
    return setmetatable( {}, { __index: string } )

table = Table gpm, "table", ->
    return setmetatable( {}, { __index: table } )

math = Table gpm, "math", ->
    return setmetatable( {}, { __index: math } )

debug = Table gpm, "debug", ->
    return setmetatable( {}, { __index: debug } )

util = Table gpm, "util", ->
    return setmetatable( {}, { __index: util } )

string.StartsWith = string.StartsWith or string.StartWith

table.unpack = unpack

math.inf = 1 / 0
math.nan = 0 / 0

debug.fempty = ->

debug.fcall = ( func, ... ) ->
    return func( ... )

util.CompileMoonString = ->
    error( "Attempt to compile MoonScript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

util.CompileYueString = ->
    error( "Attempt to compile Yuescript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

do

    :match = string

    string.IsURL = ( str ) ->
        return match( str, "[a-z]+://[^ >,;]+" ) ~= nil

:sub, :format, :lower, :len = string
:concat, :remove = table
:getinfo = debug

split = nil
do

    :find = string

    explode = ( str, separator = " ", withPattern ) ->
        withPattern = withPattern ~= true
        result, length = {}, 0

        if len( separator ) == 0
            for index = 1, len( str )
                length += 1
                result[ length ] = sub( str, index, index )

            return result, length

        pointer = 1

        for index = 1, len( str )
            startPos, endPos = find( str, separator, pointer, withPattern )
            unless startPos
                break

            length += 1
            result[ length ] = sub( str, pointer, startPos - 1 )
            pointer = endPos + 1

        length += 1
        result[ length ] = sub( str, pointer )

        return result, length

    string.Explode = explode
    string.Split = explode
    split = explode

ArgAssert = nil
do

    :type = gpm

    ArgAssert = ( value, argNum, expected, errorlevel ) ->
        valueType = type( value )

        if valueType == expected
            return value

        elseif isfunction( expected )
            expected = expected( value, argNum, valueType )
            unless isstring( expected )
                return value

        elseif istable( expected )
            for index = 1, #expected
                if valueType == expected[ index ]
                    return value

            expected = "[ " .. concat( expected, ", " ) .. " ]"

        error( format( "bad argument #%d to \'%s\' (%s expected, got %s)", argNum, getinfo( 2, "n" ).name or "unknown", expected, valueType ), errorlevel or 3 )

    gpm.ArgAssert = ArgAssert

table.HasValue = ( tbl, any, isSequential ) ->
	if isSequential
		for index = 1, #tbl
			if tbl[ index ] == any
                return true

        return false

    for _, value in pairs( tbl )
        if value == any
            return true

	return false

table.RemoveByIValue = ( tbl, any ) ->
    for index = 1, #tbl
        if tbl[ index ] == any
            return remove( tbl, index )

table.GetValue = ( tbl, str, default ) ->
    keys, length = split( str, "." )
    for index = 1, length
        tbl = tbl[ keys[ index ] ]
        unless tbl
            return default

    return tbl

table.SetValue = ( tbl, str, value, ifEmpty ) ->
    keys, length = split( str, "." )
    for index = 1, length
        key = keys[ index ]
        if index == length
            oldValue = tbl[ key ]
            if oldValue ~= nil and ifEmpty
                return oldValue

            tbl[ key ] = value
            return value

        nextValue = tbl[ key ]
        if nextValue == nil
            tbl[ key ] = {}
        elseif not istable( nextValue )
            return

        tbl = tbl[ key ]

do

    Lower = ( tbl ) ->
        for key, value in pairs( tbl )
            if istable( value )
                value = Lower( value )

            if isstring( key )
                tbl[ lower( key ) ] = value
                tbl[ key ] = nil
            elseif istable( key )
                tbl[ Lower( key ) ] = value
                tbl[ key ] = nil

        return tbl

    table.Lower = Lower

table.RemoveByFunction = ( tbl, func ) ->
    result, length, fulfilled = {}, 0, false
    while fulfilled == false
        fulfilled = true

        for index = 1, #tbl
            if func( index, tbl[ index ] )
                length += 1
                fulfilled = false
                result[ length ] = remove( tbl, index )
                break

    return result, length

gpm.AddType = ( typeName, func ) ->
    ArgAssert( typeName, 1, "string" )
    ArgAssert( func, 2, "function" )

    nextIndex = 256
    for key, value in pairs( Names )
        if typeName == value
            nextIndex = key
            break
        elseif key >= nextIndex
            nextIndex = key + 1

    Names[ nextIndex ] = typeName

    length = #Indexes
    for index = 1, length
        data = Indexes[ index ]
        if data ~= nil and data[ 2 ] == nextIndex
            remove( Indexes, index )
            length -= 1
            break

    Indexes[ length + 1 ] = { func, nextIndex }
    return nextIndex

iscolor = nil
do

    getmetatable = getmetatable
    metatable = FindMetaTable( "Color" )

    iscolor = ( value ) ->
        if getmetatable( value ) == metatable
            return true

        if istable( value )
            return isnumber( value.r ) and isnumber( value.g ) and isnumber( value.b )

        return false

    gpm.AddType( "Color", iscolor )
    gpm.iscolor = iscolor

do

    path = Table( gpm, "path" )
    :gsub = string

    path_RemoveBackslash = ( filePath ) ->
        return gsub( filePath, "[/\\]?$", "" )

    path.RemoveBackslash = path_RemoveBackslash

    path_Fix = ( filePath ) ->
        return lower( path_RemoveBackslash( gsub( filePath, "[/\\]+", "/" ) ) )

    path.Fix = path_Fix

    path_Localize = ( filePath ) ->
        return gsub( gsub( gsub( filePath, "^cache/[%w%-_]/", "" ), "^addons/[%w%-_]-/", "" ), "^lua/", "" )

    path.Localize = path_Localize

    path.Join = ( ... ) ->
        return path_Fix( concat( { ... }, "/" ) )

    do

        :StripExtension = string

        path.ReplaceExtension = ( filePath, newExtension ) ->
            return StripExtension( filePath ) .. "." .. newExtension

    path.Resolve = ( filePath ) ->
        segments, segmentsCount = split( filePath, "[/\\]+", true )
        result, length = {}, 0

        for index = 1, segmentsCount
            segment = segments[ index ]
            if segment == "."
                continue

            if segment == ".."
                if length ~= 0
                    remove( result )
                    length -= 1

                continue

            length += 1
            result[ length ] = segment

        if length == 0
            return ""

        return concat( result, "/" )

    getfmain = ->
        for level = 2, 16
            info = getinfo( level, "fS" )
            unless info
                break

            if info.what == "main"
                return info.func

    debug.getfmain = getfmain

    getfpathi = ( level ) ->
        info = getinfo( level, "S" )
        if info.what == "main"
            return path_Localize( path_Fix( sub( info.source, 2 ) ) )

    debug.getfpathi = getfpathi

    debug.getfpath = ->
        main = getfmain!
        if main
            return getfpathi( main )

class util.Stack
    __tostring: =>
        return format( "Stack: %p [%d/%d]", @, @Pointer, @Length )

    new: ( length ) =>
        @Length = ( isnumber( length ) and length > 0 ) and length or -1
        @Pointer = 0

    isEmpty: =>
        return @Pointer == 0

    isFull: =>
        return @Pointer == @Length

    peek: =>
        return @[ @Pointer ]

    push: ( value ) =>
        pointer = @Pointer
        if pointer ~= @Length
            pointer += 1
            @[ pointer ] = value
            @Pointer = pointer

        return pointer

    pop: =>
        pointer = @Pointer
        if pointer ~= 0
            @Pointer = pointer - 1
            value = @[ pointer ]
            @[ pointer ] = nil
            return value

    empty: =>
        for index = 1, @Pointer
            @[ index ] = nil

        @Pointer = 0

do

    :abs, :floor, :ldexp = math
    :byte, :char = string
    :band, :rshift = bit

    buffer = setmetatable( {}, { __mode: "v" } )
    boolean = { [ 0 ]: false, [ 1 ]: true }

    class util.ByteStream
        __tostring: =>
            return format( "ByteStream: %p [%d/%d]", @, @Pointer, @Length )

        new: ( data ) =>
            if isstring( data )
                @Length = len( data )
                @Data = data
            else
                @Length = 0
                @Data = ""

            @Pointer = 0

        Close: =>
            @Pointer = 0

        Flush: =>
            @Pointer = 0
            @Length = 0
            @Data = ""

        Size: =>
            return @Length

        Tell: =>
            return @Pointer

        Seek: ( pointer ) =>
            if pointer
                ArgAssert( pointer, 2, "number" )

                if pointer < 0
                    pointer = 0
                elseif pointer > @Length
                    pointer = @Length

            else
                pointer = 0

            @Pointer = pointer
            return pointer

        Skip: ( bytes ) =>
            if bytes
                ArgAssert( bytes, 2, "number" )
            else
                bytes = 1

            return @Seek( @Pointer + bytes )

        EndOfFile: =>
            return @Pointer >= @Length

        -- Binary data
        Read: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes <= 0 or @EndOfFile!
                return

            pointer = @Pointer
            @Skip( bytes )

            return sub( @Data, pointer + 1, pointer + bytes )

        Write: ( data ) =>
            length, size = @Length, len( data )
            @Data = sub( @Data, 1, @Pointer ) .. data .. sub( @Data, @Pointer + 1, length )
            @Length = length + size
            return @Skip( size )

        -- String
        ReadString: =>
            pointer, length = @Pointer, @Length
            if pointer >= length
                return

            len, data = 0, @Data
            for index = pointer, length
                if byte( data, index + 1 ) == 0
                    break

                len += 1

            if len == 0
                return

            return @Read( len ), @Skip( 1 )

        WriteString: ( str ) =>
            return @Write( str .. "\0" )

        -- Byte
        ReadByte: =>
            if @EndOfFile!
                return

            return byte( @Data, @Skip( 1 ) )

        WriteByte: ( number ) =>
            return @Write( char( number ) )

        -- Boolean
        ReadBool: =>
            return boolean[ @ReadByte! or -1 ]

        WriteBool: ( bool ) =>
            @WriteByte( bool and 1 or 0 )

        -- UInt
        ReadUInt: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return

            uint = 0
            for index = 1, bytes
                number = @ReadByte!
                if number == nil
                    return

                uint += number * 0x100 ^ ( index - 1 )

            return uint

        WriteUInt: ( number, bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return @Pointer

            for index = 1, bytes
                buffer[ index ] = char( band( number, 0xFF ) )
                number = rshift( number, 8 )

            return @Write( concat( buffer, "", 1, bytes ) )

        -- UShort
        ReadUShort: =>
            return @ReadUInt( 2 )

        WriteUShort: ( number ) =>
            return @WriteUInt( number, 2 )

        -- ULong
        ReadULong: =>
            return @ReadUInt( 4 )

        WriteULong: ( number ) =>
            return @WriteUInt( number, 4 )

        -- UInt64
        ReadUInt64: =>
            return @ReadUInt( 8 )

        WriteUInt64: ( number ) =>
            @WriteUInt( number, 8 )

        -- Int
        ReadInt: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return

            uint = @ReadUInt( bytes )
            if uint == nil
                return

            max = 0x100 ^ abs( bytes )
            if uint >= ( max / 2 )
                return uint - max

            return uint

        WriteInt: ( number, bytes ) =>
            for index = 1, bytes
                buffer[ index ] = char( number % 0x100 )
                number = floor( number / 0x100 )

            return @Write( concat( buffer, "", 1, bytes ) )

        -- Short
        ReadShort: =>
            return @ReadInt( 2 )

        WriteShort: ( number ) =>
            return @WriteInt( number, 2 )

        -- Long
        ReadLong: =>
            return @ReadInt( 4 )

        WriteLong: ( number ) =>
            return @WriteInt( number, 4 )

        -- Int64
        ReadInt64: =>
            return @ReadInt( 8 )

        WriteInt64: ( number ) =>
            return @WriteInt( number, 8 )

        -- Float
        ReadFloat: =>
            binary = @Read( 4 )
            if not binary or len( binary ) ~= 4
                return

            byte1, byte2, byte3, byte4 = byte( binary, 1, 4 )
            exponent = byte4 % 0x80 * 2 + floor( byte3 / 0x80 ) - 0x7F
            if exponent == 0x7F
                return 0

            return ldexp( ldexp( byte3 % 0x80 * 0x10000 + byte2 * 0x100 + byte1, -23 ) + 1, exponent ) * ( byte4 < 0x80 and 1 or -1 )

do

    tonumber = tonumber

    util.Version = ( number ) ->
        if isstring( number )
            return number

        if isnumber( number )
            version = format( "%06d", number )
            return format( "%d.%d.%d", tonumber( sub( version, 0, 2 ) ), tonumber( sub( version, 3, 4 ) ), tonumber( sub( version, 5 ) ) )

        return "unknown"

do

    :Simple = timer

    util.NextTick = ( func, a, b, c, d, e, f ) ->
        ArgAssert( func, 1, "function" )
        Simple 0, ->
            func( a, b, c, d, e, f )

do

    :Exists = file

    util.IsLuaModuleInstalled = ( name ) ->
        return Exists( "includes/modules/" .. name .. ".lua", "LUA" )

do

    Color = Color

    colors = Table gpm, "Colors", ->
        return {
            SecondaryText: Color( 150, 150, 150 )
            PrimaryText: Color( 200, 200, 200 )
            White: Color( 255, 255, 255 )
            Info: Color( 70, 135, 255 )
            Warn: Color( 255, 130, 90 )
            Error: Color( 250, 55, 40 )
            Debug: Color( 0, 200, 150 )
            gpm: Color( 180, 180, 255 )
        }

    :PrimaryText, :SecondaryText, :Info, :Warn, :Error, :Debug, :Realm, :White = colors
    :RealmName = gpm

    unless isstring( RealmName )
        RealmName, Realm = "Unknown", White

        if MENU_DLL
            RealmName, Realm = "Menu", Color( 75, 175, 80 )
        elseif CLIENT
            RealmName, Realm = "Client", Color( 225, 170, 10 )
        elseif SERVER
            RealmName, Realm = "Server", Color( 5, 170, 250 )

        gpm.RealmName, colors.Realm = RealmName, Realm

    log = nil
    do

        RealmName = "[" .. string.upper( RealmName ) .. "] "
        select = select
        MsgC = MsgC
        :date = os

        log = ( color, level, str, ... ) =>
            ArgAssert( color, 1, "Color" )
            ArgAssert( level, 2, "string" )

            if select( "#", ... ) > 0
                str = format( str, ... )

            MsgC( SecondaryText, date( "%d-%m-%Y %H:%M:%S " ), Realm, RealmName, color, level, SecondaryText, " --> ", @Color, @Name, SecondaryText, " : ", @TextColor, str, "\n" )

    debugFilter = ->
        return gpm.Developer > 0

    class Logger
        __tostring: =>
            return format( "Logger: %p [%s]", @, @Name )

        new: ( name, color, func ) =>
            @Name = isstring( name ) and name or "unknown"
            @Color = iscolor( color ) and color or White
            @DebugFilter = isfunction( func ) and func or debugFilter
            @TextColor = PrimaryText

        -- Logger Name
        GetName: =>
            return @Name

        SetName: ( str ) =>
            ArgAssert( str, 1, "string" )
            @Name = str

        -- Logger Color
        GetColor: =>
            return @Color

        SetColor: ( color ) =>
            ArgAssert( color, 1, "Color" )
            @Color = color

        -- Logger Text Color
        GetTextColor: =>
            return @TextColor

        SetTextColor: ( color ) =>
            ArgAssert( color, 1, "Color" )
            @TextColor = color

        -- Logger Debug Filter
        GetDebugFilter: =>
            return @DebugFilter

        SetDebugFilter: ( func ) =>
            ArgAssert( func, 1, "function" )
            @DebugFilter = func

        -- Logger Functions
        Log: log

        Info: ( ... ) =>
            log( @, Info, "INFO ", ... )

        Warn: ( ... ) =>
            log( @, Warn, "WARN ", ... )

        Error: ( ... ) =>
            log( @, Error, "ERROR", ... )

        Debug: ( ... ) =>
            if @DebugFilter( ... )
                log( @, Debug, "DEBUG", ... )

    gpm.Logger = Logger( "gpm@" .. gpm.VERSION, colors.gpm )
    util.Logger = Logger
