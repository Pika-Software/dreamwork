setmetatable = setmetatable
isfunction = isfunction
isstring = isstring
isnumber = isnumber
istable = istable
error = error
gpm = gpm

gpm_Table = ( tbl, name, func, ... ) ->
    result = tbl[ name ]
    unless istable( result )
        if isfunction( func )
            result = func( ... )
        else
            result = {}

        tbl[ name ] = result

    return result

gpm.Table = gpm_Table

Names, Indexes = nil, nil
do

    types = gpm_Table gpm, "Types", -> {
        Indexes: {}
        Names: {
            [-1]: "unknown"
            [0]: "nil"
            [1]: "boolean"
            [2]: "light userdata"
            [3]: "number"
            [4]: "string"
            [5]: "table"
            [6]: "function"
            [7]: "userdata"
            [8]: "thread"
            [9]: "Entity"
            [10]: "Vector"
            [11]: "Angle"
            [12]: "PhysObj"
            [13]: "ISave"
            [14]: "IRestore"
            [15]: "CTakeDamageInfo"
            [16]: "CEffectData"
            [17]: "CMoveData"
            [18]: "CRecipientFilter"
            [19]: "CUserCmd"
            [21]: "IMaterial"
            [22]: "Panel"
            [23]: "CLuaParticle"
            [24]: "CLuaEmitter"
            [25]: "ITexture"
            [26]: "bf_read"
            [27]: "ConVar"
            [28]: "IMesh"
            [29]: "VMatrix"
            [30]: "CSoundPatch"
            [31]: "pixelvis_handle_t"
            [32]: "dlight_t"
            [33]: "IVideoWriter"
            [34]: "File"
            [35]: "CLuaLocomotion"
            [36]: "PathFollower"
            [37]: "CNavArea"
            [38]: "IGModAudioChannel"
            [39]: "CNavLadder"
            [40]: "CNewParticleEffect"
            [41]: "ProjectedTexture"
            [42]: "PhysCollide"
            [43]: "SurfaceInfo"
            [255]: "Color"
        }
    }

    :Names, :Indexes = types

do

    TYPE_USERDATA = TYPE_USERDATA
    TYPE_TABLE = TYPE_TABLE
    TypeID = TypeID

    data = nil

    gpm_TypeID = ( any ) ->
        index = TypeID( any )
        if index == TYPE_TABLE or index == TYPE_USERDATA
            for index = 1, #Indexes
                data = Indexes[ index ]
                if data ~= nil and data[ 1 ]( any )
                    return data[ 2 ]

        return index

    gpm.TypeID = gpm_TypeID

    gpm.type = ( any ) ->
        return Names[ gpm_TypeID( any ) ] or "unknown"

string = gpm_Table gpm, "string", ->
    return setmetatable( {}, { __index: string } )

table = gpm_Table gpm, "table", ->
    return setmetatable( {}, { __index: table } )

math = gpm_Table gpm, "math", ->
    return setmetatable( {}, { __index: math } )

debug = gpm_Table gpm, "debug", ->
    return setmetatable( {}, { __index: debug } )

util = gpm_Table gpm, "util", ->
    return setmetatable( {}, { __index: util } )

string.StartsWith = string.StartsWith or string.StartWith

table.unpack = unpack

math.inf = 1 / 0
math.nan = 0 / 0

debug.fempty = ->

debug.fcall = ( func, ... ) ->
    return func( ... )

util.CompileMoonString = ->
    error( "Attempt to compile MoonScript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

util.CompileYueString = ->
    error( "Attempt to compile Yuescript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

do

    :match = string

    string.IsURL = ( str ) ->
        return match( str, "[a-z]+://[^ >,;]+" ) ~= nil

:sub, :format, :lower, :GetExtensionFromFilename, :Split = string
:concat, :remove = table
:getinfo = debug

ArgAssert = nil
do

    :type = gpm

    ArgAssert = ( value, argNum, expected, errorlevel ) ->
        valueType = type( value )

        if valueType == expected
            return value

        elseif isfunction( expected )
            expected = expected( value, argNum, valueType )
            unless isstring( expected )
                return value

        elseif istable( expected )
            for index = 1, #expected
                if valueType == expected[ index ]
                    return value

            expected = "[ " .. concat( expected, ", " ) .. " ]"

        error( format( "bad argument #%d to \'%s\' (%s expected, got %s)", argNum, getinfo( 2, "n" ).name or "unknown", expected, valueType ), errorlevel or 3 )

    gpm.ArgAssert = ArgAssert

table.HasIValue = ( tbl, any ) ->
    for value in *tbl
        if value == any
            return true

    return false

table.RemoveByIValue = ( tbl, any ) ->
    for index = 1, #tbl
        if tbl[ index ] == any
            return remove( tbl, index )

table.GetValue = ( tbl, str, default ) ->
    for key in *Split( str, "." )
        tbl = tbl[ key ]
        unless tbl
            return default

    return tbl

table.SetValue = ( tbl, str, value, ifEmpty ) ->
    keys = Split( str, "." )
    length = #keys

    for index = 1, length
        key = keys[ index ]
        if index == length then
            oldValue = tbl[ key ]
            if oldValue ~= nil and ifEmpty
                return oldValue

            tbl[ key ] = value
            return value

        nextValue = tbl[ key ]
        if nextValue == nil
            tbl[ key ] = {}
        elseif not istable( nextValue )
            return

        tbl = tbl[ key ]

do

    table_Lower = ( tbl ) ->
        for key, value in pairs( tbl )
            if istable( value )
                value = table_Lower( value )

            if isstring( key )
                tbl[ lower( key ) ] = value
                tbl[ key ] = nil
            elseif istable( key )
                tbl[ table_Lower( key ) ] = value
                tbl[ key ] = nil

        return tbl

    table.Lower = table_Lower

do

    length, fulfilled = 0, false

    table.RemoveByFunction = ( tbl, func ) ->
        result, length, fulfilled = {}, 0, false
        while fulfilled == false
            fulfilled = true

            for index = 1, #tbl
                if func( index, tbl[ index ] )
                    length += 1
                    fulfilled = false
                    result[ length ] = remove( tbl, index )
                    break

        return result, length

addType = nil
do

    data = nil

    addType = ( typeName, func ) ->
        ArgAssert( typeName, 1, "string" )
        ArgAssert( func, 2, "function" )

        nextIndex = 256
        for key, value in pairs( Names )
            if typeName == value
                nextIndex = key
                break
            elseif key >= nextIndex
                nextIndex = key + 1

        Names[ nextIndex ] = typeName

        length = #Indexes
        for index = 1, length
            data = Indexes[ index ]
            if data ~= nil and data[ 2 ] == nextIndex
                remove( Indexes, index )
                length -= 1
                break

        Indexes[ length + 1 ] = { func, nextIndex }
        return nextIndex

    gpm.AddType = addType

iscolor = nil
do

    getmetatable = getmetatable
    metatable = getmetatable( color_white )

    iscolor = ( value ) ->
        if getmetatable( value ) == metatable
            return true

        if istable( value )
            return isnumber( value.r ) and isnumber( value.g ) and isnumber( value.b )

        return false

    addType( "Color", iscolor )
    gpm.iscolor = iscolor

do

    path = gpm_Table( gpm, "path" )
    :gsub = string

    path_RemoveBackslash = ( filePath ) ->
        return gsub( filePath, "[/\\]?$", "" )

    path.RemoveBackslash = path_RemoveBackslash

    path_Fix = ( filePath ) ->
        return lower( path_RemoveBackslash( gsub( filePath, "[/\\]+", "/" ) ) )

    path.Fix = path_Fix

    path_Localize = ( filePath ) ->
        return gsub( gsub( gsub( filePath, "^cache/[%w%-_]/", "" ), "^addons/[%w%-_]-/", "" ), "^lua/", "" )

    path.Localize = path_Localize

    path.Join = ( ... ) ->
        return path_Fix( concat( { ... }, "/" ) )

    do

        :StripExtension = string

        path.ReplaceExtension = ( filePath, newExtension ) ->
            return StripExtension( filePath ) .. "." .. newExtension

    do

        result, length = {}, 0

        path.Resolve = ( filePath ) ->
            for index = 1, length
                result[ index ] = nil
            length = 0

            for segment in *Split( filePath, "/" )
                if #segment == 0 or segment == "."
                    continue

                if segment == ".."
                    remove( result )
                    length -= 1
                    continue

                length += 1
                result[ length ] = segment

            return concat( result, "/" )

    debug.getfpath = ->
        for i = 2, 16
            info = getinfo( i, "S" )
            unless info
                break

            if info.what == "main"
                return path_Localize( path_Fix( info.short_src ) )

class util.Stack
    __tostring: =>
        return format( "Stack: %p [%d/%d]", @, @Pointer, @Length )

    new: ( length ) =>
        @Length = ( isnumber( length ) and length > 0 ) and length or -1
        @Pointer = 0

    isEmpty: =>
        return @Pointer == 0

    isFull: =>
        return @Pointer == @Length

    peek: =>
        return @[ @Pointer ]

    push: ( value ) =>
        pointer = @Pointer
        if pointer ~= @Length
            pointer += 1
            @[ pointer ] = value
            @Pointer = pointer

        return pointer

    pop: =>
        pointer = @Pointer
        if pointer ~= 0
            @Pointer = pointer - 1
            value = @[ pointer ]
            @[ pointer ] = nil
            return value

    empty: =>
        for index = 1, @Pointer
            @[ index ] = nil

        @Pointer = 0

do

    :byte = string
    :abs = math

    class util.ByteStream
        __tostring: =>
            return format( "ByteStream: %p [%d/%d]", @, @Pointer, @Size )

        new: ( data ) =>
            @Length = #data
            @Data = data
            @Pointer = 0

        Close: =>
            @Pointer = 0
            @Length = 0
            @Data = ""

        Size: =>
            return @Length

        Tell: =>
            return @Pointer

        Seek: ( position ) =>
            if position
                ArgAssert( position, 2, "number" )
                if position < 0
                    position = 0

            else
                position = 0

            @Pointer = position
            return position

        Skip: ( length ) =>
            if length
                ArgAssert( length, 2, "number" )
            else
                length = 1

            return @Seek( @Pointer + length )

        EndOfFile: =>
            return @Pointer >= @Length

        ReadByte: =>
            unless @EndOfFile!
                return byte( @Data, @Skip( 1 ) )

        ReadBool: =>
            int = @ReadByte!
            if int ~= nil
                return int ~= 0

        Read: ( distance ) =>
            ArgAssert( distance, 2, "number" )
            if distance <= 0 or @EndOfFile!
                return

            startPos = @Pointer
            @Skip( distance )

            return sub( @Data, startPos + 1, startPos + distance )

        ReadUInt: ( distance ) =>
            ArgAssert( distance, 2, "number" )
            if distance == 0
                return

            uint = 0
            for i = 1, distance
                int = @ReadByte!
                unless int
                    return

                uint += int * 0x100 ^ ( i - 1 )

            return uint

        ReadUShort: =>
            return @ReadUInt( 2 )

        ReadULong: =>
            return @ReadUInt( 4 )

        ReadUInt64: =>
            return @ReadUInt( 8 )

        ReadInt: ( distance ) =>
            ArgAssert( distance, 2, "number" )
            if distance == 0
                return

            uint = @ReadUInt( distance )
            unless uint
                return

            max = 0x100 ^ abs( distance )
            if uint >= ( max / 2 )
                return uint - max

            return uint

        ReadShort: =>
            return @ReadInt( 2 )

        ReadLong: =>
            return @ReadInt( 4 )

        ReadInt64: =>
            return @ReadInt( 8 )

        ReadString: =>
            pointer, length = @Pointer, @Length
            if pointer >= length
                return

            len, data = 0, @Data
            for index = pointer, length
                if byte( data, index + 1 ) == 0
                    break

                len += 1

            if len == 0
                return

            return @Read( len ), @Skip( 1 )

do

    tonumber = tonumber

    util.Version = ( number ) ->
        if isstring( number )
            return number

        if isnumber( number )
            version = format( "%06d", number )
            return format( "%d.%d.%d", tonumber( sub( version, 0, 2 ) ), tonumber( sub( version, 3, 4 ) ), tonumber( sub( version, 5 ) ) )

        return "unknown"

do

    :Simple = timer

    util.NextTick = ( func, a, b, c, d, e, f ) ->
        ArgAssert( func, 1, "function" )
        Simple 0, ->
            func( a, b, c, d, e, f )

do

    :Exists = file

    util.IsLuaModuleInstalled = ( name ) ->
        return Exists( "includes/modules/" .. name .. ".lua", "LUA" )

    isWindows, isLinux = system.IsWindows!, system.IsLinux!
    jit_versionnum, jit_arch = jit.versionnum, jit.arch

    suffix = ( { "osx64", "osx", "linux64", "linux", "win64", "win32" } )[ ( isWindows and 4 or 0 ) + ( isLinux and 2 or 0 ) + ( jit_arch == "x86" and 1 or 0 ) + 1 ]
    fmt = "lua/bin/gm" .. ( ( CLIENT and not MENU_DLL ) and "cl" or "sv" ) .. "_%s_%s.dll"

    util.IsBinaryModuleInstalled = ( name ) ->
        ArgAssert( name, 1, "string" )

        if Exists( format( fmt, name, suffix ), "GAME" )
            return true

        if jit_versionnum ~= 20004 and jit_arch == "x86" and isLinux
            return Exists( format( fmt, name, "linux32" ), "GAME" )

        return false

do

    Color = Color

    colors = gpm_Table gpm, "Colors", ->
        return {
            SecondaryText: Color( 150, 150, 150 )
            PrimaryText: Color( 200, 200, 200 )
            White: Color( 255, 255, 255 )
            Info: Color( 70, 135, 255 )
            Warn: Color( 255, 130, 90 )
            Error: Color( 250, 55, 40 )
            Debug: Color( 0, 200, 150 )
            gpm: Color( 180, 180, 255 )
        }

    :PrimaryText, :SecondaryText, :Info, :Warn, :Error, :Debug, :Realm, :White = colors
    :RealmName = gpm

    unless isstring( RealmName )
        RealmName, Realm = "Unknown", White

        if MENU_DLL
            RealmName, Realm = "Menu", Color( 75, 175, 80 )
        elseif CLIENT
            RealmName, Realm = "Client", Color( 225, 170, 10 )
        elseif SERVER
            RealmName, Realm = "Server", Color( 5, 170, 250 )

        gpm.RealmName, colors.Realm = RealmName, Realm

    log = nil
    do

        RealmName = "[" .. string.upper( RealmName ) .. "] "
        select = select
        MsgC = MsgC
        :date = os

        log = ( color, level, str, ... ) =>
            ArgAssert( color, 1, "Color" )
            ArgAssert( level, 2, "string" )

            if select( "#", ... ) > 0
                str = format( str, ... )

            MsgC( SecondaryText, date( "%d-%m-%Y %H:%M:%S " ), Realm, RealmName, color, level, SecondaryText, " --> ", @Color, @Name, SecondaryText, " : ", @TextColor, str, "\n" )

    debugFilter = ->
        return gpm.Developer > 0

    class Logger
        __tostring: =>
            return format( "Logger: %p [%s]", @, @Name )

        new: ( name, color, func ) =>
            @Name = isstring( name ) and name or "unknown"
            @Color = iscolor( color ) and color or White
            @DebugFilter = isfunction( func ) and func or debugFilter
            @TextColor = PrimaryText

        -- Logger Name
        GetName: =>
            return @Name

        SetName: ( str ) =>
            ArgAssert( str, 1, "string" )
            @Name = str

        -- Logger Color
        GetColor: =>
            return @Color

        SetColor: ( color ) =>
            ArgAssert( color, 1, "Color" )
            @Color = color

        -- Logger Text Color
        GetTextColor: =>
            return @TextColor

        SetTextColor: ( color ) =>
            ArgAssert( color, 1, "Color" )
            @TextColor = color

        -- Logger Debug Filter
        GetDebugFilter: =>
            return @DebugFilter

        SetDebugFilter: ( func ) =>
            ArgAssert( func, 1, "function" )
            @DebugFilter = func

        -- Logger Functions
        Log: log

        Info: ( ... ) =>
            log( @, Info, "INFO ", ... )

        Warn: ( ... ) =>
            log( @, Warn, "WARN ", ... )

        Error: ( ... ) =>
            log( @, Error, "ERROR", ... )

        Debug: ( ... ) =>
            if @DebugFilter( ... )
                log( @, Debug, "DEBUG", ... )

    gpm.Logger = Logger( "gpm@" .. gpm.VERSION, colors.gpm )
    util.Logger = Logger
