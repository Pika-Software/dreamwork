MENU_DLL = MENU_DLL
CLIENT = CLIENT

setmetatable = setmetatable
isfunction = isfunction
isstring = isstring
isnumber = isnumber
istable = istable
ipairs = ipairs
error = error
gpm = gpm

gpm_Table = ( tbl, name, func, ... ) ->
    result = tbl[ name ]
    unless istable( result )
        if func
            result = func( ... )
        else
            result = {}
        tbl[ name ] = result
    return result
gpm.Table = gpm_Table

types = gpm_Table( gpm, "Types", ->
    return {
        Indexes: {}
        Names: {
            [-1]: "unknown"
            [0]: "nil"
            [1]: "boolean"
            [2]: "light userdata"
            [3]: "number"
            [4]: "string"
            [5]: "table"
            [6]: "function"
            [7]: "userdata"
            [8]: "thread"
            [9]: "Entity"
            [10]: "Vector"
            [11]: "Angle"
            [12]: "PhysObj"
            [13]: "ISave"
            [14]: "IRestore"
            [15]: "CTakeDamageInfo"
            [16]: "CEffectData"
            [17]: "CMoveData"
            [18]: "CRecipientFilter"
            [19]: "CUserCmd"
            [21]: "IMaterial"
            [22]: "Panel"
            [23]: "CLuaParticle"
            [24]: "CLuaEmitter"
            [25]: "ITexture"
            [26]: "bf_read"
            [27]: "ConVar"
            [28]: "IMesh"
            [29]: "VMatrix"
            [30]: "CSoundPatch"
            [31]: "pixelvis_handle_t"
            [32]: "dlight_t"
            [33]: "IVideoWriter"
            [34]: "File"
            [35]: "CLuaLocomotion"
            [36]: "PathFollower"
            [37]: "CNavArea"
            [38]: "IGModAudioChannel"
            [39]: "CNavLadder"
            [40]: "CNewParticleEffect"
            [41]: "ProjectedTexture"
            [42]: "PhysCollide"
            [43]: "SurfaceInfo"
            [255]: "Color"
        }
    } )

typeNames = types.Names
indexes = types.Indexes

gpm_type = nil
do

    TYPE_USERDATA = TYPE_USERDATA
    TYPE_TABLE = TYPE_TABLE
    TypeID = TypeID

    gpm_TypeID = ( any ) ->
        id = TypeID any
        if id == TYPE_TABLE or id == TYPE_USERDATA
            for data in *indexes
                unless data[ 1 ]( any )
                    continue
                return data[ 2 ]
        return id
    gpm.TypeID = gpm_TypeID

    gpm_type = ( any ) ->
        return typeNames[ gpm_TypeID( any ) ] or "unknown"
    gpm.type = gpm_type

string = gpm_Table( gpm, "string", ->
    return setmetatable( {}, { __index: string } )
)

string.StartsWith = string.StartsWith or string.StartWith
string.GetPathFromFilename = string.GetPathFromFilename

do
    string_match = string.match
    string.IsURL = ( str ) ->
        if string_match( str, "[a-z]+://[^ >,;]+" ) ~= nil
            return true
        return false

string_GetExtensionFromFilename = string.GetExtensionFromFilename
string_format = string.format
string_lower = string.lower
string_sub = string.sub

string_GetFilenameWithoutExtensionFromFilename = ( str ) ->
    extension = string_GetExtensionFromFilename( str )
    unless extension
        return str
    return string_sub( str, 1, #str - ( #extension + 1 ) )
string.GetFilenameWithoutExtensionFromFilename = string_GetFilenameWithoutExtensionFromFilename

debug = gpm_Table( gpm, "debug", ->
    return setmetatable( {}, { __index: debug } )
)

debug.fempty = ->
debug.fcall = ( func, ... ) ->
    return func( ... )
debug_getinfo = debug.getinfo

ArgAssert = ( value, argNum, expected, errorlevel ) ->
    valueType = gpm_type( value )

    if istable( expected )
        str, len = "[ ", #expected
        for index = 1, len
            typeName = expected[ index ]

            if valueType == typeName
                return value
            elseif index ~= len
                str = str .. typeName .. ", "

        expected = str .. " ]"
    elseif isfunction( expected )
        expected = expected( value, argNum )
        unless isstring( expected )
            return value
    elseif valueType == expected
        return value

    dinfo = debug_getinfo( 2, "n" )
    error( string_format( "bad argument #%d to \'%s\' (%s expected, got %s)", argNum, dinfo and dinfo.name or "func", expected, valueType ), errorlevel or 3 )
gpm.ArgAssert = ArgAssert

table = gpm_Table( gpm, "table", ->
    return setmetatable( {}, { __index: table } )
)

table.HasIValue = ( tbl, any ) ->
    for value in *tbl
        if value == any
            return true
    return false

table_remove = table.remove
table.RemoveByIValue = ( tbl, any ) ->
    for index, value in ipairs( tbl )
        if value == any
            return table_remove( tbl, index )

string_Split = string.Split
table.Lookup = ( tbl, str, default ) ->
    for key in *string_Split( str, "." )
        tbl = tbl[ key ]
        unless tbl
            return default
    return tbl

table.SetValue = ( tbl, str, value, ifEmpty ) ->
    keys = string_Split( str, "." )
    len = #keys

    for index = 1, len
        key = keys[ index ]
        if index == len then
            oldValue = tbl[ key ]
            if oldValue ~= nil and ifEmpty
                return oldValue

            tbl[ key ] = value
            return value

        nextValue = tbl[ key ]
        if nextValue == nil
            tbl[ key ] = {}
        elseif not istable( nextValue )
            return

        tbl = tbl[ key ]

table_Lower = ( tbl ) ->
    for key, value in pairs( tbl )
        if istable( value )
            value = table_Lower( value )

        if isstring( key )
            tbl[ string_lower( key ) ] = value
            tbl[ key ] = nil
        elseif istable( key )
            tbl[ table_Lower( key ) ] = value
            tbl[ key ] = nil

    return tbl
table.Lower = table_Lower

table.RemoveByFunction = ( tbl, func ) ->
    result, fulfilled = {}, false
    while not fulfilled
        fulfilled = true

        for index, value in ipairs( tbl )
            if func( index, value )
                result[ #result + 1 ] = table.remove( tbl, index )
                fulfilled = false
                break

    return result

table.unpack = unpack

gpm_AddType = ( typeName, func ) ->
    ArgAssert( typeName, 1, "string" )
    ArgAssert( func, 2, "function" )

    nextIndex = 256
    for key, name in pairs( typeNames )
        if typeName == name
            nextIndex = key
            break
        elseif key >= nextIndex
            nextIndex = key + 1
    typeNames[ nextIndex ] = typeName

    for index, data in ipairs( indexes )
        if nextIndex == data[ 2 ]
            table_remove( indexes, index )
            break

    indexes[] = { func, nextIndex }
    return nextIndex
gpm.AddType = gpm_AddType

getmetatable = getmetatable

gpm_IsColor = nil
do

    meta = FindMetaTable( "Color" )

    gpm_IsColor = ( any ) ->
        if getmetatable( any ) == meta
            return true
        elseif istable( any )
            return isnumber( any.r ) and isnumber( any.g ) and isnumber( any.b )
        return false
    gpm_AddType( "Color", gpm_IsColor )
    gpm.IsColor = gpm_IsColor

path = gpm_Table( gpm, "path" )
string_gsub = string.gsub

path_Fix = ( filePath ) ->
    return string_lower( string_gsub( filePath, "[/\\]+", "/" ) )
path.Fix = path_Fix

path.Join = ( ... ) ->
    arguments, filePath = { ... }, nil
    length = #arguments

    for index = 1, length
        if filePath ~= nil
            filePath ..= arguments[ index ]
        else
            filePath = arguments[ index ]
        if index == length
            return path_Fix( filePath )
        filePath ..= "/"

path_Localize = ( filePath ) ->
    return string_gsub( string_gsub( string_gsub( filePath, "^cache/[%w%-_]/", "" ), "^addons/[%w%-_]-/", "" ), "^lua/", "" )
path.Localize = path_Localize

path.ReplaceExtension = ( filePath, newExtension ) ->
    extension = string_GetExtensionFromFilename( filePath )
    if extension ~= newExtension
        if extension
            filePath = string_sub( filePath, 1, #filePath - ( #extension + 1 ) )
        filePath ..= "." .. newExtension
    return filePath

path.RemoveBackslash = ( filePath ) ->
    return string_gsub( filePath, "[/\\]?$", "" )

debug.getfpath = ->
    for i = 2, 6
        info = debug_getinfo( i, "S" )
        unless info
            break

        if info.what == "main"
            return path_Localize( path_Fix( info.short_src ) )

math = gpm_Table( gpm, "math", ->
    return setmetatable( {}, { __index: math } )
)

math.inf = 1 / 0
math.nan = 0 / 0

do

    string_byte = string.byte
    string_len = string.len
    math_abs = math.abs

    class gpm.ByteStream
        __tostring: =>
            return string_format( "ByteStream: %p [%d/%d]", @, @Pointer, @Size )

        new: ( data ) =>
            @Length = string_len( data )
            @Data = data
            @Pointer = 0

        Close: =>
            @Pointer = 0
            @Length = 0
            @Data = ""

        Size: =>
            return @Length

        Tell: =>
            return @Pointer

        Seek: ( position ) =>
            if position
                ArgAssert( position, 2, "number" )
                if position < 0
                    position = 0
            else
                position = 0

            @Pointer = position
            return position

        Skip: ( length ) =>
            if length
                ArgAssert( length, 2, "number" )
            else
                length = 1

            return @Seek( @Pointer + length )

        EndOfFile: =>
            return @Pointer >= @Length

        ReadByte: =>
            unless @EndOfFile!
                return string_byte( @Data, @Skip( 1 ) )

        ReadBool: =>
            byte = @ReadByte!
            if byte ~= nil
                return byte ~= 0

        Read: ( distance ) =>
            ArgAssert( distance, 2, "number" )
            if distance == 0 or @EndOfFile!
                return

            str, data = "", @Data
            if distance > 0
                for i = 1, distance, 1
                    str ..= data[ @Skip( 1 ) ]
            elseif distance < 0
                for i = -1, distance, -1
                    str ..= data[ @Skip( -1 ) ]
            return str

        ReadUInt: ( distance ) =>
            ArgAssert( distance, 2, "number" )
            if distance == 0
                return

            uint = 0
            for i = 1, distance
                byte = @ReadByte!
                unless byte
                    return

                uint += byte * 0x100 ^ ( i - 1 )
            return uint

        ReadUShort: =>
            return @ReadUInt( 2 )

        ReadULong: =>
            return @ReadUInt( 4 )

        ReadUInt64: =>
            return @ReadUInt( 8 )

        ReadInt: ( distance ) =>
            ArgAssert( distance, 2, "number" )
            if distance == 0
                return

            uint = @ReadUInt( distance )
            unless uint
                return

            max = 0x100 ^ math_abs( distance )
            if uint >= ( max / 2 )
                return uint - max
            return uint

        ReadShort: =>
            return @ReadInt( 2 )

        ReadLong: =>
            return @ReadInt( 4 )

        ReadInt64: =>
            return @ReadInt( 8 )

        ReadString: =>
            pointer, length = @Pointer, @Length
            if pointer >= length
                return

            len, data = 0, @Data
            for index = pointer, length
                if string_byte( data, index + 1 ) == 0
                    break
                len += 1

            if len == 0
                return

            return @Read( len ), @Skip( 1 )

do

    util = gpm_Table( gpm, "util", ->
        return setmetatable( {}, { __index: util } )
    )

    util.CompileMoonString = ->
        error( "Attempt to compile MoonScript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

    util.CompileYueString = ->
        error( "Attempt to compile Yuescript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader." )

    do

        tonumber = tonumber

        util.Version = ( number ) ->
            unless number
                return "unknown"
            elseif isstring( number )
                return number

            version = string_format( "%06d", number )
            return string_format( "%d.%d.%d", tonumber( string_sub( version, 0, 2 ) ), tonumber( string_sub( version, 3, 4 ) ), tonumber( string_sub( version, 5 ) ) )

    do

        timer_Simple = timer.Simple

        util.NextTick = ( func, a, b, c, d ) ->
            ArgAssert( func, 1, "function" )
            timer_Simple 0, -> func( a, b, c, d )

    do

        file_Exists = file.Exists

        util.IsLuaModuleInstalled = ( name ) ->
            return file_Exists( "includes/modules/" .. name .. ".lua", "LUA" )

        isWindows, isLinux = system.IsWindows!, system.IsLinux!
        jit_versionnum, jit_arch = jit.versionnum, jit.arch

        suffix = ( { "osx64", "osx", "linux64", "linux", "win64", "win32" } )[ ( isWindows and 4 or 0 ) + ( isLinux and 2 or 0 ) + ( jit_arch == "x86" and 1 or 0 ) + 1 ]
        fmt = "lua/bin/gm" .. ( ( CLIENT and not MENU_DLL ) and "cl" or "sv" ) .. "_%s_%s.dll"

        util.IsBinaryModuleInstalled = ( name ) ->
            ArgAssert( name, 1, "string" )
            if file_Exists( string_format( fmt, name, suffix ), "GAME" )
                return true
            elseif jit_versionnum ~= 20004 and jit_arch == "x86" and isLinux
                return file_Exists( string_format( fmt, name, "linux32" ), "GAME" )
            return false

    do

        Color = Color

        colors = gpm_Table( gpm, "Colors", ->
            return {
                SecondaryText: Color( 150, 150, 150 )
                PrimaryText: Color( 200, 200, 200 )
                White: Color( 255, 255, 255 )
                Info: Color( 70, 135, 255 )
                Warn: Color( 255, 130, 90 )
                Error: Color( 250, 55, 40 )
                Debug: Color( 0, 200, 150 )
                gpm: Color( 180, 180, 255 )
            } )

        state, stateColor, whiteColor = gpm.State, colors.State, colors.White
        unless isstring( state )
            if MENU_DLL
                state, stateColor = "Menu", Color( 75, 175, 80 )
            elseif CLIENT
                state, stateColor = "Client", Color( 225, 170, 10 )
            elseif SERVER
                state, stateColor = "Server", Color( 5, 170, 250 )
            gpm.State, colors.State = state or "unknown", stateColor or whiteColor

        debugFilter = -> gpm.Developer > 0

        primaryTextColor = colors.PrimaryText
        secondaryTextColor = colors.SecondaryText
        state = string.upper( state )
        os_date = os.date
        select = select
        MsgC = MsgC

        infoColor = colors.Info
        warnColor = colors.Warn
        errorColor = colors.Error
        debugColor = colors.Debug

        class Logger
            __tostring: () =>
                return string_format( "Logger: %p [%s]", @, @GetName! )

            new: ( name, color, func ) =>
                @DebugFilter = isfunction( func ) and func or debugFilter
                @Name = isstring( name ) and name or "unknown"
                @Color = gpm_IsColor( color ) and color or whiteColor
                @TextColor = primaryTextColor

            GetName: => @Name
            SetName: ( str ) =>
                ArgAssert( str, 1, "string" )
                @Name = str

            GetColor: => @Color
            SetColor: ( color ) =>
                ArgAssert( color, 1, "Color" )
                @Color = color

            GetTextColor: => @TextColor
            SetTextColor: ( color ) =>
                ArgAssert( color, 1, "Color" )
                @TextColor = color

            GetDebugFilter: => @DebugFilter
            SetDebugFilter: ( func ) =>
                ArgAssert( func, 1, "function" )
                @DebugFilter = func

            Log: ( color, level, str, ... ) =>
                ArgAssert( color, 1, "Color" )
                ArgAssert( level, 2, "string" )

                if select( "#", ... ) > 0
                    str = string_format( str, ... )
                MsgC( secondaryTextColor, os_date( "%d-%m-%Y %H:%M:%S " ), stateColor, "[" .. state .. "] ", color, level, secondaryTextColor, " --> ", @Color, @Name, secondaryTextColor, " : ", @TextColor, str, "\n" )

            Info: ( str, ... ) =>
                @Log( infoColor, "INFO ", str, ... )

            Warn: ( str, ... ) =>
                @Log( warnColor, "WARN ", str, ... )

            Error: ( str, ... ) =>
                @Log( errorColor, "ERROR", str, ... )

            Debug: ( str, ... ) =>
                if @DebugFilter( str, ... ) then
                    @Log( debugColor, "DEBUG", str, ... )

        gpm.Logger = Logger( "gpm@" .. gpm.VERSION, colors.gpm )
        util.Logger = Logger