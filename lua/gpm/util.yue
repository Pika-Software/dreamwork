_G = _G
import environment from _G.gpm
import pairs, error, rawget, getfenv, getmetatable, setmetatable, istable, tostring from _G
import string, table, debug, util from environment
import byte, sub, gsub, format, len, find from string
import concat, remove from table
import getinfo from debug

-- my cool math '^'
math = setmetatable( _G.include( "gpm/libs/math.lua" ), table.SandboxMetatable( _G.math ) )
import min, max from math
environment.math = math

do

    import running from coroutine

    environment.throw = environment.error = ( message, level ) ->
        if running!
            return error( message, level )

        return error( tostring( message ), level )

do

    import next from _G

    table.IsEmpty = ( tbl ) ->
        return next( tbl ) == nil

    table.Count = ( tbl ) ->
        length = 0

        key = next( tbl )
        while key
            length += 1
            key = next( tbl, key )

        return length

metatables = {}
do

    import FindMetaTable, RegisterMetaTable, rawset from _G
    import Count from table

    static = {
        "unknown": -1
        "nil": 0
        "boolean": 1
        "light userdata": 2
        "number": 3
        "string": 4
        "table": 5
        "function": 6
        "userdata": 7
        "thread": 8
        "Entity": 9
        "Vector": 10
        "Angle": 11
        "PhysObj": 12
        "ISave": 13
        "IRestore": 14
        "CTakeDamageInfo": 15
        "CEffectData": 16
        "CMoveData": 17
        "CRecipientFilter": 18
        "CUserCmd": 19
        "IMaterial": 21
        "Panel": 22
        "CLuaParticle": 23
        "CLuaEmitter": 24
        "ITexture": 25
        "bf_read": 26
        "ConVar": 27
        "IMesh": 28
        "VMatrix": 29
        "CSoundPatch": 30
        "pixelvis_handle_t": 31
        "dlight_t": 32
        "IVideoWriter": 33
        "File": 34
        "CLuaLocomotion": 35
        "PathFollower": 36
        "CNavArea": 37
        "IGModAudioChannel": 38
        "CNavLadder": 39
        "CNewParticleEffect": 40
        "ProjectedTexture": 41
        "PhysCollide": 42
        "SurfaceInfo": 43
        "Color": 255
    }

    setmetatable( metatables, {
        __index: ( tbl, key ) ->
            value = FindMetaTable( key )
            unless istable( value )
                return nil

            rawset( tbl, key, value )

            if id := static[ key ]
                rawset( value, "MetaID", id )
            else
                rawset( value, "MetaID", value.MetaID or ( Count( metatables ) + 256 ) )

            rawset( value, "MetaName", key )
            return value

        __newindex: ( tbl, key, value ) ->
            value = FindMetaTable( key ) or value
            unless istable( value )
                return nil

            if RegisterMetaTable
                RegisterMetaTable( key, value )

            rawset( tbl, key, value )

            if id := static[ key ]
                rawset( value, "MetaID", id )
            else
                rawset( value, "MetaID", value.MetaID or ( Count( metatables ) + 256 ) )

            rawset( value, "MetaName", key )
            return nil
    } )

do

    import type from _G
    :TypeID = _G

    type_fn = environment.type = ( any ) ->
        metatable = getmetatable( any )
        if metatable
            if name := rawget( metatable, "MetaName" )
                return name

        return type( any )

    -- js like type
    environment.typeof = ( any, ... ) ->
        return type_fn( any ), ...

    if isfunction( TypeID )
        environment.TypeID = ( any ) ->
            metatable = getmetatable( any )
            if metatable
                if id := rawget( metatable, "MetaID" )
                    return id

            return TypeID( any )

    else

        environment.TypeID = ( any ) ->
            metatable = getmetatable( any )
            if metatable
                if id := rawget( metatable, "MetaID" )
                    return id

            -- TYPE_TABLE
            return 5

:isbool, :isnumber, :isstring, :isfunction = _G
do

    getmetatabled = debug.getmetatable or getmetatable
    setmetatabled = debug.setmetatable or setmetatable
    import type from _G

    -- nil
    object = nil
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "nil" ] = metatable
        rawset( metatable, "MetaName", "nil" )
        rawset( metatable, "MetaID", 0 )

    -- boolean
    object = false
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "boolean" ] = metatable
        rawset( metatable, "MetaName", "boolean" )
        rawset( metatable, "MetaID", 1 )

        isbool = ( any ) ->
            return getmetatable( any ) == metatable

    unless isbool
        isbool = ( any ) ->
            return type( any ) == "boolean"

    environment.isbool = isbool

    -- number
    object = 0
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "number" ] = metatable
        rawset( metatable, "MetaName", "number" )
        rawset( metatable, "MetaID", 3 )

        isnumber = ( any ) ->
            return getmetatable( any ) == metatable

    unless isnumber
        isnumber = ( any ) ->
            return type( any ) == "number"

    environment.isnumber = isnumber

    -- string
    object = ""
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "string" ] = metatable
        rawset( metatable, "MetaName", "string" )
        rawset( metatable, "MetaID", 4 )

        isstring = ( any ) ->
            return getmetatable( any ) == metatable

    unless isstring
        isstring = ( any ) ->
            return type( any ) == "string"

    environment.isstring = isstring

    -- function
    object = ->
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "function" ] = metatable
        rawset( metatable, "MetaName", "function" )
        rawset( metatable, "MetaID", 6 )

        isfunction = ( any ) ->
            return getmetatable( any ) == metatable

    unless isfunction
        isfunction = ( any ) ->
            return type( any ) == "function"

    environment.isfunction = isfunction

    -- Make jit happy <3
    debug.fempty = object

    -- thread
    object = coroutine.create( object )
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "thread" ] = metatable
        rawset( metatable, "MetaName", "thread" )
        rawset( metatable, "MetaID", 8 )

        environment.isthread = ( any ) ->
            return getmetatable( any ) == metatable

environment.iscallable = ( obj ) ->
    if isfunction( obj )
        return true

    metatable = getmetatable( obj )
    if metatable and metatable.__call
        return true

    return false

util.FindMetaTable = ( name ) ->
    assert( isstring( name ), "bad argument #1 to \'util.FindMetaTable\' (string expected)" )
    return metatables[ name ]

util.RegisterMetaTable = ( name, new, id ) ->
    assert( isstring( name ), "bad argument #1 to \'util.RegisterMetaTable\' (string expected)" )
    assert( istable( new ), "bad argument #2 to \'util.RegisterMetaTable\' (table expected)" )
    assert( isnumber( id ) and id > 255 or id == nil, "bad argument #3 to \'util.RegisterMetaTable\' (number expected)" )

    old = metatables[ name ]
    unless old
        metatables[ name ] = new
        id = new.MetaID = id or new.MetaID or -1
        return id

    id = id or old.MetaID

    if old ~= new
        for key in pairs( old )
            old[ key ] = nil

        for key, value in pairs( new )
            old[ key ] = value

        old.MetaName = name
        old.MetaID = id

        new.MetaName = name
        new.MetaID = id

    return id

debug.fcall = ( func, ... ) ->
    return func( ... )

debug.getstack = ( startPos ) ->
    stack, length = {}, 0

    for level = 1 + ( startPos or 1 ), 16
        info = getinfo( level, "Snl" )
        unless info
            break

        length += 1
        stack[ length ] = info

    return stack, length

debug.getfmain = ->
    for level = 2, 16
        info = getinfo( level, "fS" )
        unless info
            break

        if info.what == "main"
            return info.func

do

    lff = ( a, b ) -> b

    debug.getfpath = ( location ) ->
        info = getinfo( location, "S" )
        if info.what == "main"
            return gsub( gsub( sub( info.source, 2 ), "^(.-)(lua/.*)$", lff ), "^(.-)([%w_]+/gamemode/.*)$", lff )

        return ""

local ArgAssert
do

    import type from environment

    ArgAssert = environment.ArgAssert = ( value, num, expected, errorlevel = 3 ) ->
        name = type( value )

        if name == expected
            return value

        elseif isfunction( expected )
            ok, expected = expected( value, num, name )
            if ok
                return value

        elseif istable( expected )
            length = #expected
            for index = 1, length
                if name == expected[ index ]
                    return value

            expected = "[ " .. concat( expected, "/", 1, length ) .. " ]"

        error( "bad argument #" .. num .. " to \'" .. ( getinfo( 2, "n" ).name or "unknown" ) .. "\' (" .. expected .. " expected, got " .. name .. ")", errorlevel )
        return nil

-- string
string.slice = sub

string.StartsWith = ( str, startStr ) ->
	return sub( str, 1, len( startStr ) ) == startStr

string.EndsWith = ( str, endStr ) ->
	return endStr == "" or sub( str, len( str ) - len( endStr ) ) == endStr

string.concat = ( ... ) ->
    args = { ... }

    length = #args
    if length == 0
        return ""

    return concat( args, "", 1, length )

string.indexOf = ( str, searchable, position, withPattern ) ->
    unless searchable
        return 0

    if searchable == ""
        return 1

    position = max( position or 1, 1 )

    if position > len( str )
        return -1

    return find( str, searchable, position, withPattern ~= true ) or -1, nil

do

    split = string.Split = ( str, pattern, withPattern ) ->
        unless pattern
            return { str }

        if pattern == ""
            ret = {}
            for i = 1, len( str )
                ret[ i ] = sub( str, i, i )

            return ret

        withPattern = withPattern ~= true
        ret, rlength = {}, 0
        pointer = 1

        while true
            startPos, endPos = find( str, pattern, pointer, withPattern )
            unless startPos
                break

            rlength += 1
            ret[ rlength ] = sub( str, pointer, startPos - 1 )
            pointer = endPos + 1

        rlength += 1
        ret[ rlength ] = sub( str, pointer )

        return ret, rlength

    string.Explode = ( pattern, str, withPattern ) ->
        return split( str, pattern, withPattern )

string.Count = ( str, pattern, withPattern ) ->
    unless pattern
        return 0

    if pattern == ""
        return len( str )

    withPattern = withPattern ~= true
    pointer = 1
    count = 0

    while true
        startPos, endPos = find( str, pattern, pointer, withPattern )
        unless startPos
            break

        count += 1
        pointer = endPos + 1

    return count

string.ByteSplit = ( str, byte0 ) ->
    unless byte0
        return { str }

    result, length = {}, 0
    startPos, endPos = 1, 1
    nextByte = byte( str, endPos )

    while nextByte
        if nextByte == byte0
            length += 1
            result[ length ] = sub( str, startPos, endPos - 1 )
            startPos = endPos + 1

        endPos += 1
        nextByte = byte( str, endPos )

    length += 1
    result[ length ] = sub( str, startPos, endPos - 1 )

    return result, length

string.ByteCount = ( str, byte0 ) ->
    unless byte0
        return 0

    count = 0
    pointer = 1
    nextByte = byte( str, pointer )

    while nextByte
        if nextByte == byte0
            count += 1

        pointer += 1
        nextByte = byte( str, pointer )

    return count

string.TrimByte = ( str, byte0, dir = 0 ) ->
    startPos, endPos = 1, len( str )

    switch dir
        when -1
            while byte( str, endPos ) == byte0
                endPos -= 1

                if endPos == 0
                    return ""
        when 1
            while byte( str, startPos ) == byte0
                startPos += 1

                if startPos == endPos
                    return ""
        else
            while byte( str, startPos ) == byte0
                startPos += 1

                if startPos == endPos
                    return ""

            while byte( str, endPos ) == byte0
                endPos -= 1

                if endPos == 0
                    return ""

    return sub( str, startPos, endPos )

string.Extract = ( str, pattern, default ) ->
    startPos, endPos, matched = find( str, pattern, 1, false )
    if startPos
        return sub( str, 1, startPos - 1 ) .. sub( str, endPos + 1 ), matched or default

    return str, default

string.Left = ( str, num ) ->
    return sub( str, 1, num )

string.Right = ( str, num ) ->
    return sub( str, -num )

string.Replace = ( str, searchable, replaceable, withPattern ) ->
    if withPattern
        return gsub( str, searchable, replaceable )

    startPos, endPos = find( str, searchable, 1, true )
    while startPos
        str = sub( str, 1, startPos - 1 ) .. replaceable .. sub( str, endPos + 1 )
        startPos, endPos = find( str, searchable, endPos + 1, true )

    return str

do

    import match from string

    string.IsURL = ( str ) ->
        return match( str, "^%l[%l+-.]+%:[^%z\x01-\x20\x7F-\xFF\"<>^`{-}]*$" ) ~= nil

string.IsASCII = ( byte0 ) ->
    return byte0 >= 0 and byte0 <= 255

string.IsBytecode = ( str ) ->
    return byte( str, 1 ) == 0x1B --[[ byte code marker ]]

-- table
unless table.unpack
    table.unpack = _G.unpack

unless table.pack
    import select from _G
    table.pack = ( ... ) ->
        return { n: select( "#", ... ), ... }

table.Invert = ( tbl ) ->
    for key, value in pairs( tbl )
        tbl[ value ] = key
        tbl[ key ] = nil

    return tbl

table.HasValue = ( tbl, any, isSequential ) ->
	if isSequential
		for index = 1, #tbl
			if tbl[ index ] == any
                return true

    else

        for _, value in pairs( tbl )
            if value == any
                return true

	return false

table.Empty = ( tbl ) ->
    for key in pairs( tbl )
        tbl[ key ] = nil

table.GetKeyCount = ( tbl ) ->
    length = 0

    for _ in pairs( tbl )
        length += 1

    return length

table.GetKeys = ( tbl ) ->
    result, length = {}, 0

    for key in pairs( tbl )
        length += 1
        result[ length ] = key

    return result, length

table.GetValues = ( tbl ) ->
    result, length = {}, 0

    for _, value in pairs( tbl )
        length += 1
        result[ length ] = value

    return result, length

table.IsSequential = ( tbl ) ->
    index = 1

    for _ in pairs( tbl )
        if tbl[ index ] == nil
            return false

        index += 1

    return true

table.RemoveByValue = ( tbl, any, isSequential ) ->
    if isSequential
        for index = 1, #tbl
            if tbl[ index ] == any
                return remove( tbl, index )

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil
                return value

    return nil

table.RemoveSameValues = ( tbl, any, isSequential ) ->
    if isSequential
        ::removed::

        for index = 1, #tbl
            if tbl[ index ] == any
                remove( tbl, index )
                goto removed

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil

    return nil

table.GetValue = ( tbl, str ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        tbl = tbl[ sub( str, pointer, startPos - 1 ) ]
        if tbl == nil
            return

        pointer = startPos + 1

    return tbl[ sub( str, pointer ) ]

table.SetValue = ( tbl, str, value ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        key = sub( str, pointer, startPos - 1 )
        pointer = startPos + 1

        if tbl[ key ] == nil
            tbl[ key ] = {}

        tbl = tbl[ key ]

    tbl[ sub( str, pointer ) ] = value

table.Slice = ( tbl, startPos, endPos, step ) ->
	result, length = {}, 0

	for index = startPos or 1, endPos or #tbl, step or 1
        length += 1
        result[ length ] = tbl[ index ]

	return result

do

    import random from math
    index, length = 1, 0

    table.Shuffle = ( tbl ) ->
        length = #tbl
        for i = length, 1, -1
            index = random( 1, length )
            tbl[ i ], tbl[ index ] = tbl[ index ], tbl[ i ]

        return tbl

    do

        keys = setmetatable( {}, { __mode: "v" } )

        table.Random = ( tbl, isSequential ) ->
            if isSequential
                length = #tbl
                if length == 0
                    return nil, nil

                if length == 1
                    index = 1
                else
                    index = random( 1, length )

            else

                length = 0
                for key in pairs( tbl )
                    length += 1
                    keys[ length ] = key

                if length == 0
                    return nil, nil

                if length == 1
                    index = keys[ 1 ]
                else
                    index = keys[ random( 1, length ) ]

            return tbl[ index ], index

do

    import lower from string

    lowerKeyNames = table.LowerKeyNames = ( tbl ) ->
        for key, value in pairs( tbl )
            if istable( value )
                value = lowerKeyNames( value )

            if isstring( key )
                tbl[ key ] = nil
                tbl[ lower( key ) ] = value
            elseif istable( key )
                tbl[ key ] = nil
                tbl[ lowerKeyNames( key ) ] = value

        return tbl

do

    import abs, clamp, floor from math
    import rshift, band from _G.bit
    import tonumber from _G
    import char from string

    metatable = metatables.Color
    environment.TYPE_COLOR = metatable.TypeID

    environment.Color = setmetatable(
        {
            FromHex: ( hex ) ->
                if isnumber( hex )
                    return setmetatable( {
                        r: rshift( band( hex, 0xFF0000 ), 16 ),
                        g: rshift( band( hex, 0xFF00 ), 8 ),
                        b: band( hex, 0xFF )
                    }, metatable )

                if byte( hex, 1 ) == 0x23 --[[ # ]]
                    hex = sub( hex, 2 )

                local r, g, b
                switch len( hex )
                    when 3
                        r, g, b = byte( hex, 1, 3 )
                        r = tonumber( char( r, r ), 16 )
                        g = tonumber( char( g, g ), 16 )
                        b = tonumber( char( b, b ), 16 )

                    when 6
                        r = tonumber( sub( hex, 1, 2 ), 16 )
                        g = tonumber( sub( hex, 3, 4 ), 16 )
                        b = tonumber( sub( hex, 5, 6 ), 16 )

                    else
                        error "invalid hex color: " .. hex

                return setmetatable( { :r, :g, :b, a: 255 }, metatable )

            FromBinary: ( binary ) ->
                local color
                switch len( binary )
                    when 1
                        color = {
                            r: byte( binary, 1 ),
                            g: 0,
                            b: 0,
                            a: 255
                        }

                    when 2
                        color = {
                            r: byte( binary, 1 ),
                            g: byte( binary, 2 ),
                            b: 0,
                            a: 255
                        }

                    when 3
                        color = {
                            r: byte( binary, 1 ),
                            g: byte( binary, 2 ),
                            b: byte( binary, 3 ),
                            a: 255
                        }

                    else
                        color = {
                            r: byte( binary, 1 ),
                            g: byte( binary, 2 ),
                            b: byte( binary, 3 ),
                            a: byte( binary, 4 )
                        }

                return setmetatable( color, metatable )

            FromVector: ( vector ) ->
                return setmetatable( {
                    r: vector[ 1 ] * 255,
                    g: vector[ 2 ] * 255,
                    b: vector[ 3 ] * 255,
                    a: 255
                }, metatable )

            FromHSL: ( hue, saturation, lightness ) ->
                return setmetatable( HSLToColor( hue, saturation, lightness ), metatable )

            FromHSV: ( hue, saturation, brightness ) ->
                return setmetatable( HSVToColor( hue, saturation, brightness ), metatable )

            FromHWB: ( hue, saturation, brightness ) ->
                return setmetatable( HSVToColor( hue, 1 - saturation / ( 1 - brightness ), 1 - brightness ), metatable )

            FromCMYK: ( cyan, magenta, yellow, black ) ->
                cyan, magenta, yellow, black = cyan * 0.01, magenta * 0.01, yellow * 0.01, black * 0.01
                mk = 1 - black

                return setmetatable( {
                    r: ( 1 - cyan ) * mk * 255,
                    g: ( 1 - magenta ) * mk * 255,
                    b: ( 1 - yellow ) * mk * 255,
                    a: 255
                }, metatable )

            FromTable: ( tbl ) ->
                return setmetatable( { r: tbl[ 1 ] or 0, g: tbl[ 2 ] or 0, b: tbl[ 3 ] or 0, a: tbl[ 4 ] or 255 }, metatable )

        },
        {
            __call: ( r, g, b, a ) =>
                if istable( r )
                    a = a or r[ 4 ] or r.a
                    b = b or r[ 3 ] or r.b
                    g = g or r[ 2 ] or r.g
                    r = r[ 1 ] or r.r

                return setmetatable( { r: r or 0, g: g or 0, b: b or 0, a: a or 255 }, metatable )
        }
    )

    do

        -- color correction credits goes to 0x00000ED (https://github.com/0x00000ED)
        colorCorrection = {
            [0]: 0, 5, 8, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
            22, -- lost 15
            23, 24, 25, 26, 27, 28,
            28, -- lost 22
            29, 30, 31, 32, 33, 34, 35,
            35, -- lost 30
            36, 37, 38, 39, 40, 41, 42,
            42, -- lost 38
            43, 44, 45, 46, 47, 48, 49, 50, 51,
            51, -- lost 48
            52, 53, 54, 55, 56, 57, 58, 59, 60,
            60, -- lost 58
            61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
            73, -- lost 72
            74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
            88, -- lost 88
            89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
            109, -- lost 110
            111,
            111, -- lost 112
            113,
            113, -- lost 114
            114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132,
            133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,
            152, 153, 154, 155, 156, 157,
            157, -- lost 159
            158, 159, 160, 162, 163, 164, 165,
            165, -- lost 167
            167, 168,
            168, -- lost 170
            170,
            170, -- lost 172
            172,
            172, -- lost 174
            174,
            174, -- lost 176
            176, 177,
            177, -- lost 179
            178, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
            198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
            217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 236, 237,
            237, -- lost 238
            238, 239, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
        }

        metatable.DoCorrection = =>
            @r = colorCorrection[ @r ]
            @g = colorCorrection[ @g ]
            @b = colorCorrection[ @b ]
            return @

    metatable.Copy = =>
        return setmetatable( { r: @r, g: @g, b: @b, a: @a }, metatable )

    do

        fixNumber = ( number ) ->
            return clamp( floor( number ), 0, 255 )

        metatable.Fix = =>
            @r = fixNumber( @r )
            @g = fixNumber( @g )
            @b = fixNumber( @b )
            return @

    metatable.ToTable = =>
        return { @r, @g, @b, @a }

    metatable.ToHex = =>
        return format( "#%02x%02x%02x", @r, @g, @b )

    metatable.ToBinary = =>
        return char( @r, @g, @b, @a )

    do

        vconst = 1 / 255

        metatable.Normalize = =>
            @r *= vconst
            @g *= vconst
            @b *= vconst
            return @

        metatable.ToVector = =>
            return Vector( @r * vconst, @g * vconst, @b * vconst )

    metatable.GetNormalized = =>
        return @Copy!\Normalize!

    metatable.ToHSL = _G.ColorToHSL
    metatable.ToHSV = _G.ColorToHSV

    metatable.ToHWB = =>
        hue, saturation, brightness = @ToHSV!
        return hue, ( 100 - saturation ) * brightness, 100 - brightness

    metatable.ToCMYK = =>
        m = max( @r, @g, @b )
        return ( m - @r ) / m * 100, ( m - @g ) / m * 100, ( m - @b ) / m * 100, min( @r, @g, @b ) / 2.55

    do

        import lerp, clamp01 from math

        metatable.Lerp = ( color, frac ) =>
            frac = clamp01( frac )
            return setmetatable( {
                r: lerp( frac, @r, color.r ),
                g: lerp( frac, @g, color.g ),
                b: lerp( frac, @b, color.b ),
                a: lerp( frac, @a, color.a )
            }, metatable )

        metatable.LerpTo = ( color, frac ) =>
            frac = clamp01( frac )
            @r = lerp( frac, @r, color.r )
            @g = lerp( frac, @g, color.g )
            @b = lerp( frac, @b, color.b )
            @a = lerp( frac, @a, color.a )
            return @

    metatable.Invert = =>
        @r, @g, @b = clamp( abs( 255 - @r ), 0, 255 ), clamp( abs( 255 - @g ), 0, 255 ), clamp( abs( 255 - @b ), 0, 255 )
        return @

    metatable.__unm = =>
        return @Copy!\Invert!

    metatable.__add = ( color ) =>
        return setmetatable( {
            r: clamp( @r + color.r, 0, 255 ),
            g: clamp( @g + color.g, 0, 255 ),
            b: clamp( @b + color.b, 0, 255 ),
            a: clamp( @a + color.a, 0, 255 )
        }, metatable )

    metatable.__sub = ( color ) =>
        return setmetatable( {
            r: clamp( @r - color.r, 0, 255 ),
            g: clamp( @g - color.g, 0, 255 ),
            b: clamp( @b - color.b, 0, 255 ),
            a: clamp( @a - color.a, 0, 255 )
        }, metatable )

    metatable.__mul = ( other ) =>
        local r, g, b, a
        if isnumber( other )
            r, g, b, a = clamp( @r * other, 0, 255 ), clamp( @g * other, 0, 255 ), clamp( @b * other, 0, 255 ), clamp( @a * other, 0, 255 )
        else
            r, g, b, a = clamp( @r * other.r, 0, 255 ), clamp( @g * other.g, 0, 255 ), clamp( @b * other.b, 0, 255 ), clamp( @a * other.a, 0, 255 )

        return setmetatable( { :r, :g, :b, :a }, metatable )

    metatable.__div = ( other ) =>
        local r, g, b, a
        if isnumber( other )
            r, g, b, a = clamp( @r / other, 0, 255 ), clamp( @g / other, 0, 255 ), clamp( @b / other, 0, 255 ), clamp( @a / other, 0, 255 )
        else
            r, g, b, a = clamp( @r / other.r, 0, 255 ), clamp( @g / other.g, 0, 255 ), clamp( @b / other.b, 0, 255 ), clamp( @a / other.a, 0, 255 )

        return setmetatable( { :r, :g, :b, :a }, metatable )

    metatable.__lt = ( other ) =>
        return ( @r + @g + @b + @a ) < ( other.r + other.g + other.b + other.a )

    metatable.__le = ( other ) =>
        return ( @r + @g + @b + @a ) <= ( other.r + other.g + other.b + other.a )

    metatable.__concat = ( value ) =>
        return @ToHex! .. tostring( value )

    -- i really hate this
    environment.ColorAlpha = ( color, alpha ) ->
        return setmetatable( { r: color.r, g: color.g, b: color.b, a: alpha }, metatable )

    environment.IsColor = ( any ) ->
        return getmetatable( any ) == metatable

    environment.iscolor = ( any ) ->
        return getmetatable( any ) == metatable or ( istable( any ) and isnumber( any.r ) and isnumber( any.g ) and isnumber( any.b ) and isnumber( any.a ) )

-- Stack
do

    class Stack
        __tostring: =>
            return format( "Stack: %p [%d/%d]", @, @pointer, @size )

        new: ( size ) =>
            @size = ( isnumber( size ) and size > 0 ) and size or -1
            @pointer = 0

        isEmpty: =>
            return @pointer == 0

        isFull: =>
            return @pointer == @size

        peek: =>
            return @[ @pointer ]

        push: ( value ) =>
            pointer = @pointer
            if pointer ~= @size
                pointer += 1
                @[ pointer ] = value
                @pointer = pointer

            return pointer

        pop: =>
            pointer = @pointer
            if pointer == 0
                return nil

            @pointer = pointer - 1
            value = @[ pointer ]
            @[ pointer ] = nil
            return value

        empty: =>
            for index = 1, @pointer
                @[ index ] = nil

            @pointer = 0

    util.Stack = Stack

    isStack = environment.IsStack = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Stack

    util.RegisterMetaTable( "Stack", Stack.__base )

-- Queue
do

    --[[

        Queue References:
            https://github.com/darkwark/queue-lua
            https://en.wikipedia.org/wiki/Queue_(abstract_data_type)

    --]]

    class Queue
        __tostring: =>
            return format( "Queue: %p [%d/%d]", @, @pointer, @size )

        new: ( size ) =>
            @size = ( isnumber( size ) and size > 0 ) and size or -1
            @front = 1
            @rear = 0

        length: =>
            return ( @rear - @front ) + 1

        isEmpty: =>
            :rear = @
            return rear == 0 or @front > rear

        isFull: =>
            return @length! == @size

        enqueue: ( value ) =>
            if @isFull!
                return nil

            rear = @rear + 1
            @rear = rear
            @[ rear ] = value

        dequeue: =>
            if @isEmpty!
                return nil

            front = @front
            value = @[ front ]
            @[ front ] = nil

            front += 1
            @front = front

            if ( front * 2 ) >= @rear
                @optimize!

            return value

        get: ( index ) =>
            return @[ @front + index ]

        set: ( index, value ) =>
            @[ @front + index ] = value

        optimize: =>
            pointer, buffer = 1, {}

            for index = @front, @rear
                buffer[ pointer ] = @[ index ]
                @[ index ] = nil
                pointer += 1

            for index = 1, pointer
                @[ index ] = buffer[ index ]

            @front = 1
            @rear = pointer - 1

        peek: =>
            return @[ @front ]

        empty: =>
            for index = @front, @rear
                @[ index ] = nil

        iterator: =>
            @optimize!

            :front, :rear = @
            front -= 1

            return ->
                if rear == 0 or front >= rear
                    return nil

                front += 1
                return front, @[ front ]

        @__base.push = @__base.enqueue
        @__base.pop = @__base.dequeue

    util.Queue = Queue

    isQueue = environment.IsQueue = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Queue

    util.RegisterMetaTable( "Queue", Queue.__base )

-- Garry's Mod hooks
do

    import hook from _G

    -- just in case
    if hook

        lib = environment.hook = setmetatable( rawget( environment, "hook" ) or {}, { __index: hook } )
        import Add, Remove, GetTable from hook
        import IsEmpty from table

        lib.Add = ( eventName, identifier, func, priority ) ->
            ArgAssert( eventName, 1, "string" )
            ArgAssert( identifier, 2, "string" )
            ArgAssert( func, 3, "function" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if hooks := pkg.__hooks
                        hooks[ eventName ][ identifier ] = func
                        return Add( eventName, pkg.__prefix .. identifier, func, priority )

            return Add( eventName, identifier, func, priority )

        lib.Remove = ( eventName, identifier ) ->
            ArgAssert( eventName, 1, "string" )
            ArgAssert( identifier, 2, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if hooks := pkg.__hooks
                        event = hooks[ eventName ]
                        event[ identifier ] = nil

                        if IsEmpty( event )
                            hooks[ eventName ] = nil

                        return Remove( eventName, pkg.__prefix .. identifier )

            return Remove( eventName, identifier )

        lib.GetTable = ->
            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if hooks := pkg.__hooks
                        return hooks

            return GetTable!

-- Garry's Mod timers
do

    import timer from _G

    -- just in case
    if timer

        import Adjust, Create, Exists, Pause, Remove, RepsLeft, Start, Stop, Simple, TimeLeft, Toggle, UnPause from timer
        lib = environment.timer = setmetatable( rawget( environment, "timer" ) or {}, { __index: timer } )
        import unpack from table

        lib.Adjust = ( identifier, delay, repetitions, func ) ->
            ArgAssert( identifier, 1, "string" )
            ArgAssert( delay, 2, "number" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if timers := pkg.__timers
                        data = timers[ identifier ]
                        unless data
                            return nil

                        delay = data.delay = delay or data.delay
                        repetitions = data.repetitions = repetitions or data.repetitions
                        func = data.func = func or data.func

                        return Adjust( pkg.__prefix .. identifier, delay, repetitions, func)

            return Adjust( identifier, delay, repetitions, func )

        lib.Create = ( identifier, delay, repetitions, func ) ->
            ArgAssert( identifier, 1, "string" )
            ArgAssert( delay, 2, "number" )
            ArgAssert( repetitions, 3, "number" )
            ArgAssert( func, 4, "function" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if timers := pkg.__timers
                        data = timers[ identifier ]
                        if data
                            data.delay = delay
                            data.repetitions = repetitions
                            data.func = func
                        else
                            timers[ identifier ] = { :delay, :repetitions, :func }

                        return Create( pkg.__prefix .. identifier, delay, repetitions, func )

            return Create( identifier, delay, repetitions, func )

        lib.Exists = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Exists( pkg.__prefix .. identifier )

            return Exists( identifier )

        lib.Pause = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Pause( pkg.__prefix .. identifier )

            return Pause( identifier )

        lib.Remove = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if timers := pkg.__timers
                        timers[ identifier ] = nil
                        return Remove( pkg.__prefix .. identifier )

            return Remove( identifier )

        lib.RepsLeft = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return RepsLeft( pkg.__prefix .. identifier )

            return RepsLeft( identifier )

        lib.Start = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Start( pkg.__prefix .. identifier )

            return Start( identifier )

        lib.Stop = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Stop( pkg.__prefix .. identifier )

            return Stop( identifier )

        lib.TimeLeft = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return TimeLeft( pkg.__prefix .. identifier )

            return TimeLeft( identifier )

        lib.Toggle = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Toggle( pkg.__prefix .. identifier )

            return Toggle( identifier )

        lib.UnPause = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return UnPause( pkg.__prefix .. identifier )

            return UnPause( identifier )

        lib.GetTable = ->
            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return pkg.__timers

            return {}

        lib.NextTick = util.NextTick = ( func, ... ) ->
            ArgAssert( func, 1, "function" )
            args = { ... }

            Simple 0, ->
                func( unpack( args ) )
                return nil

            return nil
