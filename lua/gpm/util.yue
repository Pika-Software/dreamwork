_G = _G
import pairs, error, rawget, getmetatable, setmetatable, istable from _G
import environment from _G.gpm

string = environment.string = setmetatable( rawget( environment, "string" ) or {}, { __index: _G.string } )
table = environment.table = setmetatable( rawget( environment, "table" ) or {}, { __index: _G.table } )
debug = environment.debug = setmetatable( rawget( environment, "debug" ) or {}, { __index: _G.debug } )
math = environment.math = setmetatable( rawget( environment, "math" ) or {}, { __index: _G.math } )
http = environment.http = setmetatable( rawget( environment, "http" ) or {}, { __index: _G.http } )
util = environment.util = setmetatable( rawget( environment, "util" ) or {}, { __index: _G.util } )

import byte, sub, gsub, format, len, find from string
import concat, remove from table
import max, min from math
import getinfo from debug

-- Aliases
util.CompileLuaFile = _G.CompileFile
environment.throw = error

local _R
do

    import FindMetaTable, RegisterMetaTable, rawset from _G
    _R = debug.getregistry and debug.getregistry! or {}

    static = {
        "unknown": -1
        "nil": 0
        "boolean": 1
        "light userdata": 2
        "number": 3
        "string": 4
        "table": 5
        "function": 6
        "userdata": 7
        "thread": 8
        "Entity": 9
        "Vector": 10
        "Angle": 11
        "PhysObj": 12
        "ISave": 13
        "IRestore": 14
        "CTakeDamageInfo": 15
        "CEffectData": 16
        "CMoveData": 17
        "CRecipientFilter": 18
        "CUserCmd": 19
        "IMaterial": 21
        "Panel": 22
        "CLuaParticle": 23
        "CLuaEmitter": 24
        "ITexture": 25
        "bf_read": 26
        "ConVar": 27
        "IMesh": 28
        "VMatrix": 29
        "CSoundPatch": 30
        "pixelvis_handle_t": 31
        "dlight_t": 32
        "IVideoWriter": 33
        "File": 34
        "CLuaLocomotion": 35
        "PathFollower": 36
        "CNavArea": 37
        "IGModAudioChannel": 38
        "CNavLadder": 39
        "CNewParticleEffect": 40
        "ProjectedTexture": 41
        "PhysCollide": 42
        "SurfaceInfo": 43
        "Color": 255
    }

    setmetatable( _R, {
        __index: ( tbl, key ) ->
            value = FindMetaTable( key )
            rawset( tbl, key, value )

            if index := static[ key ]
                rawset( value, "MetaID", index )
            else
                rawset( value, "MetaID", value.MetaID or -1 )

            rawset( value, "MetaName", key )
            return value

        __newindex: ( tbl, key, value ) ->
            value = FindMetaTable( key ) or value

            if RegisterMetaTable
                RegisterMetaTable( key, value )

            rawset( tbl, key, value )

            if index := static[ key ]
                rawset( value, "MetaID", index )
            else
                rawset( value, "MetaID", value.MetaID or -1 )

            rawset( value, "MetaName", key )
            return nil
    } )

    debug.getregistry = ->
        return _R

do

    import type from _G
    :TypeID = _G

    type_fn = environment.type = ( any ) ->
        metatable = getmetatable( any )
        if metatable
            if name := rawget( metatable, "MetaName" )
                return name

        return type( any )

    -- js like type
    environment.typeof = ( any, ... ) ->
        return type_fn( any ), ...

    if isfunction( TypeID )
        environment.TypeID = ( any ) ->
            metatable = getmetatable( any )
            if metatable
                if id := rawget( metatable, "MetaID" )
                    return id

            return TypeID( any )

    else

        environment.TypeID = ( any ) ->
            metatable = getmetatable( any )
            if metatable
                if id := rawget( metatable, "MetaID" )
                    return id

            -- TYPE_TABLE
            return 5

:isbool, :isnumber, :isstring, :isfunction = _G
do

    getmetatabled = debug.getmetatable or getmetatable
    setmetatabled = debug.setmetatable or setmetatable
    import type from _G

    -- nil
    object = nil
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        _R[ "nil" ] = metatable
        rawset( metatable, "MetaName", "nil" )
        rawset( metatable, "MetaID", 0 )

    -- boolean
    object = false
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        _R[ "boolean" ] = metatable
        rawset( metatable, "MetaName", "boolean" )
        rawset( metatable, "MetaID", 1 )

        isbool = ( any ) ->
            return getmetatable( any ) == metatable

    unless isbool
        isbool = ( any ) ->
            return type( any ) == "boolean"

    environment.isbool = isbool

    -- number
    object = 0
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        _R[ "number" ] = metatable
        rawset( metatable, "MetaName", "number" )
        rawset( metatable, "MetaID", 3 )

        isnumber = ( any ) ->
            return getmetatable( any ) == metatable

    unless isnumber
        isnumber = ( any ) ->
            return type( any ) == "number"

    environment.isnumber = isnumber

    -- string
    object = ""
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        _R[ "string" ] = metatable
        rawset( metatable, "MetaName", "string" )
        rawset( metatable, "MetaID", 4 )

        isstring = ( any ) ->
            return getmetatable( any ) == metatable

    unless isstring
        isstring = ( any ) ->
            return type( any ) == "string"

    environment.isstring = isstring

    -- function
    object = ->
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        _R[ "function" ] = metatable
        rawset( metatable, "MetaName", "function" )
        rawset( metatable, "MetaID", 6 )

        isfunction = ( any ) ->
            return getmetatable( any ) == metatable

    unless isfunction
        isfunction = ( any ) ->
            return type( any ) == "function"

    environment.isfunction = isfunction

    -- Make jit happy <3
    debug.fempty = object

    -- thread
    object = coroutine.create( object )
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        _R[ "thread" ] = metatable
        rawset( metatable, "MetaName", "thread" )
        rawset( metatable, "MetaID", 8 )

        environment.isthread = ( any ) ->
            return getmetatable( any ) == metatable

environment.iscallable = ( obj ) ->
    if isfunction( obj )
        return true

    metatable = getmetatable( obj )
    if metatable and metatable.__call
        return true

    return false

environment.FindMetaTable = util.FindMetaTable = ( name ) ->
    assert( isstring( name ), "bad argument #1 to \'util.FindMetaTable\' (string expected)" )
    return _R[ name ]

environment.RegisterMetaTable = util.RegisterMetaTable = ( name, metatable ) ->
    assert( isstring( name ), "bad argument #1 to \'util.RegisterMetaTable\' (string expected)" )
    assert( istable( metatable ), "bad argument #2 to \'util.RegisterMetaTable\' (metatable expected)" )
    _R[ name ] = metatable

    metatable = _R[ name ]
    return metatable and metatable.MetaID or -1

debug.fcall = ( func, ... ) ->
    return func( ... )

debug.getstack = ( startPos ) ->
    stack, length = {}, 0

    for level = 1 + ( startPos or 1 ), 16
        info = getinfo( level, "Snl" )
        unless info
            break

        length += 1
        stack[ length ] = info

    return stack, length

debug.getfmain = ->
    for level = 2, 16
        info = getinfo( level, "fS" )
        unless info
            break

        if info.what == "main"
            return info.func

do

    lff = ( a, b ) -> b

    debug.getfpath = ( location ) ->
        info = getinfo( location, "S" )
        if info.what == "main"
            return gsub( gsub( sub( info.source, 2 ), "^(.-)(lua/.*)$", lff ), "^(.-)([%w_]+/gamemode/.*)$", lff )

        return ""

do

    import type from environment

    environment.ArgAssert = ( value, num, expected, errorlevel = 3 ) ->
        name = type( value )

        if name == expected
            return value

        elseif isfunction( expected )
            ok, expected = expected( value, num, name )
            if ok
                return value

        elseif istable( expected )
            length = #expected
            for index = 1, length
                if name == expected[ index ]
                    return value

            expected = "[ " .. concat( expected, "/", 1, length ) .. " ]"

        error( "bad argument #" .. num .. " to \'" .. ( getinfo( 2, "n" ).name or "unknown" ) .. "\' (" .. expected .. " expected, got " .. name .. ")", errorlevel )
        return nil

-- string
string.slice = sub

string.StartsWith = ( str, startStr ) ->
	return sub( str, 1, len( startStr ) ) == startStr

string.EndsWith = ( str, endStr ) ->
	return endStr == "" or sub( str, len( str ) - len( endStr ) ) == endStr

string.indexOf = ( str, searchable, position, withPattern ) ->
    unless searchable
        return 0

    if searchable == ""
        return 1

    position = max( position or 1, 1 )

    if position > len( str )
        return -1

    return find( str, searchable, position, withPattern ~= true ) or -1, nil

do

    split = string.Split = ( str, pattern, withPattern ) ->
        unless pattern
            return { str }

        if pattern == ""
            ret = {}
            for i = 1, len( str )
                ret[ i ] = sub( str, i, i )

            return ret

        withPattern = withPattern ~= true
        ret, rlength = {}, 0
        pointer = 1

        while true
            startPos, endPos = find( str, pattern, pointer, withPattern )
            unless startPos
                break

            rlength += 1
            ret[ rlength ] = sub( str, pointer, startPos - 1 )
            pointer = endPos + 1

        rlength += 1
        ret[ rlength ] = sub( str, pointer )

        return ret, rlength

    string.Explode = ( pattern, str, withPattern ) ->
        return split( str, pattern, withPattern )

string.Count = ( str, pattern, withPattern ) ->
    unless pattern
        return 0

    if pattern == ""
        return len( str )

    withPattern = withPattern ~= true
    pointer = 1
    count = 0

    while true
        startPos, endPos = find( str, pattern, pointer, withPattern )
        unless startPos
            break

        count += 1
        pointer = endPos + 1

    return count

string.ByteSplit = ( str, byte0 ) ->
    unless byte0
        return { str }

    result, length = {}, 0
    startPos, endPos = 1, 1
    nextByte = byte( str, endPos )

    while nextByte
        if nextByte == byte0
            length += 1
            result[ length ] = sub( str, startPos, endPos - 1 )
            startPos = endPos + 1

        endPos += 1
        nextByte = byte( str, endPos )

    length += 1
    result[ length ] = sub( str, startPos, endPos - 1 )

    return result, length

string.ByteCount = ( str, byte0 ) ->
    unless byte0
        return 0

    count = 0
    pointer = 1
    nextByte = byte( str, pointer )

    while nextByte
        if nextByte == byte0
            count += 1

        pointer += 1
        nextByte = byte( str, pointer )

    return count

string.TrimByte = ( str, byte0, dir = 0 ) ->
    startPos, endPos = 1, len( str )

    switch dir
        when -1
            while byte( str, endPos ) == byte0
                endPos -= 1

                if endPos == 0
                    return ""
        when 1
            while byte( str, startPos ) == byte0
                startPos += 1

                if startPos == endPos
                    return ""
        else
            while byte( str, startPos ) == byte0
                startPos += 1

                if startPos == endPos
                    return ""

            while byte( str, endPos ) == byte0
                endPos -= 1

                if endPos == 0
                    return ""

    return sub( str, startPos, endPos )

string.Extract = ( str, pattern, default ) ->
    startPos, endPos, matched = find( str, pattern, 1, false )
    if startPos
        return sub( str, 1, startPos - 1 ) .. sub( str, endPos + 1 ), matched or default

    return str, default

string.Left = ( str, num ) ->
    return sub( str, 1, num )

string.Right = ( str, num ) ->
    return sub( str, -num )

string.Replace = ( str, searchable, replaceable, withPattern ) ->
    if withPattern
        return gsub( str, searchable, replaceable )

    startPos, endPos = find( str, searchable, 1, true )
    while startPos
        str = sub( str, 1, startPos - 1 ) .. replaceable .. sub( str, endPos + 1 )
        startPos, endPos = find( str, searchable, endPos + 1, true )

    return str

do

    import match from string

    string.IsURL = ( str ) ->
        return match( str, "^%l[%l+-.]+%:[^%z\x01-\x20\x7F-\xFF\"<>^`{-}]*$" ) ~= nil

unless table.unpack
    table.unpack = _G.unpack

unless table.pack
    import select from _G
    table.pack = ( ... ) ->
        return { n: select( "#", ... ), ... }

table.Invert = ( tbl ) ->
    for key, value in pairs( tbl )
        tbl[ value ] = key
        tbl[ key ] = nil

    return tbl

table.HasValue = ( tbl, any, isSequential ) ->
	if isSequential
		for index = 1, #tbl
			if tbl[ index ] == any
                return true

    else

        for _, value in pairs( tbl )
            if value == any
                return true

	return false

table.Empty = ( tbl ) ->
    for key in pairs( tbl )
        tbl[ key ] = nil

table.GetKeyCount = ( tbl ) ->
    length = 0

    for _ in pairs( tbl )
        length += 1

    return length

table.GetKeys = ( tbl ) ->
    result, length = {}, 0

    for key in pairs( tbl )
        length += 1
        result[ length ] = key

    return result, length

table.GetValues = ( tbl ) ->
    result, length = {}, 0

    for _, value in pairs( tbl )
        length += 1
        result[ length ] = value

    return result, length

do

    import next from _G

    table.IsEmpty = ( tbl ) ->
        return next( tbl ) == nil

table.IsSequential = ( tbl ) ->
    index = 1

    for _ in pairs( tbl )
        if tbl[ index ] == nil
            return false

        index += 1

    return true

table.RemoveByValue = ( tbl, any, isSequential ) ->
    if isSequential
        for index = 1, #tbl
            if tbl[ index ] == any
                return remove( tbl, index )

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil
                return value

    return nil

table.RemoveSameValues = ( tbl, any, isSequential ) ->
    if isSequential
        ::removed::

        for index = 1, #tbl
            if tbl[ index ] == any
                remove( tbl, index )
                goto removed

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil

    return nil

table.GetValue = ( tbl, str ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        tbl = tbl[ sub( str, pointer, startPos - 1 ) ]
        if tbl == nil
            return

        pointer = startPos + 1

    return tbl[ sub( str, pointer ) ]

table.SetValue = ( tbl, str, value ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        key = sub( str, pointer, startPos - 1 )
        pointer = startPos + 1

        if tbl[ key ] == nil
            tbl[ key ] = {}

        tbl = tbl[ key ]

    tbl[ sub( str, pointer ) ] = value

do

    import random from math
    index, length = 1, 0

    table.Shuffle = ( tbl ) ->
        length = #tbl
        for i = length, 1, -1
            index = random( 1, length )
            tbl[ i ], tbl[ index ] = tbl[ index ], tbl[ i ]

        return tbl

    do

        keys = setmetatable( {}, { __mode: "v" } )

        table.Random = ( tbl, isSequential ) ->
            if isSequential
                length = #tbl
                if length == 0
                    return nil, nil

                if length == 1
                    index = 1
                else
                    index = random( 1, length )

            else

                length = 0
                for key in pairs( tbl )
                    length += 1
                    keys[ length ] = key

                if length == 0
                    return nil, nil

                if length == 1
                    index = keys[ 1 ]
                else
                    index = keys[ random( 1, length ) ]

            return tbl[ index ], index

do

    import lower from string

    lowerKeyNames = table.LowerKeyNames = ( tbl ) ->
        for key, value in pairs( tbl )
            if istable( value )
                value = lowerKeyNames( value )

            if isstring( key )
                tbl[ key ] = nil
                tbl[ lower( key ) ] = value
            elseif istable( key )
                tbl[ key ] = nil
                tbl[ lowerKeyNames( key ) ] = value

        return tbl

do

    metatable = util.FindMetaTable( "Color" )
    environment.TYPE_COLOR = metatable.TypeID

    environment.iscolor = ( any ) ->
        if getmetatable( any ) == metatable
            return true

        if istable( any )
            return isnumber( any.r ) and isnumber( any.g ) and isnumber( any.b )

        return false

-- Stack
do

    class Stack
        __tostring: =>
            return format( "Stack: %p [%d/%d]", @, @pointer, @size )

        new: ( size ) =>
            @size = ( isnumber( size ) and size > 0 ) and size or -1
            @pointer = 0

        isEmpty: =>
            return @pointer == 0

        isFull: =>
            return @pointer == @size

        peek: =>
            return @[ @pointer ]

        push: ( value ) =>
            pointer = @pointer
            if pointer ~= @size
                pointer += 1
                @[ pointer ] = value
                @pointer = pointer

            return pointer

        pop: =>
            pointer = @pointer
            if pointer == 0
                return nil

            @pointer = pointer - 1
            value = @[ pointer ]
            @[ pointer ] = nil
            return value

        empty: =>
            for index = 1, @pointer
                @[ index ] = nil

            @pointer = 0

    util.Stack = Stack

    isStack = environment.IsStack = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Stack

    util.RegisterMetaTable( "Stack", Stack.__base )

-- Queue
do

    --[[

        Queue References:
            https://github.com/darkwark/queue-lua
            https://en.wikipedia.org/wiki/Queue_(abstract_data_type)

    --]]

    class Queue
        __tostring: =>
            return format( "Queue: %p [%d/%d]", @, @pointer, @size )

        new: ( size ) =>
            @size = ( isnumber( size ) and size > 0 ) and size or -1
            @front = 1
            @rear = 0

        length: =>
            return ( @rear - @front ) + 1

        isEmpty: =>
            return @rear == 0

        isFull: =>
            return @length! == @size

        enqueue: ( value ) =>
            if @isFull!
                return

            rear = @rear + 1
            @rear = rear
            @[ rear ] = value

        dequeue: =>
            if @isEmpty!
                return nil

            front = @front
            value = @[ front ]
            @[ front ] = nil

            front += 1
            @front = front

            if ( front * 2 ) >= @rear
                @optimize!

            return value

        get: ( index ) =>
            return @[ @front + index ]

        set: ( index, value ) =>
            @[ @front + index ] = value

        optimize: =>
            pointer, buffer = 1, {}

            for index = @front, @rear
                buffer[ pointer ] = @[ index ]
                @[ index ] = nil
                pointer += 1

            for index = 1, pointer
                @[ index ] = buffer[ index ]

            @front = 1
            @rear = pointer - 1

        peek: =>
            return @[ @front ]

        empty: =>
            for index = @front, @rear
                @[ index ] = nil

        @__base.push = @__base.enqueue
        @__base.pop = @__base.dequeue

    util.Queue = Queue

    isQueue = environment.IsQueue = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Queue

    util.RegisterMetaTable( "Queue", Queue.__base )

do

    import Simple from timer

    util.NextTick = ( func, a, b, c, d, e, f ) ->
        return Simple 0, ->
            func( a, b, c, d, e, f )
            return

do

    -- https://github.com/willox/gmbc
    if util.IsBinaryModuleInstalled( "gmbc" )
        pcall( require, "gmbc" )

    import CompileString, gmbc_load_bytecode from _G

    util.CompileLuaString = ( code, identifier, handleError, ignoreBytecode ) ->
        if not ignoreBytecode and byte( code, 1 ) == 0x1b
            if gmbc_load_bytecode
                return gmbc_load_bytecode( code )

            error "Bytecode compilation is not supported."
            return

        return CompileString( code, identifier, handleError )
