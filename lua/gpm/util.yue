_G = _G
import environment from _G.gpm
import pairs, error, rawget, getfenv, getmetatable, setmetatable, istable from _G
import string, table, debug, math, util from environment
import byte, sub, gsub, format, len, find from string
import concat, remove from table
import max, min from math
import getinfo from debug

-- Aliases
util.CompileLuaFile = _G.CompileFile
environment.throw = error
util.CRC32 = util.CRC

do

    import next from _G

    table.IsEmpty = ( tbl ) ->
        return next( tbl ) == nil

    table.Count = ( tbl ) ->
        length = 0

        key = next( tbl )
        while key
            length += 1
            key = next( tbl, key )

        return lenght

metatables = {}
do

    import FindMetaTable, RegisterMetaTable, rawset from _G
    import Count from table

    static = {
        "unknown": -1
        "nil": 0
        "boolean": 1
        "light userdata": 2
        "number": 3
        "string": 4
        "table": 5
        "function": 6
        "userdata": 7
        "thread": 8
        "Entity": 9
        "Vector": 10
        "Angle": 11
        "PhysObj": 12
        "ISave": 13
        "IRestore": 14
        "CTakeDamageInfo": 15
        "CEffectData": 16
        "CMoveData": 17
        "CRecipientFilter": 18
        "CUserCmd": 19
        "IMaterial": 21
        "Panel": 22
        "CLuaParticle": 23
        "CLuaEmitter": 24
        "ITexture": 25
        "bf_read": 26
        "ConVar": 27
        "IMesh": 28
        "VMatrix": 29
        "CSoundPatch": 30
        "pixelvis_handle_t": 31
        "dlight_t": 32
        "IVideoWriter": 33
        "File": 34
        "CLuaLocomotion": 35
        "PathFollower": 36
        "CNavArea": 37
        "IGModAudioChannel": 38
        "CNavLadder": 39
        "CNewParticleEffect": 40
        "ProjectedTexture": 41
        "PhysCollide": 42
        "SurfaceInfo": 43
        "Color": 255
    }

    setmetatable( metatables, {
        __index: ( tbl, key ) ->
            value = FindMetaTable( key )
            unless istable( value )
                return nil

            rawset( tbl, key, value )

            if id := static[ key ]
                rawset( value, "MetaID", id )
            else
                rawset( value, "MetaID", value.MetaID or Count( metatables ) + 256 )

            rawset( value, "MetaName", key )
            return value

        __newindex: ( tbl, key, value ) ->
            value = FindMetaTable( key ) or value
            unless istable( value )
                return nil

            if RegisterMetaTable
                RegisterMetaTable( key, value )

            rawset( tbl, key, value )

            if id := static[ key ]
                rawset( value, "MetaID", id )
            else
                rawset( value, "MetaID", value.MetaID or Count( metatables ) + 256 )

            rawset( value, "MetaName", key )
            return nil
    } )

do

    import type from _G
    :TypeID = _G

    type_fn = environment.type = ( any ) ->
        metatable = getmetatable( any )
        if metatable
            if name := rawget( metatable, "MetaName" )
                return name

        return type( any )

    -- js like type
    environment.typeof = ( any, ... ) ->
        return type_fn( any ), ...

    if isfunction( TypeID )
        environment.TypeID = ( any ) ->
            metatable = getmetatable( any )
            if metatable
                if id := rawget( metatable, "MetaID" )
                    return id

            return TypeID( any )

    else

        environment.TypeID = ( any ) ->
            metatable = getmetatable( any )
            if metatable
                if id := rawget( metatable, "MetaID" )
                    return id

            -- TYPE_TABLE
            return 5

:isbool, :isnumber, :isstring, :isfunction = _G
do

    getmetatabled = debug.getmetatable or getmetatable
    setmetatabled = debug.setmetatable or setmetatable
    import type from _G

    -- nil
    object = nil
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "nil" ] = metatable
        rawset( metatable, "MetaName", "nil" )
        rawset( metatable, "MetaID", 0 )

    -- boolean
    object = false
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "boolean" ] = metatable
        rawset( metatable, "MetaName", "boolean" )
        rawset( metatable, "MetaID", 1 )

        isbool = ( any ) ->
            return getmetatable( any ) == metatable

    unless isbool
        isbool = ( any ) ->
            return type( any ) == "boolean"

    environment.isbool = isbool

    -- number
    object = 0
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "number" ] = metatable
        rawset( metatable, "MetaName", "number" )
        rawset( metatable, "MetaID", 3 )

        isnumber = ( any ) ->
            return getmetatable( any ) == metatable

    unless isnumber
        isnumber = ( any ) ->
            return type( any ) == "number"

    environment.isnumber = isnumber

    -- string
    object = ""
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "string" ] = metatable
        rawset( metatable, "MetaName", "string" )
        rawset( metatable, "MetaID", 4 )

        isstring = ( any ) ->
            return getmetatable( any ) == metatable

    unless isstring
        isstring = ( any ) ->
            return type( any ) == "string"

    environment.isstring = isstring

    -- function
    object = ->
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "function" ] = metatable
        rawset( metatable, "MetaName", "function" )
        rawset( metatable, "MetaID", 6 )

        isfunction = ( any ) ->
            return getmetatable( any ) == metatable

    unless isfunction
        isfunction = ( any ) ->
            return type( any ) == "function"

    environment.isfunction = isfunction

    -- Make jit happy <3
    debug.fempty = object

    -- thread
    object = coroutine.create( object )
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        metatables[ "thread" ] = metatable
        rawset( metatable, "MetaName", "thread" )
        rawset( metatable, "MetaID", 8 )

        environment.isthread = ( any ) ->
            return getmetatable( any ) == metatable

environment.iscallable = ( obj ) ->
    if isfunction( obj )
        return true

    metatable = getmetatable( obj )
    if metatable and metatable.__call
        return true

    return false

util.FindMetaTable = ( name ) ->
    assert( isstring( name ), "bad argument #1 to \'util.FindMetaTable\' (string expected)" )
    return metatables[ name ]

util.RegisterMetaTable = ( name, new, id ) ->
    assert( isstring( name ), "bad argument #1 to \'util.RegisterMetaTable\' (string expected)" )
    assert( istable( new ), "bad argument #2 to \'util.RegisterMetaTable\' (table expected)" )
    assert( isnumber( id ) and id > 255 or id == nil, "bad argument #3 to \'util.RegisterMetaTable\' (number expected)" )

    old = metatables[ name ]
    unless old
        metatables[ name ] = new
        id = new.MetaID = id or new.MetaID or -1
        return id

    id = id or old.MetaID

    if old ~= new
        for key in pairs( old )
            old[ key ] = nil

        for key, value in pairs( new )
            old[ key ] = value

        old.MetaName = name
        old.MetaID = id

        new.MetaName = name
        new.MetaID = id

    return id

debug.fcall = ( func, ... ) ->
    return func( ... )

debug.getstack = ( startPos ) ->
    stack, length = {}, 0

    for level = 1 + ( startPos or 1 ), 16
        info = getinfo( level, "Snl" )
        unless info
            break

        length += 1
        stack[ length ] = info

    return stack, length

debug.getfmain = ->
    for level = 2, 16
        info = getinfo( level, "fS" )
        unless info
            break

        if info.what == "main"
            return info.func

do

    lff = ( a, b ) -> b

    debug.getfpath = ( location ) ->
        info = getinfo( location, "S" )
        if info.what == "main"
            return gsub( gsub( sub( info.source, 2 ), "^(.-)(lua/.*)$", lff ), "^(.-)([%w_]+/gamemode/.*)$", lff )

        return ""

local ArgAssert
do

    import type from environment

    ArgAssert = environment.ArgAssert = ( value, num, expected, errorlevel = 3 ) ->
        name = type( value )

        if name == expected
            return value

        elseif isfunction( expected )
            ok, expected = expected( value, num, name )
            if ok
                return value

        elseif istable( expected )
            length = #expected
            for index = 1, length
                if name == expected[ index ]
                    return value

            expected = "[ " .. concat( expected, "/", 1, length ) .. " ]"

        error( "bad argument #" .. num .. " to \'" .. ( getinfo( 2, "n" ).name or "unknown" ) .. "\' (" .. expected .. " expected, got " .. name .. ")", errorlevel )
        return nil

-- string
string.slice = sub

string.StartsWith = ( str, startStr ) ->
	return sub( str, 1, len( startStr ) ) == startStr

string.EndsWith = ( str, endStr ) ->
	return endStr == "" or sub( str, len( str ) - len( endStr ) ) == endStr

string.concat = ( ... ) ->
    args = { ... }

    lenght = #args
    if lenght == 0
        return ""

    return concat( args, "", 1, lenght )

string.indexOf = ( str, searchable, position, withPattern ) ->
    unless searchable
        return 0

    if searchable == ""
        return 1

    position = max( position or 1, 1 )

    if position > len( str )
        return -1

    return find( str, searchable, position, withPattern ~= true ) or -1, nil

do

    split = string.Split = ( str, pattern, withPattern ) ->
        unless pattern
            return { str }

        if pattern == ""
            ret = {}
            for i = 1, len( str )
                ret[ i ] = sub( str, i, i )

            return ret

        withPattern = withPattern ~= true
        ret, rlength = {}, 0
        pointer = 1

        while true
            startPos, endPos = find( str, pattern, pointer, withPattern )
            unless startPos
                break

            rlength += 1
            ret[ rlength ] = sub( str, pointer, startPos - 1 )
            pointer = endPos + 1

        rlength += 1
        ret[ rlength ] = sub( str, pointer )

        return ret, rlength

    string.Explode = ( pattern, str, withPattern ) ->
        return split( str, pattern, withPattern )

string.Count = ( str, pattern, withPattern ) ->
    unless pattern
        return 0

    if pattern == ""
        return len( str )

    withPattern = withPattern ~= true
    pointer = 1
    count = 0

    while true
        startPos, endPos = find( str, pattern, pointer, withPattern )
        unless startPos
            break

        count += 1
        pointer = endPos + 1

    return count

string.ByteSplit = ( str, byte0 ) ->
    unless byte0
        return { str }

    result, length = {}, 0
    startPos, endPos = 1, 1
    nextByte = byte( str, endPos )

    while nextByte
        if nextByte == byte0
            length += 1
            result[ length ] = sub( str, startPos, endPos - 1 )
            startPos = endPos + 1

        endPos += 1
        nextByte = byte( str, endPos )

    length += 1
    result[ length ] = sub( str, startPos, endPos - 1 )

    return result, length

string.ByteCount = ( str, byte0 ) ->
    unless byte0
        return 0

    count = 0
    pointer = 1
    nextByte = byte( str, pointer )

    while nextByte
        if nextByte == byte0
            count += 1

        pointer += 1
        nextByte = byte( str, pointer )

    return count

string.TrimByte = ( str, byte0, dir = 0 ) ->
    startPos, endPos = 1, len( str )

    switch dir
        when -1
            while byte( str, endPos ) == byte0
                endPos -= 1

                if endPos == 0
                    return ""
        when 1
            while byte( str, startPos ) == byte0
                startPos += 1

                if startPos == endPos
                    return ""
        else
            while byte( str, startPos ) == byte0
                startPos += 1

                if startPos == endPos
                    return ""

            while byte( str, endPos ) == byte0
                endPos -= 1

                if endPos == 0
                    return ""

    return sub( str, startPos, endPos )

string.Extract = ( str, pattern, default ) ->
    startPos, endPos, matched = find( str, pattern, 1, false )
    if startPos
        return sub( str, 1, startPos - 1 ) .. sub( str, endPos + 1 ), matched or default

    return str, default

string.Left = ( str, num ) ->
    return sub( str, 1, num )

string.Right = ( str, num ) ->
    return sub( str, -num )

string.Replace = ( str, searchable, replaceable, withPattern ) ->
    if withPattern
        return gsub( str, searchable, replaceable )

    startPos, endPos = find( str, searchable, 1, true )
    while startPos
        str = sub( str, 1, startPos - 1 ) .. replaceable .. sub( str, endPos + 1 )
        startPos, endPos = find( str, searchable, endPos + 1, true )

    return str

do

    import match from string

    string.IsURL = ( str ) ->
        return match( str, "^%l[%l+-.]+%:[^%z\x01-\x20\x7F-\xFF\"<>^`{-}]*$" ) ~= nil

string.IsASCII = ( byte0 ) ->
    return byte0 >= 0 and byte0 <= 255

-- table
unless table.unpack
    table.unpack = _G.unpack

unless table.pack
    import select from _G
    table.pack = ( ... ) ->
        return { n: select( "#", ... ), ... }

table.Invert = ( tbl ) ->
    for key, value in pairs( tbl )
        tbl[ value ] = key
        tbl[ key ] = nil

    return tbl

table.HasValue = ( tbl, any, isSequential ) ->
	if isSequential
		for index = 1, #tbl
			if tbl[ index ] == any
                return true

    else

        for _, value in pairs( tbl )
            if value == any
                return true

	return false

table.Empty = ( tbl ) ->
    for key in pairs( tbl )
        tbl[ key ] = nil

table.GetKeyCount = ( tbl ) ->
    length = 0

    for _ in pairs( tbl )
        length += 1

    return length

table.GetKeys = ( tbl ) ->
    result, length = {}, 0

    for key in pairs( tbl )
        length += 1
        result[ length ] = key

    return result, length

table.GetValues = ( tbl ) ->
    result, length = {}, 0

    for _, value in pairs( tbl )
        length += 1
        result[ length ] = value

    return result, length

table.IsSequential = ( tbl ) ->
    index = 1

    for _ in pairs( tbl )
        if tbl[ index ] == nil
            return false

        index += 1

    return true

table.RemoveByValue = ( tbl, any, isSequential ) ->
    if isSequential
        for index = 1, #tbl
            if tbl[ index ] == any
                return remove( tbl, index )

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil
                return value

    return nil

table.RemoveSameValues = ( tbl, any, isSequential ) ->
    if isSequential
        ::removed::

        for index = 1, #tbl
            if tbl[ index ] == any
                remove( tbl, index )
                goto removed

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil

    return nil

table.GetValue = ( tbl, str ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        tbl = tbl[ sub( str, pointer, startPos - 1 ) ]
        if tbl == nil
            return

        pointer = startPos + 1

    return tbl[ sub( str, pointer ) ]

table.SetValue = ( tbl, str, value ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        key = sub( str, pointer, startPos - 1 )
        pointer = startPos + 1

        if tbl[ key ] == nil
            tbl[ key ] = {}

        tbl = tbl[ key ]

    tbl[ sub( str, pointer ) ] = value

table.Slice = ( tbl, startPos, endPos, step ) ->
	result, lenght = {}, 0

	for index = startPos or 1, endPos or #tbl, step or 1
        lenght += 1
        result[ lenght ] = tbl[ index ]

	return result

do

    import random from math
    index, length = 1, 0

    table.Shuffle = ( tbl ) ->
        length = #tbl
        for i = length, 1, -1
            index = random( 1, length )
            tbl[ i ], tbl[ index ] = tbl[ index ], tbl[ i ]

        return tbl

    do

        keys = setmetatable( {}, { __mode: "v" } )

        table.Random = ( tbl, isSequential ) ->
            if isSequential
                length = #tbl
                if length == 0
                    return nil, nil

                if length == 1
                    index = 1
                else
                    index = random( 1, length )

            else

                length = 0
                for key in pairs( tbl )
                    length += 1
                    keys[ length ] = key

                if length == 0
                    return nil, nil

                if length == 1
                    index = keys[ 1 ]
                else
                    index = keys[ random( 1, length ) ]

            return tbl[ index ], index

do

    import lower from string

    lowerKeyNames = table.LowerKeyNames = ( tbl ) ->
        for key, value in pairs( tbl )
            if istable( value )
                value = lowerKeyNames( value )

            if isstring( key )
                tbl[ key ] = nil
                tbl[ lower( key ) ] = value
            elseif istable( key )
                tbl[ key ] = nil
                tbl[ lowerKeyNames( key ) ] = value

        return tbl

do

    metatable = metatables.Color
    environment.TYPE_COLOR = metatable.TypeID

    environment.iscolor = ( any ) ->
        if getmetatable( any ) == metatable
            return true

        if istable( any )
            return isnumber( any.r ) and isnumber( any.g ) and isnumber( any.b )

        return false

-- Stack
do

    class Stack
        __tostring: =>
            return format( "Stack: %p [%d/%d]", @, @pointer, @size )

        new: ( size ) =>
            @size = ( isnumber( size ) and size > 0 ) and size or -1
            @pointer = 0

        isEmpty: =>
            return @pointer == 0

        isFull: =>
            return @pointer == @size

        peek: =>
            return @[ @pointer ]

        push: ( value ) =>
            pointer = @pointer
            if pointer ~= @size
                pointer += 1
                @[ pointer ] = value
                @pointer = pointer

            return pointer

        pop: =>
            pointer = @pointer
            if pointer == 0
                return nil

            @pointer = pointer - 1
            value = @[ pointer ]
            @[ pointer ] = nil
            return value

        empty: =>
            for index = 1, @pointer
                @[ index ] = nil

            @pointer = 0

    util.Stack = Stack

    isStack = environment.IsStack = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Stack

    util.RegisterMetaTable( "Stack", Stack.__base )

-- Queue
do

    --[[

        Queue References:
            https://github.com/darkwark/queue-lua
            https://en.wikipedia.org/wiki/Queue_(abstract_data_type)

    --]]

    class Queue
        __tostring: =>
            return format( "Queue: %p [%d/%d]", @, @pointer, @size )

        new: ( size ) =>
            @size = ( isnumber( size ) and size > 0 ) and size or -1
            @front = 1
            @rear = 0

        length: =>
            return ( @rear - @front ) + 1

        isEmpty: =>
            return @rear == 0

        isFull: =>
            return @length! == @size

        enqueue: ( value ) =>
            if @isFull!
                return

            rear = @rear + 1
            @rear = rear
            @[ rear ] = value

        dequeue: =>
            if @isEmpty!
                return nil

            front = @front
            value = @[ front ]
            @[ front ] = nil

            front += 1
            @front = front

            if ( front * 2 ) >= @rear
                @optimize!

            return value

        get: ( index ) =>
            return @[ @front + index ]

        set: ( index, value ) =>
            @[ @front + index ] = value

        optimize: =>
            pointer, buffer = 1, {}

            for index = @front, @rear
                buffer[ pointer ] = @[ index ]
                @[ index ] = nil
                pointer += 1

            for index = 1, pointer
                @[ index ] = buffer[ index ]

            @front = 1
            @rear = pointer - 1

        peek: =>
            return @[ @front ]

        empty: =>
            for index = @front, @rear
                @[ index ] = nil

        @__base.push = @__base.enqueue
        @__base.pop = @__base.dequeue

    util.Queue = Queue

    isQueue = environment.IsQueue = ( any ) ->
        metatable = getmetatable( any )
        return metatable and metatable.__class == Queue

    util.RegisterMetaTable( "Queue", Queue.__base )

do

    -- https://github.com/willox/gmbc
    if util.IsBinaryModuleInstalled( "gmbc" )
        pcall( require, "gmbc" )

    import CompileString, gmbc_load_bytecode from _G

    loadstring = environment.loadstring = util.CompileLuaString = ( code, identifier, handleError, ignoreBytecode ) ->
        if not ignoreBytecode and byte( code, 1 ) == 0x1b
            if isfunction( gmbc_load_bytecode )
                return gmbc_load_bytecode( code )

            error "Bytecode compilation is not supported.", 2
            return nil

        return CompileString( code, identifier, handleError )

    load = environment.load = ( chunk, chunkName, mode = "bt", env = getfenv( 2 ) ) ->
        ArgAssert( chunkName, 2, "string" )

        switch type( chunk )
            when "string"
                local func
                if mode == "t"
                    func = CompileString( chunk, chunkName, true, true )
                elseif mode == "b"
                    if isfunction( gmbc_load_bytecode )
                        func = gmbc_load_bytecode( chunk )

                    error "Bytecode compilation is not supported.", 2
                    return nil
                elseif mode == "bt" or mode == "tb"
                    func = loadstring( chunk, chunkName, true, false )

                if func
                    if env
                        setfenv( func, env )

                    return func

                error "unknown load mode", 2
                return nil

            when "function"
                result, length = {}, 0

                str = chunk!
                while str
                    length += 1
                    result[ length ] = str
                    str = chunk!

                if lenght == 0
                    return ->

                return load( concat( result, "", 1, length ), chunkName, mode, env )

        error "Invalid argument #1 to 'load' (string/function expected)", 2
        return nil

-- Garry's Mod hooks
do

    import hook from _G

    -- just in case
    if hook

        lib = environment.hook = setmetatable( rawget( environment, "hook" ) or {}, { __index: hook } )
        import Add, Remove, GetTable from hook
        import IsEmpty from table

        lib.Add = ( eventName, identifier, func, priority ) ->
            ArgAssert( eventName, 1, "string" )
            ArgAssert( identifier, 2, "string" )
            ArgAssert( func, 3, "function" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if hooks := pkg.__hooks
                        hooks[ eventName ][ identifier ] = func
                        return Add( eventName, pkg.__prefix .. identifier, func, priority )

            return Add( eventName, identifier, func, priority )

        lib.Remove = ( eventName, identifier ) ->
            ArgAssert( eventName, 1, "string" )
            ArgAssert( identifier, 2, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if hooks := pkg.__hooks
                        event = hooks[ eventName ]
                        event[ identifier ] = nil

                        if IsEmpty( event )
                            hooks[ eventName ] = nil

                        return Remove( eventName, pkg.__prefix .. identifier )

            return Remove( eventName, identifier )

        lib.GetTable = ->
            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if hooks := pkg.__hooks
                        return hooks

            return GetTable!

-- Garry's Mod timers
do

    import timer from _G

    -- just in case
    if timer

        import Adjust, Create, Exists, Pause, Remove, RepsLeft, Start, Stop, Simple, TimeLeft, Toggle, UnPause from timer
        lib = environment.timer = setmetatable( rawget( environment, "timer" ) or {}, { __index: timer } )
        import unpack from table

        lib.Adjust = ( identifier, delay, repetitions, func ) ->
            ArgAssert( identifier, 1, "string" )
            ArgAssert( delay, 2, "number" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if timers := pkg.__timers
                        data = timers[ identifier ]
                        unless data
                            return nil

                        delay = data.delay = delay or data.delay
                        repetitions = data.repetitions = repetitions or data.repetitions
                        func = data.func = func or data.func

                        return Adjust( pkg.__prefix .. identifier, delay, repetitions, func)

            return Adjust( identifier, delay, repetitions, func )

        lib.Create = ( identifier, delay, repetitions, func ) ->
            ArgAssert( identifier, 1, "string" )
            ArgAssert( delay, 2, "number" )
            ArgAssert( repetitions, 3, "number" )
            ArgAssert( func, 4, "function" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if timers := pkg.__timers
                        data = timers[ identifier ]
                        if data
                            data.delay = delay
                            data.repetitions = repetitions
                            data.func = func
                        else
                            timers[ identifier ] = { :delay, :repetitions, :func }

                        return Create( pkg.__prefix .. identifier, delay, repetitions, func )

            return Create( identifier, delay, repetitions, func )

        lib.Exists = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Exists( pkg.__prefix .. identifier )

            return Exists( identifier )

        lib.Pause = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Pause( pkg.__prefix .. identifier )

            return Pause( identifier )

        lib.Remove = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if timers := pkg.__timers
                        timers[ identifier ] = nil
                        return Remove( pkg.__prefix .. identifier )

            return Remove( identifier )

        lib.RepsLeft = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return RepsLeft( pkg.__prefix .. identifier )

            return RepsLeft( identifier )

        lib.Start = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Start( pkg.__prefix .. identifier )

            return Start( identifier )

        lib.Stop = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Stop( pkg.__prefix .. identifier )

            return Stop( identifier )

        lib.TimeLeft = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return TimeLeft( pkg.__prefix .. identifier )

            return TimeLeft( identifier )

        lib.Toggle = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Toggle( pkg.__prefix .. identifier )

            return Toggle( identifier )

        lib.UnPause = ( identifier ) ->
            ArgAssert( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return UnPause( pkg.__prefix .. identifier )

            return UnPause( identifier )

        lib.GetTable = ->
            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return pkg.__timers

            return {}

        lib.NextTick = util.NextTick = ( func, ... ) ->
            ArgAssert( func, 1, "function" )
            args = { ... }

            Simple 0, ->
                func( unpack( args ) )
                return nil

            return nil

do

    import time from environment.os
    import SERVER from _G
    import MD5 from util

    util.MD5ID = ( str ) ->
        return MD5( str .. time! .. ( SERVER and "s" or "c" ) )
