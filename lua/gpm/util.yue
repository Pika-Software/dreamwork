_G = _G
import environment from _G.gpm
import pairs, error, rawget, getfenv, getmetatable, setmetatable, istable, tostring from _G
import string, table, debug, util, os from environment
import byte, sub, gsub, format, len, find from string
import concat, remove from table
import rshift, band from _G.bit
import min, max from _G.math
import getinfo from debug

:isbool, :isnumber, :isstring, :isfunction = _G

do

    import running from _G.coroutine

    environment.throw = environment.error = ( message, level ) ->
        if running!
            return error( message, level )

        return error( tostring( message ), level )

do

    import next from _G

    table.IsEmpty = ( tbl ) ->
        return next( tbl ) == nil

    table.Count = ( tbl ) ->
        length = 0

        key = next( tbl )
        while key
            length += 1
            key = next( tbl, key )

        return length

do

    equal = table.Equal = ( a, b ) ->
        if a == b
            return true

        for key, value in pairs( a )
            alt = rawget( b, key )
            unless alt
                return false

            if not ( getmetatable( value ) or getmetatable( alt ) ) and istable( value ) and istable( alt )
                return equal( value, alt )

            if value ~= alt
                return false

        for key, value in pairs( b )
            alt = rawget( a, key )
            unless alt
                return false

            if not ( getmetatable( value ) or getmetatable( alt ) ) and istable( value ) and istable( alt )
                return equal( value, alt )

            if value ~= alt
                return false

        return true

-- string
string.slice = sub
string.gmatch or= string.gfind

string.StartsWith = ( str, startStr ) ->
	return sub( str, 1, len( startStr ) ) == startStr

string.EndsWith = ( str, endStr ) ->
	return endStr == "" or sub( str, len( str ) - len( endStr ) ) == endStr

string.concat = ( ... ) ->
    args = { ... }

    length = #args
    if length == 0
        return ""

    return concat( args, "", 1, length )

string.indexOf = ( str, searchable, position, withPattern ) ->
    unless searchable
        return 0

    if searchable == ""
        return 1

    position = max( position or 1, 1 )

    if position > len( str )
        return -1

    return find( str, searchable, position, withPattern ~= true ) or -1, nil

do

    split = string.Split = ( str, pattern, withPattern ) ->
        unless pattern
            return { str }

        if pattern == ""
            ret = {}
            for index = 1, len( str )
                ret[ index ] = sub( str, index, index )

            return ret

        withPattern = withPattern ~= true
        ret, rlength = {}, 0
        pointer = 1

        while true
            startPos, endPos = find( str, pattern, pointer, withPattern )
            unless startPos
                break

            rlength += 1
            ret[ rlength ] = sub( str, pointer, startPos - 1 )
            pointer = endPos + 1

        rlength += 1
        ret[ rlength ] = sub( str, pointer )

        return ret, rlength

    string.Explode = ( pattern, str, withPattern ) ->
        return split( str, pattern, withPattern )

string.Count = ( str, pattern, withPattern ) ->
    unless pattern
        return 0

    if pattern == ""
        return len( str )

    withPattern = withPattern ~= true
    pointer = 1
    count = 0

    while true
        startPos, endPos = find( str, pattern, pointer, withPattern )
        unless startPos
            break

        count += 1
        pointer = endPos + 1

    return count

string.ByteSplit = ( str, byte0 ) ->
    unless byte0
        return { str }

    result, length = {}, 0
    startPos, endPos = 1, 1
    nextByte = byte( str, endPos )

    while nextByte
        if nextByte == byte0
            length += 1
            result[ length ] = sub( str, startPos, endPos - 1 )
            startPos = endPos + 1

        endPos += 1
        nextByte = byte( str, endPos )

    length += 1
    result[ length ] = sub( str, startPos, endPos - 1 )

    return result, length

string.ByteCount = ( str, byte0 ) ->
    unless byte0
        return 0

    count = 0
    pointer = 1
    nextByte = byte( str, pointer )

    while nextByte
        if nextByte == byte0
            count += 1

        pointer += 1
        nextByte = byte( str, pointer )

    return count

do

    isASCII = string.IsASCII = ( byte0 ) ->
        return byte0 >= 0 and byte0 <= 255

    string.TrimByte = ( str, byte0, dir = 0 ) ->
        unless isASCII( byte0 )
            error "invalid byte", 2

        startPos, endPos = 1, len( str )

        if dir ~= -1
            while byte( str, startPos ) == byte0
                startPos += 1

                if startPos == endPos
                    return "", 0

        if dir ~= 1
            while byte( str, endPos ) == byte0
                endPos -= 1

                if endPos == 0
                    return "", 0

        return sub( str, startPos, endPos ), endPos - startPos + 1

    string.TrimBytes = ( str, bytes, dir = 0 ) ->
        startPos, endPos = 1, len( str )

        for key, value in pairs( bytes )
            if isnumber( value )
                bytes[ value ] = true
                bytes[ key ] = nil

            elseif isbool( value )
                unless isnumber( key ) and isASCII( key )
                   error "invalid bytes", 2
            else
                error "invalid bytes", 2

        if dir ~= -1
            while bytes[ byte( str, startPos ) ]
                startPos += 1

                if startPos == endPos
                    return "", 0

        if dir ~= 1
            while bytes[ byte( str, endPos ) ]
                endPos -= 1

                if endPos == 0
                    return "", 0

        return sub( str, startPos, endPos ), endPos - startPos + 1

do

    chars = {
        -- ()
        [ 0x28 ]: "%("
        [ 0x29 ]: "%)"

        -- []
        [ 0x5B ]: "%["
        [ 0x5D ]: "%]"

        -- .
        [ 0x2E ]: "%."

        -- %
        [ 0x25 ]: "%%"

        -- +-
        [ 0x2B ]: "%+"
        [ 0x2D ]: "%-"

        -- *
        [ 0x2A ]: "%*"

        -- ?
        [ 0x3F ]: "%?"

        -- ^
        [ 0x5E ]: "%^"

        -- $
        [ 0x24 ]: "%$"
    }

    patternSafe = string.PatternSafe = ( str ) ->
        result, size = {}, 0
        startPos = 1

        length = len( str )

        for index = 1, length
            byte0 = byte( str, index )
            if byte0 == 0x00
                size += 1
                result[ size ] = sub( str, startPos, index - 1 ) .. "%z"
                startPos = index + 1
            else
                sybol = chars[ byte0 ]
                if sybol
                    size += 1
                    if startPos ~= index
                        result[ size ] = sub( str, startPos, index - 1 ) .. sybol
                    else
                        result[ size ] = sybol

                    startPos = index + 1

        size += 1
        result[ size ] = sub( str, startPos, length )

        if size == 0
            return str

        if size == 1
            return result[ 1 ]

        return concat( result, "", 1, size )

    import match from string

    trim = string.Trim = ( str, pattern, dir = 0 ) ->
        if pattern
            length = len( pattern )
            if length == 0
                pattern = "%s"
            elseif length == 1
                pattern = chars[ byte( pattern, 1 ) ] or pattern
            elseif length ~= 2 or byte( pattern, 1 ) ~= 0x25
                error "invalid character", 2
        else
            pattern = "%s"

        -- left
        if dir == 1
            return match( str, "^(.-)" .. pattern .. "*$" ) or str

        -- right
        if dir == -1
            return match( str, "^" .. pattern .. "*(.+)$" ) or str

        return match( str, "^" .. pattern .. "*(.-)" .. pattern .. "*$" ) or str

    string.TrimLeft = ( str, pattern ) ->
        return trim( str, pattern, 1 )

    string.TrimRight = ( str, pattern ) ->
        return trim( str, pattern, -1 )

    string.IsURL = ( str ) ->
        return match( str, "^%l[%l+-.]+%:[^%z\x01-\x20\x7F-\xFF\"<>^`{-}]*$" ) ~= nil

string.Extract = ( str, pattern, default ) ->
    startPos, endPos, matched = find( str, pattern, 1, false )
    if startPos
        return sub( str, 1, startPos - 1 ) .. sub( str, endPos + 1 ), matched or default

    return str, default

string.Left = ( str, num ) ->
    return sub( str, 1, num )

string.Right = ( str, num ) ->
    return sub( str, -num )

do

    replace = string.Replace = ( str, searchable, replaceable, withPattern ) ->
        if withPattern
            return gsub( str, searchable, replaceable )

        startPos, endPos = find( str, searchable, 1, true )
        while startPos
            str = sub( str, 1, startPos - 1 ) .. replaceable .. sub( str, endPos + 1 )
            startPos, endPos = find( str, searchable, endPos + 1, true )

        return str

    string.SQLSafe = ( str, noQuotes ) ->
        str = replace( tostring( str ), "'", "''", false )
        if null_chr := find( str, "\0" )
            str = sub( str, 1, null_chr - 1 )

        if noQuotes
            return str

        return "'" .. str .. "'"

string.IsBytecode = ( str ) ->
    return byte( str, 1 ) == 0x1B --[[ byte code marker ]]

local argument, findMetaTable, registerMetaTable
do

    import FindMetaTable, RegisterMetaTable, TypeID, rawset, type from _G
    import Count from table

    static = {
        "unknown": -1
        "nil": 0
        "boolean": 1
        "light userdata": 2
        "number": 3
        "string": 4
        "table": 5
        "function": 6
        "userdata": 7
        "thread": 8
        "Entity": 9
        "Vector": 10
        "Angle": 11
        "PhysObj": 12
        "ISave": 13
        "IRestore": 14
        "CTakeDamageInfo": 15
        "CEffectData": 16
        "CMoveData": 17
        "CRecipientFilter": 18
        "CUserCmd": 19
        "IMaterial": 21
        "Panel": 22
        "CLuaParticle": 23
        "CLuaEmitter": 24
        "ITexture": 25
        "bf_read": 26
        "ConVar": 27
        "IMesh": 28
        "VMatrix": 29 -- approved by retr0
        "CSoundPatch": 30
        "pixelvis_handle_t": 31
        "dlight_t": 32
        "IVideoWriter": 33
        "File": 34
        "CLuaLocomotion": 35
        "PathFollower": 36
        "CNavArea": 37
        "IGModAudioChannel": 38
        "CNavLadder": 39
        "CNewParticleEffect": 40
        "ProjectedTexture": 41
        "PhysCollide": 42
        "SurfaceInfo": 43
        "Color": 255
    }

    metatables = {}

    findMetaTable = util.FindMetaTable = ( name ) ->
        argument( name, 1, "string" )

        metatable = metatables[ name ]
        unless metatable
            metatable = FindMetaTable( name )
            unless istable( metatable )
                return nil

            id = static[ name ] or rawget( metatable, "MetaID" ) or rawget( metatable, "__metatable_id" ) or ( 256 + Count( metatables ) )
            if not isnumber( id ) or id < 0
                return nil

            rawset( metatable, "__metatable_name", name )
            rawset( metatable, "__metatable_id", id )
            rawset( metatable, "MetaName", name )
            rawset( metatable, "MetaID", id )
            metatables[ name ] = metatable

        return metatable

    registerMetaTable = util.RegisterMetaTable = ( name, new ) ->
        argument( name, 1, "string" )
        argument( new, 2, "table" )

        old = findMetaTable( name )
        unless old
            if RegisterMetaTable
                RegisterMetaTable( name, new )

            id = static[ name ] or rawget( new, "MetaID" ) or rawget( new, "__metatable_id" ) or ( 256 + Count( metatables ) )
            if not isnumber( id ) or id < 0
                return nil

            rawset( new, "__metatable_name", name )
            rawset( new, "__metatable_id", id )
            rawset( new, "MetaName", name )
            rawset( new, "MetaID", id )
            metatables[ name ] = new
            return new

        if new ~= old
            id = static[ name ] or rawget( old, "MetaID" ) or rawget( old, "__metatable_id" ) or ( 256 + Count( metatables ) )
            if not isnumber( id ) or id < 0
                return nil

            for key in pairs( old )
                old[ key ] = nil

            setmetatable( old, { __index: new, __newindex: new } )

            rawset( old, "__metatable_name", name )
            rawset( old, "__metatable_id", id )
            rawset( old, "MetaName", name )
            rawset( old, "MetaID", id )

        return old

    type_fn = environment.type = ( any ) ->
        local name

        metatable = getmetatable( any )
        if metatable
            cls = rawget( metatable, "__class" )
            if cls
                name = rawget( cls, "__name" )
            else
                name = rawget( metatable, "__metatable_name" ) or rawget( metatable, "MetaName" )

        if name
            return name

        return type( any )

    -- js like type
    environment.typeof = ( any, ... ) ->
        return type_fn( any ), ...

    if isfunction( TypeID )
        environment.TypeID = ( any ) ->
            metatable = getmetatable( any )
            if metatable
                id = rawget( metatable, "__metatable_id" )
                if id
                    return id

            return TypeID( any )

    else

        environment.TypeID = ( any ) ->
            metatable = getmetatable( any )
            if metatable
                id = rawget( metatable, "__metatable_id" )
                if id
                    return id

            -- TYPE_TABLE
            return 5

    environment.isinstance = environment.instanceof = ( any, a, b, ... ) ->
        if isstring( a )
            if isstring( b )
                a = { a, b, ... }
            else
                return type_fn( any ) == a

        name = type_fn( any )
        for str in *a
            if name == str
                return true

        return false

    argument = environment.argument = ( value, num, ... ) ->
        typeName = type_fn( value )
        args = { ... }
        length = #args

        local expected
        for index = 1, length
            searchable = args[ index ]
            if typeName == searchable or searchable == "any"
                return value

            elseif isfunction( searchable )
                expected = searchable( value, typeName, num )
                unless isstring( expected )
                    return value

        unless expected
            if length == 0
                expected = "none"

            elseif length == 1
                expected = args[ 1 ]

            else
                expected = concat( args, "/" )

        error( "bad argument #" .. num .. " to \'" .. ( getinfo( 2, "n" ).name or "unknown" ) .. "\' ('" .. expected .. "' expected, got '" .. typeName .. "')", 3 )
        return nil

local newClass
do

    class__call = ( cls, ... ) ->
        init = rawget( cls, "__init" )
        unless init
            parent = rawget( cls, "__parent" )
            if parent
                init = rawget( parent, "__init" )

        base = rawget( cls, "__base" )
        unless base
            error "class '#{cls}' has been corrupted", 2

        obj = setmetatable( {}, base )
        if init
            override, new = init( obj, ... )
            if override
                return new

        return obj

    extends__index = ( cls, key ) ->
        base = rawget( cls, "__base" )
        unless base
            return nil

        value = rawget( base, key )
        if value == nil
            parent = rawget( cls, "__parent" )
            if parent
                value = parent[ key ]

        return value

    tostring_object = ( obj ) ->
        return format( "@object '%s': %p", obj.__class.__name, obj )

    tostring_class = ( cls ) ->
        return format( "@class '%s': %p", cls.__name, cls )

    classExtends = environment.extends = ( cls, parent ) ->
        argument( cls, 1, "class" )
        argument( parent, 2, "class" )

        base = rawget( cls, "__base" )
        unless base
            error "class '#{cls}' has been corrupted", 2

        metatable = getmetatable( cls )
        unless metatable
            error "metatable of class '#{cls}' has been corrupted", 2

        base_parent = rawget( parent, "__base" )
        unless base_parent
            error "invalid parent", 2

        if metatable.__index ~= base
            error "class '#{cls}' has already been extended", 2

        if rawget( base, "__tostring" ) == tostring_object
            rawset( base, "__tostring", nil )

        metatable.__index = extends__index
        setmetatable( base, { __index: base_parent } )

        for key, value in pairs( base_parent )
            if sub( key, 1, 2 ) == "__" and rawget( base, key ) == nil and not ( key == "__index" and value == base_parent )
                rawset( base, key, value )

        inherited = rawget( parent, "__inherited" )
        if inherited
            inherited( parent, cls )

        rawset( cls, "__parent", parent )
        rawset( base, "__class", cls )
        return cls

    newClass = environment.class = ( name, base, static, parent ) ->
        argument( name, 1, "string" )

        if base
            argument( base, 2, "table" )
            rawset( base, "__index", rawget( base, "__index" ) or base )
            rawset( base, "__tostring", rawget( base, "__tostring" ) or tostring_object )
        else
            base = { __tostring: tostring_object }
            base.__index = base

        if static
            argument( static, 3, "table" )

            rawset( static, "__init", rawget( base, "new" ) )
            rawset( static, "__name", name )
            rawset( static, "__base", base )
        else
            static = {
                __init: rawget( base, "new" ),
                __name: name,
                __base: base
            }

        rawset( base, "new", nil )

        setmetatable( static, {
            __tostring: tostring_class
            __metatable_name: "class"
            __call: class__call
            __metatable_id: 5
            __index: base
        } )

        if parent ~= nil
            classExtends( static, parent )
        else
            rawset( base, "__class", static )

        return static

    environment.extend = ( parent, name, base, static ) ->
        return newClass( name, base, static, parent )

do

    import gmatch, ByteSplit, TrimBytes from string

    SPACE_BYTES = { 0x20 --[[ space ]], 0x09 --[[ tab ]], 0x0D --[[ cr ]], 0x0A --[[ lf ]] }
    environment.SPACE_BYTES = SPACE_BYTES

    default_types = {
        "nil": true
        "boolean": true
        "number": true
        "string": true
        "table": true
        "function": true
        "thread": true
        "userdata": true
    }

    __tostring = =>
        return format( "@type '%s': %p", getmetatable( @ ).__metatable_name, @ )

    environment.Type = newClass( "Type", {
        new: ( name, scheme, classes ) =>
            argument( name, 1, "string" )
            argument( scheme, 2, "string" )

            if classes ~= nil
                argument( classes, 3, "table" )

                for className, cls in pairs( classes )
                    unless isstring( className )
                        error "external type name must be a string"

                    unless istable( cls )
                        error "external type must be a class"

                    if rawget( cls, "__name" ) ~= className
                        error "external type name mismatch '" .. ( rawget( cls, "__name" ) or "nil" ) .. " ~= " .. className .. "'"

                @external = classes

            @name = name

            required, length = {}, 0
            fields = {}

            for str in gmatch( scheme, "(.-)\n" )
                line = TrimBytes( str, SPACE_BYTES, 0 )
                if byte( line, 1 ) == 0x23 --[[ # ]]
                    continue

                commentPos = find( line, "#", 1, true )
                if commentPos
                    line = sub( line, 1, commentPos - 1 )

                parts, count = ByteSplit( line, 0x3A --[[ : ]] )
                if count > 2
                    error "invalid type definition, expected 'name: type'"

                typeName, typeLength = TrimBytes( parts[ 2 ], SPACE_BYTES, 1 )
                fieldName = TrimBytes( parts[ 1 ], SPACE_BYTES, -1 )

                if byte( typeName, typeLength ) == 0x3F --[[ ? ]]
                    typeLength -= 1
                    typeName = sub( typeName, 1, typeLength )
                else
                    length += 1
                    required[ length ] = fieldName

                isArray = false
                if byte( typeName, typeLength - 1 ) == 0x5B --[[ [ ]] and byte( typeName, typeLength ) == 0x5D --[[ ] ]]
                    isArray = true
                    typeLength -= 2
                    typeName = sub( typeName, 1, -3 )

                unless ( default_types[ typeName ] or ( classes and classes[ typeName ] ) )
                    error "unknown type '" .. typeName .. "'"

                fields[ fieldName ] = { typeName, isArray }

            @metatable = { __metatable_name: name, __metatable_id: 5, :__tostring }
            @required = required
            @fields = fields
            return nil

        __call: ( tbl ) =>
            :required, :fields = @

            for key in *required
                unless tbl[ key ]
                    data = fields[ key ]
                    if data[ 2 ]
                        error "expected field '" .. key .. ":" .. data[ 1 ] .. "[]', got '" .. key .. ":nil'", 2
                    else
                        error "expected field '" .. key .. ":" .. data[ 1 ] .. "', got '" .. key .. ":nil'", 2

            for key, value in pairs( tbl )
                data = fields[ key ]
                unless data
                    error "unknown field '" .. key .. ":" .. type( value ) .. "'", 2

                typeName = data[ 1 ]
                if data[ 2 ]
                    unless istable( value )
                        error "expected field '" .. key .. ":" .. typeName .. "[]', got '" .. key .. ":" .. type( value ) .. "'", 2

                    for index = 1, #value
                        if type( value[ index ] ) ~= typeName
                            error "expected field '" .. key .. ":" .. typeName .. "[" .. index .. "]', got '" .. key .. ":" .. type( value[ index ] ) .. "[" .. index .. "]'", 2

                elseif type( value ) ~= typeName
                    error "expected field '" .. key .. ":" .. typeName .. "', got '" .. key .. ":" .. type( value ) .. "'", 2

            return setmetatable( tbl, @metatable )

    } )

do

    getmetatabled = debug.getmetatable or getmetatable
    setmetatabled = debug.setmetatable or setmetatable

    -- null
    do

        null = environment.null = _G.newproxy( true )
        metatable = getmetatabled( null )
        metatable.__metatable_name = "null"
        metatable.__metatable_id = 0
        metatable.MetaName = "null"
        metatable.MetaID = 0

        metatable.__tostring = ->
            return "null"

        registerMetaTable( "null", metatable )

    -- nil
    object = nil
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        registerMetaTable( "nil", metatable )

    -- boolean
    object = false
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        registerMetaTable( "boolean", metatable )

        isbool = ( any ) ->
            return getmetatable( any ) == metatable

    environment.isbool = isbool

    -- number
    object = 0
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        registerMetaTable( "number", metatable )

        isnumber = ( any ) ->
            return getmetatable( any ) == metatable

    environment.isnumber = isnumber

    -- string
    object = ""
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        registerMetaTable( "string", metatable )

        isstring = ( any ) ->
            return getmetatable( any ) == metatable

    environment.isstring = isstring

    -- function
    object = ->
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        registerMetaTable( "function", metatable )

        isfunction = ( any ) ->
            return getmetatable( any ) == metatable

        environment.iscallable = ( obj ) ->
            tbl = getmetatable( obj )
            if tbl and ( tbl == metatable or tbl.__call )
                return true

            return false

    environment.isfunction = isfunction

    -- Make jit happy <3
    debug.fempty = object

    -- thread
    object = _G.coroutine.create( object )
    do

        metatable = getmetatabled( object )
        if metatable == nil
            metatable = {}
            setmetatabled( object, metatable )

        registerMetaTable( "thread", metatable )

        environment.isthread = ( any ) ->
            return getmetatable( any ) == metatable

-- my cool math '^'
math = setmetatable( _G.include( "gpm/libs/math.lua" ), table.SandboxMetatable( _G.math ) )
environment.math = math

math.type = ( number ) ->
    if isnumber( number )
        return ( number % 1 ) == 0 and "integer" or "float"

    return nil

debug.fcall = ( func, ... ) ->
    return func( ... )

debug.getstack = ( startPos ) ->
    stack, length = {}, 0

    for level = 1 + ( startPos or 1 ), 16
        info = getinfo( level, "Snl" )
        unless info
            break

        length += 1
        stack[ length ] = info

    return stack, length

debug.getfmain = ->
    for level = 2, 16
        info = getinfo( level, "fS" )
        unless info
            break

        if info.what == "main"
            return info.func

do

    lff = ( a, b ) -> b

    debug.getfpath = ( location ) ->
        info = getinfo( location, "S" )
        if info.what == "main"
            return gsub( gsub( sub( info.source, 2 ), "^(.-)(lua/.*)$", lff ), "^(.-)([%w_]+/gamemode/.*)$", lff )

        return ""

-- table
unless table.unpack
    table.unpack = _G.unpack

unless table.pack
    import select from _G
    table.pack = ( ... ) ->
        return { n: select( "#", ... ), ... }

table.Add = ( destination, source, isSequential ) ->
    length = #destination
    if isSequential
        for index = 1, #source
            destination[ length + index ] = source[ index ]

    else

        -- shitty garry implementation
        for _, value in pairs( source )
            length += 1
            destination[ length ] = value

    return destination

table.Invert = ( tbl, makeCopy ) ->
    if makeCopy
        result = {}
        for key, value in pairs( tbl )
            result[ value ] = key

        return result

    for key, value in pairs( tbl )
        tbl[ value ] = key
        tbl[ key ] = nil

    return tbl

table.HasValue = ( tbl, any, isSequential ) ->
	if isSequential
		for index = 1, #tbl
			if tbl[ index ] == any
                return true

    else

        for _, value in pairs( tbl )
            if value == any
                return true

	return false

table.Empty = ( tbl ) ->
    for key in pairs( tbl )
        tbl[ key ] = nil

table.GetKeyCount = ( tbl ) ->
    length = 0

    for _ in pairs( tbl )
        length += 1

    return length

table.GetKeys = ( tbl ) ->
    result, length = {}, 0

    for key in pairs( tbl )
        length += 1
        result[ length ] = key

    return result, length

table.GetValues = ( tbl ) ->
    result, length = {}, 0

    for _, value in pairs( tbl )
        length += 1
        result[ length ] = value

    return result, length

table.IsSequential = ( tbl ) ->
    index = 1

    for _ in pairs( tbl )
        if tbl[ index ] == nil
            return false

        index += 1

    return true

table.RemoveByValue = ( tbl, any, isSequential ) ->
    if isSequential
        for index = 1, #tbl
            if tbl[ index ] == any
                remove( tbl, index )
                return index

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil
                return key

    return nil

table.RemoveSameValues = ( tbl, any, isSequential ) ->
    if isSequential
        ::removed::

        for index = 1, #tbl
            if tbl[ index ] == any
                remove( tbl, index )
                goto removed

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil

    return nil

table.GetValue = ( tbl, str ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        tbl = tbl[ sub( str, pointer, startPos - 1 ) ]
        if tbl == nil
            return

        pointer = startPos + 1

    return tbl[ sub( str, pointer ) ]

table.SetValue = ( tbl, str, value ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        key = sub( str, pointer, startPos - 1 )
        pointer = startPos + 1

        if tbl[ key ] == nil
            tbl[ key ] = {}

        tbl = tbl[ key ]

    tbl[ sub( str, pointer ) ] = value

table.Slice = ( tbl, startPos, endPos, step ) ->
	result, length = {}, 0

	for index = startPos or 1, endPos or #tbl, step or 1
        length += 1
        result[ length ] = tbl[ index ]

	return result

do

    import random from math
    index, length = 1, 0

    table.Shuffle = ( tbl ) ->
        length = #tbl
        for i = length, 1, -1
            index = random( 1, length )
            tbl[ i ], tbl[ index ] = tbl[ index ], tbl[ i ]

        return tbl

    do

        keys = setmetatable( {}, { __mode: "v" } )

        table.Random = ( tbl, isSequential ) ->
            if isSequential
                length = #tbl
                if length == 0
                    return nil, nil

                if length == 1
                    index = 1
                else
                    index = random( 1, length )

            else

                length = 0
                for key in pairs( tbl )
                    length += 1
                    keys[ length ] = key

                if length == 0
                    return nil, nil

                if length == 1
                    index = keys[ 1 ]
                else
                    index = keys[ random( 1, length ) ]

            return tbl[ index ], index

do

    import lower from string

    lowerKeyNames = table.LowerKeyNames = ( tbl ) ->
        for key, value in pairs( tbl )
            if istable( value )
                value = lowerKeyNames( value )

            if isstring( key )
                tbl[ key ] = nil
                tbl[ lower( key ) ] = value
            elseif istable( key )
                tbl[ key ] = nil
                tbl[ lowerKeyNames( key ) ] = value

        return tbl

do

    import abs, clamp, floor, lerp from math
    import tonumber from _G
    import char from string

    -- color correction credits goes to 0x00000ED (https://github.com/0x00000ED)
    colorCorrection = {
        [0]: 0, 5, 8, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
        22, -- lost 15
        23, 24, 25, 26, 27, 28,
        28, -- lost 22
        29, 30, 31, 32, 33, 34, 35,
        35, -- lost 30
        36, 37, 38, 39, 40, 41, 42,
        42, -- lost 38
        43, 44, 45, 46, 47, 48, 49, 50, 51,
        51, -- lost 48
        52, 53, 54, 55, 56, 57, 58, 59, 60,
        60, -- lost 58
        61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
        73, -- lost 72
        74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
        88, -- lost 88
        89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
        109, -- lost 110
        111,
        111, -- lost 112
        113,
        113, -- lost 114
        114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132,
        133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,
        152, 153, 154, 155, 156, 157,
        157, -- lost 159
        158, 159, 160, 162, 163, 164, 165,
        165, -- lost 167
        167, 168,
        168, -- lost 170
        170,
        170, -- lost 172
        172,
        172, -- lost 174
        174,
        174, -- lost 176
        176, 177,
        177, -- lost 179
        178, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
        198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
        217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 236, 237,
        237, -- lost 238
        238, 239, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
    }

    vconst = 1 / 255

    local colorClass
    internal = setmetatable(
        {
            __tostring: =>
                return format( "%d %d %d %d", @r, @g, @b, @a )

            __eq: =>
                return @r == other.r and @g == other.g and @b == other.b and @a == other.a

            __unm: =>
                return @Copy!\Invert!

            __add: ( color ) =>
                return colorClass( @r + color.r, @g + color.g, @b + color.b, @a + color.a )

            __sub: ( color ) =>
                return colorClass( @r - color.r, @g - color.g, @b - color.b, @a - color.a )

            __mul: ( other ) =>
                if isnumber( other )
                    return colorClass( @r * other, @g * other, @b * other, @a * other )

                return colorClass( @r * other.r, @g * other.g, @b * other.b, @a * other.a )

            __div: ( other ) =>
                if isnumber( other )
                    return colorClass( @r / other, @g / other, @b / other, @a / other )

                return colorClass( @r / other.r, @g / other.g, @b / other.b, @a / other.a )

            __lt: ( other ) =>
                return ( @r + @g + @b + @a ) < ( other.r + other.g + other.b + other.a )

            __le: ( other ) =>
                return ( @r + @g + @b + @a ) <= ( other.r + other.g + other.b + other.a )

            __concat: ( value ) =>
                return @ToHex! .. tostring( value )

            new: ( r, g, b, a ) =>
                if istable( r )
                    a = a or r[ 4 ] or r.a
                    b = b or r[ 3 ] or r.b
                    g = g or r[ 2 ] or r.g
                    r = r[ 1 ] or r.r

                r or= 0
                g or= 0
                b or= 0
                a or= 255

                @r = clamp( r, 0, 255 )
                @g = clamp( g, 0, 255 )
                @b = clamp( b, 0, 255 )
                @a = clamp( a, 0, 255 )

            DoCorrection: =>
                @r = colorCorrection[ @r ]
                @g = colorCorrection[ @g ]
                @b = colorCorrection[ @b ]
                return @

            Copy: =>
                return colorClass( @r, @g, @b, @a )

            ToTable: =>
                return { @r, @g, @b, @a }

            ToHex: =>
                return format( "#%02x%02x%02x", @r, @g, @b )

            ToBinary: =>
                return char( @r, @g, @b, @a )

            ToVector: =>
                return Vector( @r * vconst, @g * vconst, @b * vconst )

            ToHSL: _G.ColorToHSL
            ToHSV: _G.ColorToHSV

            ToHWB: =>
                hue, saturation, brightness = @ToHSV!
                return hue, ( 100 - saturation ) * brightness, 100 - brightness

            ToCMYK: =>
                m = max( @r, @g, @b )
                return ( m - @r ) / m * 100, ( m - @g ) / m * 100, ( m - @b ) / m * 100, min( @r, @g, @b ) / 2.55

            Lerp: ( color, frac ) =>
                frac = clamp( frac, 0, 1 )
                return colorClass( lerp( frac, @r, color.r ), lerp( frac, @g, color.g ), lerp( frac, @b, color.b ), lerp( frac, @a, color.a ) )

            LerpTo: ( color, frac ) =>
                frac = clamp( frac, 0, 1 )
                @r = lerp( frac, @r, color.r )
                @g = lerp( frac, @g, color.g )
                @b = lerp( frac, @b, color.b )
                @a = lerp( frac, @a, color.a )
                return @

            Invert: =>
                @r, @g, @b = clamp( abs( 255 - @r ), 0, 255 ), clamp( abs( 255 - @g ), 0, 255 ), clamp( abs( 255 - @b ), 0, 255 )
                return @

        },
        {
            __index: findMetaTable( "Color" )
        }
    )

    internal.__index = internal

    -- i really hate this
    environment.ColorAlpha = ( color, alpha ) ->
        return colorClass( color.r, color.g, color.b, alpha )

    environment.IsColor = ( any ) ->
        return getmetatable( any ) == internal

    environment.iscolor = ( any ) ->
        return getmetatable( any ) == internal or ( istable( any ) and isnumber( any.r ) and isnumber( any.g ) and isnumber( any.b ) and isnumber( any.a ) )

    colorClass = newClass( "Color", internal, {
        FromHex: ( hex ) ->
            if isnumber( hex )
                return colorClass( rshift( band( hex, 0xFF0000 ), 16 ), rshift( band( hex, 0xFF00 ), 8 ), band( hex, 0xFF ) )

            if byte( hex, 1 ) == 0x23 --[[ # ]]
                hex = sub( hex, 2 )

            length = len( hex )
            if length == 3
                r, g, b = byte( hex, 1, 3 )
                return colorClass( tonumber( char( r, r ), 16 ), tonumber( char( g, g ), 16 ), tonumber( char( b, b ), 16 ) )

            if length == 6
                return colorClass( tonumber( sub( hex, 1, 2 ), 16 ), tonumber( sub( hex, 3, 4 ), 16 ), tonumber( sub( hex, 5, 6 ), 16 ) )

            return colorClass!

        FromBinary: ( binary ) ->
            length = len( binary )
            if length == 1
                return colorClass( byte( binary, 1 ), 0, 0, 255 )

            if length == 2
                return colorClass( byte( binary, 1 ), byte( binary, 2 ), 0, 255 )

            if length == 3
                return colorClass( byte( binary, 1 ), byte( binary, 2 ), byte( binary, 3 ), 255 )

            return colorClass( byte( binary, 1 ), byte( binary, 2 ), byte( binary, 3 ), byte( binary, 4 ) )

        FromVector: ( vector ) ->
            return colorClass( vector[ 1 ] * 255, vector[ 2 ] * 255, vector[ 3 ] * 255, 255 )

        FromHSL: ( hue, saturation, lightness ) ->
            return colorClass( HSLToColor( hue, saturation, lightness ) )

        FromHSV: ( hue, saturation, brightness ) ->
            return colorClass( HSVToColor( hue, saturation, brightness ) )

        FromHWB: ( hue, saturation, brightness ) ->
            return colorClass( HSVToColor( hue, 1 - saturation / ( 1 - brightness ), 1 - brightness ) )

        FromCMYK: ( cyan, magenta, yellow, black ) ->
            cyan, magenta, yellow, black = cyan * 0.01, magenta * 0.01, yellow * 0.01, black * 0.01
            mk = 1 - black

            return colorClass( ( 1 - cyan ) * mk * 255, ( 1 - magenta ) * mk * 255, ( 1 - yellow ) * mk * 255, 255 )

        FromTable: ( tbl ) ->
            return colorClass( tbl )

    } )

    environment.Color = colorClass

-- Stack
do

    util.Stack = newClass( "Stack", {
        __tostring: =>
            return format( "Stack: %p [%d/%d]", @, @pointer, @size )

        new: ( size ) =>
            @size = ( isnumber( size ) and size > 0 ) and size or -1
            @pointer = 0

        IsEmpty: =>
            return @pointer == 0

        IsFull: =>
            return @pointer == @size

        Peek: =>
            return @[ @pointer ]

        Push: ( value ) =>
            pointer = @pointer
            if pointer ~= @size
                pointer += 1
                @[ pointer ] = value
                @pointer = pointer

            return pointer

        Pop: =>
            pointer = @pointer
            if pointer == 0
                return nil

            @pointer = pointer - 1
            value = @[ pointer ]
            @[ pointer ] = nil
            return value

        Empty: =>
            for index = 1, @pointer
                @[ index ] = nil

            @pointer = 0

    }, nil, nil, true )

-- Queue
do

    --[[

        Queue References:
            https://github.com/darkwark/queue-lua
            https://en.wikipedia.org/wiki/Queue_(abstract_data_type)

    --]]

    enqueue = ( value ) =>
        if @IsFull!
            return nil

        rear = @rear + 1
        @rear = rear
        @[ rear ] = value

    dequeue = =>
        if @IsEmpty!
            return nil

        front = @front
        value = @[ front ]
        @[ front ] = nil

        front += 1
        @front = front

        if ( front * 2 ) >= @rear
            @Optimize!

        return value

    util.Queue = newClass( "Queue", {
        __tostring: =>
            return format( "Queue: %p [%d/%d]", @, @pointer, @size )

        new: ( size ) =>
            @size = ( isnumber( size ) and size > 0 ) and size or -1
            @front = 1
            @rear = 0

        Length: =>
            return ( @rear - @front ) + 1

        IsEmpty: =>
            :rear = @
            return rear == 0 or @front > rear

        IsFull: =>
            return @Length! == @size

        Push: enqueue
        Pop: dequeue

        Enqueue: enqueue
        Dequeue: dequeue

        Get: ( index ) =>
            return @[ @front + index ]

        Set: ( index, value ) =>
            @[ @front + index ] = value

        Optimize: =>
            pointer, buffer = 1, {}

            for index = @front, @rear
                buffer[ pointer ] = @[ index ]
                @[ index ] = nil
                pointer += 1

            for index = 1, pointer
                @[ index ] = buffer[ index ]

            @front = 1
            @rear = pointer - 1

        Peek: =>
            return @[ @front ]

        Empty: =>
            for index = @front, @rear
                @[ index ] = nil

        Iterator: =>
            @Optimize!

            :front, :rear = @
            front -= 1

            return ->
                if rear == 0 or front >= rear
                    return nil

                front += 1
                return front, @[ front ]

    }, nil, nil, true )

-- https://github.com/WilliamVenner/gmsv_workshop
if _G.SERVER and util.IsBinaryModuleInstalled( "workshop" )
    _G.require( "workshop" )

do

    import time from os

    os.dos2unix = ( t, d ) ->
        data = { year: 1980, month: 1, day: 1, hour: 0, min: 0, sec: 0 }

        if t
            data.hour = rshift( band( t, 0xF800 ), 11 )
            data.min = rshift( band( t, 0x07E0 ), 5 )
            data.sec = band( t, 0x001F ) * 2

        if d
            data.year += rshift( band( d, 0xFE00 ), 9 )
            data.month = rshift( band( d, 0x01E0 ), 5 )
            data.day = band( d, 0x001F )

        return time( data )

do

    import lshift, bor from bit
    import fdiv from math
    import date from os

    os.unix2dos = ( u ) ->
        data = date( "*t", u )
        return bor( lshift( data.hour, 11 ), lshift( data.min, 5 ), fdiv( data.sec, 2 ) ), bor( lshift( data.year - 1980, 9 ), lshift( data.month, 5 ), data.day )

-- Garry's Mod hooks
do

    import hook from _G

    -- just in case
    if hook

        lib = environment.hook = setmetatable( rawget( environment, "hook" ) or {}, { __index: hook } )
        import Add, Remove, GetTable from hook
        import IsEmpty from table

        lib.Add = ( eventName, identifier, func, priority ) ->
            argument( eventName, 1, "string" )
            argument( identifier, 2, "string" )
            argument( func, 3, "function" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if hooks := pkg.__hooks
                        hooks[ eventName ][ identifier ] = func
                        return Add( eventName, pkg.__prefix .. identifier, func, priority )

            return Add( eventName, identifier, func, priority )

        lib.Remove = ( eventName, identifier ) ->
            argument( eventName, 1, "string" )
            argument( identifier, 2, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if hooks := pkg.__hooks
                        event = hooks[ eventName ]
                        event[ identifier ] = nil

                        if IsEmpty( event )
                            hooks[ eventName ] = nil

                        return Remove( eventName, pkg.__prefix .. identifier )

            return Remove( eventName, identifier )

        lib.GetTable = ->
            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if hooks := pkg.__hooks
                        return hooks

            return GetTable!

-- Garry's Mod timers
do

    import timer from _G

    -- just in case
    if timer

        import Adjust, Create, Exists, Pause, Remove, RepsLeft, Start, Stop, Simple, TimeLeft, Toggle, UnPause from timer
        lib = environment.timer = setmetatable( rawget( environment, "timer" ) or {}, { __index: timer } )
        import unpack from table

        lib.Adjust = ( identifier, delay, repetitions, func ) ->
            argument( identifier, 1, "string" )
            argument( delay, 2, "number" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if timers := pkg.__timers
                        data = timers[ identifier ]
                        unless data
                            return nil

                        delay = data.delay = delay or data.delay
                        repetitions = data.repetitions = repetitions or data.repetitions
                        func = data.func = func or data.func

                        return Adjust( pkg.__prefix .. identifier, delay, repetitions, func)

            return Adjust( identifier, delay, repetitions, func )

        lib.Create = ( identifier, delay, repetitions, func ) ->
            argument( identifier, 1, "string" )
            argument( delay, 2, "number" )
            argument( repetitions, 3, "number" )
            argument( func, 4, "function" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if timers := pkg.__timers
                        data = timers[ identifier ]
                        if data
                            data.delay = delay
                            data.repetitions = repetitions
                            data.func = func
                        else
                            timers[ identifier ] = { :delay, :repetitions, :func }

                        return Create( pkg.__prefix .. identifier, delay, repetitions, func )

            return Create( identifier, delay, repetitions, func )

        lib.Exists = ( identifier ) ->
            argument( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Exists( pkg.__prefix .. identifier )

            return Exists( identifier )

        lib.Pause = ( identifier ) ->
            argument( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Pause( pkg.__prefix .. identifier )

            return Pause( identifier )

        lib.Remove = ( identifier ) ->
            argument( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    if timers := pkg.__timers
                        timers[ identifier ] = nil
                        return Remove( pkg.__prefix .. identifier )

            return Remove( identifier )

        lib.RepsLeft = ( identifier ) ->
            argument( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return RepsLeft( pkg.__prefix .. identifier )

            return RepsLeft( identifier )

        lib.Start = ( identifier ) ->
            argument( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Start( pkg.__prefix .. identifier )

            return Start( identifier )

        lib.Stop = ( identifier ) ->
            argument( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Stop( pkg.__prefix .. identifier )

            return Stop( identifier )

        lib.TimeLeft = ( identifier ) ->
            argument( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return TimeLeft( pkg.__prefix .. identifier )

            return TimeLeft( identifier )

        lib.Toggle = ( identifier ) ->
            argument( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return Toggle( pkg.__prefix .. identifier )

            return Toggle( identifier )

        lib.UnPause = ( identifier ) ->
            argument( identifier, 1, "string" )

            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return UnPause( pkg.__prefix .. identifier )

            return UnPause( identifier )

        lib.GetTable = ->
            if fenv := getfenv( 2 )
                if pkg := fenv.__package
                    return pkg.__timers

            return {}

        lib.NextTick = util.NextTick = ( func, ... ) ->
            argument( func, 1, "function" )
            args = { ... }

            Simple 0, ->
                func( unpack( args ) )
                return nil

            return nil
