_G = _G
import gpm, pairs, error, istable, tostring from _G
import environment from gpm

do

    import debug from _G

    local register
    do

        _R = debug.getregistry!

        register = _G.RegisterMetaTable or ( name, metatable ) ->
            _R[ name ] = metatable

    import getmetatable, setmetatable from debug

    object = nil

    metatable = getmetatable( object )
    if metatable == nil
        metatable = {}
        setmetatable( object, metatable )

    register( "nil", metatable )

    object = 0

    metatable = getmetatable( object )
    if metatable == nil
        metatable = {}
        setmetatable( object, metatable )

    register( "number", metatable )

    object = ""

    metatable = getmetatable( object )
    if metatable == nil
        metatable = {}
        setmetatable( object, metatable )

    register( "string", metatable )

    object = false

    metatable = getmetatable( object )
    if metatable == nil
        metatable = {}
        setmetatable( object, metatable )

    register( "boolean", metatable )

    object = ->

    metatable = getmetatable( object )
    if getmetatable( object ) == nil
        metatable = {}
        setmetatable( object, metatable )

    register( "function", metatable )

    object = coroutine.create( object )

    metatable = getmetatable( object )
    if metatable == nil
        metatable = {}
        setmetatable( object, metatable )

    register( "thread", metatable )

import getmetatable, setmetatable from _G

local isstring, isnumber, isbool, isfunction
do

    :isstring, :isnumber, :isbool, :isfunction = _G
    import type from _G

    if stringMeta := getmetatable("")
        isstring = (v) -> getmetatable(v) == stringMeta

    unless isstring
        isstring = (v) -> type(v) == "string"

    environment.isstring = isstring

    if numberMeta := getmetatable(0)
        isnumber = (v) -> getmetatable(v) == numberMeta

    unless isnumber
        isnumber = (v) -> type(v) == "number"

    environment.isnumber = isnumber

    if boolMeta := getmetatable(false)
        isbool = (v) -> getmetatable(v) == boolMeta

    unless isbool
        isbool = (v) -> type(v) == "boolean"

    environment.isbool = isbool

    if functionMeta := getmetatable(->)
        isfunction = (v) -> getmetatable(v) == functionMeta

    unless isfunction
        isfunction = (v) -> type(v) == "function"

    environment.isfunction = isfunction

environment.iscallable = ( obj ) ->
    if isfunction( obj )
        return true

    metatable = getmetatable( obj )
    if metatable and metatable.__call
        return true

    return false

unless istable( gpm.Types )
    gpm.Types = {
        Functions: {}

        Indexes: setmetatable( {
            "unknown": -1
            "nil": 0
            "boolean": 1
            "light userdata": 2
            "number": 3
            "string": 4
            "table": 5
            "function": 6
            "userdata": 7
            "thread": 8
            "Entity": 9
            "Vector": 10
            "Angle": 11
            "PhysObj": 12
            "ISave": 13
            "IRestore": 14
            "CTakeDamageInfo": 15
            "CEffectData": 16
            "CMoveData": 17
            "CRecipientFilter": 18
            "CUserCmd": 19
            "IMaterial": 21
            "Panel": 22
            "CLuaParticle": 23
            "CLuaEmitter": 24
            "ITexture": 25
            "bf_read": 26
            "ConVar": 27
            "IMesh": 28
            "VMatrix": 29
            "CSoundPatch": 30
            "pixelvis_handle_t": 31
            "dlight_t": 32
            "IVideoWriter": 33
            "File": 34
            "CLuaLocomotion": 35
            "PathFollower": 36
            "CNavArea": 37
            "IGModAudioChannel": 38
            "CNavLadder": 39
            "CNewParticleEffect": 40
            "ProjectedTexture": 41
            "PhysCollide": 42
            "SurfaceInfo": 43
            "Color": 255
        }, {
            __index: ->
                return -1
        } )

        Names: setmetatable( {
            [ -1 ]: "unknown"
            [ 0 ]: "nil"
            [ 1 ]: "boolean"
            [ 2 ]: "light userdata"
            [ 3 ]: "number"
            [ 4 ]: "string"
            [ 5 ]: "table"
            [ 6 ]: "function"
            [ 7 ]: "userdata"
            [ 8 ]: "thread"
            [ 9 ]: "Entity"
            [ 10 ]: "Vector"
            [ 11 ]: "Angle"
            [ 12 ]: "PhysObj"
            [ 13 ]: "ISave"
            [ 14 ]: "IRestore"
            [ 15 ]: "CTakeDamageInfo"
            [ 16 ]: "CEffectData"
            [ 17 ]: "CMoveData"
            [ 18 ]: "CRecipientFilter"
            [ 19 ]: "CUserCmd"
            [ 21 ]: "IMaterial"
            [ 22 ]: "Panel"
            [ 23 ]: "CLuaParticle"
            [ 24 ]: "CLuaEmitter"
            [ 25 ]: "ITexture"
            [ 26 ]: "bf_read"
            [ 27 ]: "ConVar"
            [ 28 ]: "IMesh"
            [ 29 ]: "VMatrix"
            [ 30 ]: "CSoundPatch"
            [ 31 ]: "pixelvis_handle_t"
            [ 32 ]: "dlight_t"
            [ 33 ]: "IVideoWriter"
            [ 34 ]: "File"
            [ 35 ]: "CLuaLocomotion"
            [ 36 ]: "PathFollower"
            [ 37 ]: "CNavArea"
            [ 38 ]: "IGModAudioChannel"
            [ 39 ]: "CNavLadder"
            [ 40 ]: "CNewParticleEffect"
            [ 41 ]: "ProjectedTexture"
            [ 42 ]: "PhysCollide"
            [ 43 ]: "SurfaceInfo"
            [ 255 ]: "Color"
        }, {
            __index: ->
                return "unknown"
        } )
    }

math = environment.math = setmetatable( include( "libs/math.lua" ), { __index: _G.math } )
string = environment.string = setmetatable( {}, { __index: _G.string } )
table = environment.table = setmetatable( {}, { __index: _G.table } )
debug = environment.debug = setmetatable( {}, { __index: _G.debug } )
http = environment.http = setmetatable( {}, { __index: _G.http } )
util = environment.util = setmetatable( {}, { __index: _G.util } )

-- Aliases
util.CompileLuaString = _G.CompileString
util.CompileLuaFile = _G.CompileFile
environment.throw = error

import byte, char, sub, gsub, format, len, find from string
import concat, remove from table
import max, min from math
import getinfo from debug

-- Make jit happy <3
debug.fempty = ->

debug.fcall = ( func, ... ) ->
    return func( ... )

debug.getstack = ( startPos ) ->
    stack, length = {}, 0

    for level = 1 + ( startPos or 1 ), 16
        info = getinfo( level, "Snl" )
        unless info
            break

        length += 1
        stack[ length ] = info

    return stack, length

do

    getfmain = debug.getfmain = ->
        for level = 2, 16
            info = getinfo( level, "fS" )
            unless info
                break

            if info.what == "main"
                return info.func

    lff = ( a, b ) -> b

    getfpathi = debug.getfpathi = ( location ) ->
        info = getinfo( location, "S" )
        if info.what == "main"
            return "/" .. gsub( gsub( sub( info.source, 2 ), "^(.-)(lua/.*)$", lff ), "^(.-)([%w_]+/gamemode/.*)$", lff )

        return "/"

    debug.getfpath = ->
        main = getfmain!
        if main
            return getfpathi( main )

        return "/"

-- Custom variable types
do

    metadataTypes = { [ TYPE_USERDATA ]: true, [ TYPE_TABLE ]: true }
    import Names, Indexes, Functions from gpm.Types
    TypeID = TypeID

    typeID = ( value ) ->
        typeIndex = TypeID( value )

        if metadataTypes[ typeIndex ]
            for funcData in *Functions
                if funcData and funcData[ 1 ]( value )
                    return funcData[ 2 ]

        return typeIndex

    environment.TypeID = typeID

    environment.type = ( value ) ->
        return Names[ typeID( value ) ]

    environment.AddType = ( typeName, func ) ->
        assert( isstring( typeName ), "bad argument #1 to \'AddType\' (string expected)" )
        assert( isfunction( func ), "bad argument #2 to \'AddType\' (function expected)" )

        typeIndex = 256

        for index, name in pairs( Names )
            if typeName == name
                typeIndex = index
                break
            elseif index >= typeIndex
                typeIndex = index + 1

        Names[ typeIndex ] = typeName
        Indexes[ typeName ] = typeIndex

        length = #Functions
        for index = 1, length
            funcData = Functions[ index ]
            if funcData and funcData[ 2 ] == typeIndex
                remove( Functions, index )
                length -= 1
                break

        Functions[ length + 1 ] = { func, typeIndex }
        return typeIndex

-- string
string.slice = sub

string.StartsWith = ( str, startStr ) ->
	return sub( str, 1, len( startStr ) ) == startStr

string.EndsWith = ( str, endStr ) ->
	return endStr == "" or sub( str, len( str ) - len( endStr ) ) == endStr

string.indexOf = ( str, searchable, position, withPattern ) ->
    unless searchable
        return 0

    if searchable == ""
        return 1

    position = max( position or 1, 1 )

    if position > len( str )
        return -1

    return find( str, searchable, position, withPattern ~= true ) or -1, nil

split = string.Split = ( str, pattern, withPattern ) ->
    unless pattern
        return { str }

    if pattern == ""
        ret = {}
        for i = 1, len( str )
            ret[ i ] = sub( str, i, i )

        return ret

    withPattern = withPattern ~= true
    ret, rlength = {}, 0
    pointer = 1

    while true
        startPos, endPos = find( str, pattern, pointer, withPattern )
        unless startPos
            break

        rlength += 1
        ret[ rlength ] = sub( str, pointer, startPos - 1 )
        pointer = endPos + 1

    rlength += 1
    ret[ rlength ] = sub( str, pointer )

    return ret, rlength

string.Count = ( str, pattern, withPattern ) ->
    unless pattern
        return 0

    if pattern == ""
        return len( str )

    withPattern = withPattern ~= true
    pointer = 1
    count = 0

    while true
        startPos, endPos = find( str, pattern, pointer, withPattern )
        unless startPos
            break

        count += 1
        pointer = endPos + 1

    return count

string.Explode = ( pattern, str, withPattern ) ->
    return split( str, pattern, withPattern )

byteSplit = string.ByteSplit = ( str, bt ) ->
    unless bt
        return { str }

    result, length = {}, 0
    startPos, endPos = 1, 1
    nextByte = byte( str, endPos )

    while nextByte
        if nextByte == bt
            length += 1
            result[ length ] = sub( str, startPos, endPos - 1 )
            startPos = endPos + 1

        endPos += 1
        nextByte = byte( str, endPos )

    length += 1
    result[ length ] = sub( str, startPos, endPos - 1 )

    return result, length

byteCount = string.ByteCount = ( str, bt ) ->
    unless bt
        return 0

    count = 0
    pointer = 1
    nextByte = byte( str, pointer )

    while nextByte
        if nextByte == bt
            count += 1

        pointer += 1
        nextByte = byte( str, pointer )

    return count

string.Extract = ( str, pattern, default ) ->
    startPos, endPos, matched = find( str, pattern, 1, false )
    if startPos
        return sub( str, 1, startPos - 1 ) .. sub( str, endPos + 1 ), matched or default

    return str, default

string.Left = ( str, num ) ->
    return sub( str, 1, num )

string.Right = ( str, num ) ->
    return sub( str, -num )

string.Replace = ( str, searchable, replaceable, withPattern ) ->
    if withPattern
        return gsub( str, searchable, replaceable )

    startPos, endPos = find( str, searchable, 1, true )
    while startPos
        str = sub( str, 1, startPos - 1 ) .. replaceable .. sub( str, endPos + 1 )
        startPos, endPos = find( str, searchable, endPos + 1, true )

    return str

do

    import rawget, rawset from _G

    class LinkedTable
        new: ( object, read, write ) =>
            setmetatable( @, {
                "__index": read ~= false and object or nil
                "__newindex": write == true and object or nil
            } )

    util.LinkedTable = LinkedTable

    metatable = {
        __index: ( tbl, key ) ->
            links = rawget( tbl, "__indexes" )
            for index = 1, #links
                value = links[ index ][ key ]
                if value ~= nil
                    if getmetatable( value ) == nil
                        value = LinkedTable( value, true )
                        rawset( tbl, key, value )
                        return value

                    return value
    }

    import insert, RemoveByValue, GetValue, SetValue from table
    import setfenv from debug

    class util.MultiIndexTable
        new: ( link, @value = {} ) =>
            rawset( value, "__indexes", {} )
            setmetatable( value, metatable )
            rawset( value, "__mit", @ )

            if link
                @Link( link )

            return

        GetLinks: =>
            return rawget( @value, "__indexes" )

        GetBase: =>
            return @value

        SetBase: ( tbl ) =>
            rawset( tbl, "__indexes", rawget( @value, "__indexes" ) or {} )
            setmetatable( tbl, metatable )
            rawset( tbl, "__mit", @ )
            @value = tbl

        Get: ( keyPath ) =>
            return GetValue( @value, keyPath )

        Set: ( keyPath, any ) =>
            :value = @
            if isfunction( any )
                setfenv( any, value )

            return SetValue( value, keyPath, any )

        Link: ( tbl ) =>
            :value = @
            insert( rawget( value, "__indexes" ), 1, tbl )
            return value

        UnLink: ( tbl ) =>
            :value = @
            RemoveByValue( rawget( value, "__indexes" ), tbl, true )
            return value

        ClearLinks: =>
            :value = @

            indexes = rawget( value, "__indexes" )
            for index = 1, #indexes
                indexes[ index ] = nil

            return value

do

    import bor, band, lshift, rshift from (bit or bit32)
    import match from string
    import tonumber from _G
    import isuint from math

    string.IsURL = ( str ) ->
        return match( str, "^%l[%l+-.]+%:[^%z\x01-\x20\x7F-\xFF\"<>^`{-}]*$" ) ~= nil

    compare = ( a, b ) ->
        return a == b and 0 or a < b and -1 or 1

    compareIDs = ( value, value2 ) ->
        if value == value2
            return 0

        unless value
            return -1

        unless value2
            return 1

        number, number2 = tonumber( value ), tonumber( value2 )
        if number and number2
            return compare( number, number2 )

        if number
            return -1

        if number2
            return 1

        return compare( value, value2 )

    smallerPrerelease = ( first, second ) ->
        if not first or first == second
            return false

        unless second
            return true

        fisrt, fcount = byteSplit( first, 0x2E --[[ . ]] )
        second, scount = byteSplit( second, 0x2E --[[ . ]] )

        local comparison
        for index = 1, fcount
            comparison = compareIDs( fisrt[ index ], second[ index ] )
            if comparison ~= 0
                return comparison == -1

        return fcount < scount

    -- Semver lua parser. Based on https://github.com/kikito/semver.lua
    -- https://github.com/Pika-Software/gpm_legacy/blob/main/lua/gpm/sh_semver.lua
    class Version
        __tostring: =>
            preRelease, build = @prelease, @build
            if preRelease and build
                return @major .. "." .. @minor .. "." .. @patch .. "-" .. preRelease .. "+" .. build

            if preRelease
                return @major .. "." .. @minor .. "." .. @patch .. "-" .. preRelease

            if build
                return @major .. "." .. @minor .. "." .. @patch .. "+" .. build

            return @major .. "." .. @minor .. "." .. @patch

        __eq: ( other ) =>
            return @major == other.major and @minor == other.minor and @patch == other.patch and @prerelease == other.prerelease

        __lt: ( other ) =>
            if @major ~= other.major
                return @major < other.major

            if @minor ~= other.minor
                return @minor < other.minor

            if @patch ~= other.patch
                return @patch < other.patch

            return smallerPrerelease( @prerelease, other.prerelease )

        __pow: ( other ) =>
            if @major == 0
                return @ == other

            return @major == other.major and @minor <= other.minor

        -- This works like 'satisfies' (fuzzy matching) in npm.
        -- https://docs.npmjs.com/cli/v6/using-npm/semver
        -- A version range is a set of comparators which specify versions that satisfy the range.
        -- A comparator is composed of an operator and a version. The set of primitive operators is:
        --   < Less than
        --   <= Less than or equal to
        --   > Greater than
        --   >= Greater than or equal to
        --   = Equal. If no operator is specified, then equality is assumed, so this operator
        --     is optional, but MAY be included.
        -- Comparators can be joined by whitespace to form a comparator set, which is satisfied by
        -- the intersection of all of the comparators it includes.
        -- A range is composed of one or more comparator sets, joined by ||. A version matches
        -- a range if and only if every comparator in at least one of the ||-separated comparator
        -- sets is satisfied by the version.
        -- A 'version' is described by the v2.0.0 specification found at https://semver.org/.
        -- A leading '=' or 'v' character is stripped off and ignored
        __mod: ( str ) =>
            -- version range := comparator sets
            if find( str, "||", 1, true )
                local pos, part
                start = 1

                while true
                    pos = find( str, "||", start, true )
                    part = sub( str, start, pos and ( pos - 1 ) )

                    if @ % part
                        return true

                    unless pos
                        return false

                    start = pos + 2

            -- comparator set := comparators
            str = gsub( gsub( gsub( str, "%s+", " " ), "^%s+", "" ), "%s+$", "" )

            if find( str, " ", 1, true )
                local pos, part
                start = 1

                while true
                    pos = find( str, " ", start, true )
                    part = sub( str, start, pos and ( pos - 1 ) )

                    -- Hyphen Ranges: X.Y.Z - A.B.C
                    -- https://docs.npmjs.com/cli/v6/using-npm/semver#hyphen-ranges-xyz---abc
                    if pos and sub( str, pos, pos + 2 ) == " - "
                        unless @ % ( ">=" .. part )
                            return false

                        start = pos + 3
                        pos = find( str, " ", start, true )
                        part = sub( str, start, pos and ( pos - 1 ) )

                        unless @ % ( "<=" .. part )
                            return false

                    elseif not ( @ % part )
                        return false

                    unless pos
                        return true

                    start = pos + 1

                return true

            -- comparators := operator + version
            str = gsub( gsub( str, "^=", "" ), "^v", "" )

            -- X-Ranges *
            -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
            if str == "" or str == "*"
                return @ % ">=0.0.0"

            pos = find( str, "%d" )
            unless pos
                error "Version range must starts with number: " .. str

            -- X-Ranges 1.2.x 1.X 1.2.*
            -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
            local operator
            if pos == 1
                operator = "="
            else
                operator = sub( str, 1, pos - 1 )

            version = gsub( sub( str, pos ), "%.[xX*]", "" )
            xrange = max( 2 - byteCount( version, 0x2e --[[ . ]] ), 0 )

            for i = 1, xrange
                version = version .. ".0"

            sv = Version( version )
            if operator == "<"
                return @ < sv

            -- primitive operators
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#ranges
            if operator == "<="
                if xrange > 0
                    if xrange == 1
                        sv = sv\nextMinor!
                    elseif xrange == 2
                        sv = sv\nextMajor!

                    return @ < sv

                return @ <= sv

            if operator == ">"
                if xrange > 0
                    if xrange == 1
                        sv = sv\nextMinor!
                    elseif xrange == 2
                        sv = sv\nextMajor!

                    return @ >= sv

                return @ > sv

            if operator == ">="
                return @ >= sv

            if operator == "="
                if xrange > 0
                    if @ < sv
                        return false

                    if xrange == 1
                        sv = sv\nextMinor!
                    elseif xrange == 2
                        sv = sv\nextMajor!

                    return @ < sv

                return @ == sv

            -- Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4
            -- Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple.
            -- In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for
            -- versions 0.X >=0.1.0, and no updates for versions 0.0.X.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#caret-ranges-123-025-004
            if operator == "^"
                if sv.major == 0 and xrange < 2
                    if sv.minor == 0 and xrange < 1
                        return @major == 0 and @minor == 0 and @ >= sv and @ < sv\nextPatch!

                    return @major == 0 and @ >= sv and @ < sv\nextMinor!

                return @major == sv.major and @ >= sv and @ < sv\nextMajor!

            -- Tilde Ranges ~1.2.3 ~1.2 ~1
            -- Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#tilde-ranges-123-12-1
            if operator == "~"
                if @ < sv
                    return false

                if xrange == 2
                    return @ < sv\nextMajor!

                return @ < sv\nextMinor!

            error "Invaild operator: '" .. operator .. "'"
            return

        parsePrerelease: ( str ) =>
            if str == ""
                return

            prelease = match( str, "^-(%w[%.%w-]*)$" )
            if not prelease or match( prelease, "%.%." )
                error "the pre-release '" .. str .. "' is not valid"

            @prelease = prelease
            return

        parseBuild: ( str ) =>
            if str == ""
                return

            build = match( str, "^%+(%w[%.%w-]*)$" )
            if not build or match( build, "%.%." )
                error "the build '" .. str .. "' is not valid"

            @build = build
            return

        parsePrereleaseAndBuild: ( str ) =>
            if not str or str == ""
                return

            prerelease, build = match( str, "^(%-[^+]+)(%+.+)$" )
            unless prerelease and build
                switch byte( str, 1 )
                    when 0x2d --[[ - ]]
                        @parsePrerelease( str )

                    when 0x2b --[[ + ]]
                        @parseBuild( str )

                    else
                        error "the parameter '" .. str .. "' must begin with + or - to denote a pre-release or a build"

                return

            @prelease = prerelease
            @build = build
            return

        new: ( major, minor, patch, prerelease, build ) =>
            unless major
                error "at least one parameter is needed"

            if isnumber( major )
                unless isuint( major )
                    error "major version must be unsigned integer"

                @major = major

                if minor
                    unless isnumber( minor )
                        error "minor version must be a number"

                    unless isuint( minor )
                        error "minor version must be unsigned integer"

                @minor = minor or 0

                if patch
                    unless isnumber( patch )
                        error "patch version must be a number"

                    unless isuint( patch )
                        error "patch version must be unsigned integer"

                @patch = patch or 0

                if isstring( build )
                    if isstring( prerelease )
                        @parsePrerelease( prerelease )

                    @parseBuild( build )
                elseif isnumber( prerelease )
                    @parsePrereleaseAndBuild( prerelease )

                return

            str = tostring( major )

            major, minor, patch, extra = match( str, "^(%d+)%.?(%d*)%.?(%d*)(.-)$" )
            unless major
                error "the major version of '" .. str .. "' is missing"

            @parsePrereleaseAndBuild( extra )

            if minor == ""
                minor = "0"

            if patch == ""
                patch = "0"

            @major = tonumber( major )
            @minor = tonumber( minor )
            @patch = tonumber( patch )
            return

        nextMajor: =>
            return Version( @major + 1, 0, 0 )

        nextMinor: =>
            return Version( @major, @minor + 1, 0 )

        nextPatch: =>
            return Version( @major, @minor, @patch + 1 )

        toNumber: =>
            major = tonumber( @major )
            if major > 0x3ff
                error "major version is too large (max 1023)"

            minor = tonumber( @minor )
            if minor > 0x7ff
                error "minor version is too large (max 2047)"

            patch = tonumber( @patch )
            if patch > 0x7ff
                error "patch version is too large (max 2047)"

            return bor( lshift( patch, 21 ), lshift( minor, 10 ), major )

        @fromNumber: ( uint ) ->
            return Version( band( uint, 0x3ff ), band( rshift( uint, 10 ), 0x7ff ), band( rshift( uint, 21 ), 0x7ff ) )

    util.Version = Version

local ArgAssert
do

    import type from environment

    ArgAssert = ( value, argNum, expected, errorlevel ) ->
        valueType = type( value )

        if valueType == expected
            return value

        elseif isfunction( expected )
            expected = expected( value, argNum, valueType )
            unless isstring( expected )
                return value

        elseif istable( expected )
            length = #expected
            for index = 1, length
                if valueType == expected[ index ]
                    return value

            expected = "[ " .. concat( expected, "/", 1, length ) .. " ]"

        error "bad argument #" .. argNum .. " to \'" .. ( getinfo( 2, "n" ).name or "unknown" ) .. "\' (" .. expected .. " expected, got " .. valueType .. ")", errorlevel or 3

    environment.ArgAssert = ArgAssert

table.unpack = table.unpack or _G.unpack

unless table.pack

    import select from _G

    table.pack = ( ... ) ->
        return { n: select( "#", ... ), ... }

table.HasValue = ( tbl, any, isSequential ) ->
	if isSequential
		for index = 1, #tbl
			if tbl[ index ] == any
                return true

    else

        for _, value in pairs( tbl )
            if value == any
                return true

	return false

table.Empty = ( tbl ) ->
    for key in pairs( tbl )
        tbl[ key ] = nil

table.GetKeyCount = ( tbl ) ->
    length = 0

    for _ in pairs( tbl )
        length += 1

    return length

table.GetKeys = ( tbl ) ->
    result, length = {}, 0

    for key in pairs( tbl )
        length += 1
        result[ length ] = key

    return result, length

table.GetValues = ( tbl ) ->
    result, length = {}, 0

    for _, value in pairs( tbl )
        length += 1
        result[ length ] = value

    return result, length

do

    import next from _G

    table.IsEmpty = ( tbl ) ->
        return next( tbl ) == nil

table.IsSequential = ( tbl ) ->
    index = 1

    for _ in pairs( tbl )
        if tbl[ index ] == nil
            return false

        index += 1

    return true

table.RemoveByValue = ( tbl, any, isSequential ) ->
    if isSequential
        for index = 1, #tbl
            if tbl[ index ] == any
                return remove( tbl, index )

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil
                return value

    return nil

table.RemoveSameValues = ( tbl, any, isSequential ) ->
    if isSequential
        ::removed::

        for index = 1, #tbl
            if tbl[ index ] == any
                remove( tbl, index )
                goto removed

    else

        for key, value in pairs( tbl )
            if value == any
                tbl[ key ] = nil

    return nil

table.GetValue = ( tbl, str ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        tbl = tbl[ sub( str, pointer, startPos - 1 ) ]
        if tbl == nil
            return

        pointer = startPos + 1

    return tbl[ sub( str, pointer ) ]

table.SetValue = ( tbl, str, value ) ->
    pointer = 1

    for _ = 1, len( str )
        startPos = find( str, ".", pointer, true )
        unless startPos
            break

        key = sub( str, pointer, startPos - 1 )
        pointer = startPos + 1

        if tbl[ key ] == nil
            tbl[ key ] = {}

        tbl = tbl[ key ]

    tbl[ sub( str, pointer ) ] = value

do

    import random from math
    index, length = 1, 0

    table.Shuffle = ( tbl ) ->
        length = #tbl
        for i = length, 1, -1
            index = random( 1, length )
            tbl[ i ], tbl[ index ] = tbl[ index ], tbl[ i ]

        return tbl

    do

        keys = setmetatable( {}, { __mode: "v" } )

        table.Random = ( tbl, isSequential ) ->
            if isSequential
                length = #tbl
                if length == 0
                    return nil, nil

                if length == 1
                    index = 1
                else
                    index = random( 1, length )

            else

                length = 0
                for key in pairs( tbl )
                    length += 1
                    keys[ length ] = key

                if length == 0
                    return nil, nil

                if length == 1
                    index = keys[ 1 ]
                else
                    index = keys[ random( 1, length ) ]

            return tbl[ index ], index

do

    import lower from string

    lowerKeyNames = table.LowerKeyNames = ( tbl ) ->
        for key, value in pairs( tbl )
            if istable( value )
                value = lowerKeyNames( value )

            if isstring( key )
                tbl[ key ] = nil
                tbl[ lower( key ) ] = value
            elseif istable( key )
                tbl[ key ] = nil
                tbl[ lowerKeyNames( key ) ] = value

        return tbl

local iscolor
do

    metatable = FindMetaTable( "Color" )

    iscolor = ( any ) ->
        if getmetatable( any ) == metatable
            return true

        if istable( any )
            return isnumber( any.r ) and isnumber( any.g ) and isnumber( any.b )

        return false

    environment.AddType( "Color", iscolor )
    environment.iscolor = iscolor

do

    -- https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
    -- https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
    codes = {

        --[[--------------------
            Successful 2XX
        --------------------]]--
        [ 200 ]: { "OK", "The resource has been obtained" }
        [ 201 ]: { "Created", "The request succeeded, and a new resource was created as a result" }
        [ 202 ]: { "Accepted", "The request has been received but not yet acted upon" }
        [ 203 ]: { "Non-Authoritative Information", "This response code means the returned metadata is not exactly the same as is available from the origin server" }
        [ 204 ]: { "No Content", "The request has been send with no errors also there is no content to send for this request, but the headers may be useful" }
        [ 205 ]: { "Reset Content", "This response tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI" }
        [ 206 ]: { "Partial Content", "The request has succeeded and the body contains the requested ranges of data, as described in the Range header of the request" }
        [ 207 ]: { "Multi-Status", "This response code indicates that there might be a mixture of responses" }
        [ 208 ]: { "Already Reported", "This response code is used in a 207 (207 Multi-Status) response to save space and avoid conflicts" }

        --[[--------------------
            Client Error 4XX
        --------------------]]--
        [ 400 ]: { "Bad Request", "The server was unable to interpret the request given invalid syntax" }
        [ 401 ]: { "Unauthorized", "Authentication is required to get the requested response" }
        [ 403 ]: { "Forbidden", "You don't have the necessary permissions for certain content, so the server is refusing to grant an appropriate response" }
        [ 404 ]: { "Not Found", "The server was unable to find the requested content" }
        [ 405 ]: { "Method Not Allowed", "The requested method is known to the server but it has been disabled and cannot be used" }
        [ 408 ]: { "Request Timeout", "A timeout has occurred while processing an HTTP request" }
        [ 409 ]: { "Conflict", "The server encountered a conflict with the request sent with the current state of the server" }
        [ 410 ]: { "Gone", "The requested content has been deleted from the server" }
        [ 411 ]: { "Length Required", "The server rejected the request because the Content-Length is not defined" }
        [ 418 ]: { "I'm a teapot", "This client error response code indicates that the server refuses to brew coffee because it is, permanently, a teapot." }
        [ 429 ]: { "Rate limit reached for requests", "This error message indicates that you have hit your assigned rate limit for the API" }

        --[[--------------------
            Server Error 5XX
        --------------------]]--
        [ 500 ]: { "Internal Server Error", "This response means that the server encountered an unexpected condition that prevented it from fulfilling the request" }
        [ 501 ]: { "Not Implemented", "This response means that the server does not support the functionality required to fulfill the request" }
        [ 502 ]: { "Bad Gateway", "This response means that the server, while acting as a gateway or proxy, received an invalid response from the upstream server" }
        [ 503 ]: { "Service Unavailable", "This response means that the server is not ready to handle the request" }
        [ 504 ]: { "Gateway Timeout", "This response means that the server, while acting as a gateway or proxy, did not get a response in time from the upstream server that it needed in order to complete the request" }
        [ 505 ]: { "HTTP Version Not Supported", "This response status code indicates that the HTTP version used in the request is not supported by the server" }
        [ 507 ]: { "Insufficient Storage", "This operation couldn't succeed, maybe because the request it's too large to fit on a disk" }
        [ 508 ]: { "Loop Detected", "This status indicates that the entire operation failed, the server terminated an operation because it encountered an infinite loop" }

    }

    http.Codes = codes

    http.GetStatusDescription = ( statusCode ) ->
        data = codes[ statusCode ]
        if data
            return data[ 1 ], data[ 2 ]

class util.Stack
    __tostring: =>
        return format( "Stack: %p [%d/%d]", @, @pointer, @size )

    new: ( size ) =>
        @size = ( isnumber( size ) and size > 0 ) and size or -1
        @pointer = 0

    isEmpty: =>
        return @pointer == 0

    isFull: =>
        return @pointer == @size

    peek: =>
        return @[ @pointer ]

    push: ( value ) =>
        pointer = @pointer
        if pointer ~= @size
            pointer += 1
            @[ pointer ] = value
            @pointer = pointer

        return pointer

    pop: =>
        pointer = @pointer
        if pointer == 0
            return nil

        @pointer = pointer - 1
        value = @[ pointer ]
        @[ pointer ] = nil
        return value

    empty: =>
        for index = 1, @pointer
            @[ index ] = nil

        @pointer = 0

--[[

    Queue References:
        https://github.com/darkwark/queue-lua
        https://en.wikipedia.org/wiki/Queue_(abstract_data_type)

--]]

class util.Queue
    __tostring: =>
        return format( "Queue: %p [%d/%d]", @, @pointer, @size )

    new: ( size ) =>
        @size = ( isnumber( size ) and size > 0 ) and size or -1
        @front = 1
        @rear = 0

    length: =>
        return ( @rear - @front ) + 1

    isEmpty: =>
        return @rear == 0

    isFull: =>
        return @length! == @size

    enqueue: ( value ) =>
        if @isFull!
            return

        rear = @rear + 1
        @rear = rear
        @[ rear ] = value

    dequeue: =>
        if @isEmpty!
            return nil

        front = @front
        value = @[ front ]
        @[ front ] = nil

        front += 1
        @front = front

        if ( front * 2 ) >= @rear
            @optimize!

        return value

    get: ( index ) =>
        return @[ @front + index ]

    set: ( index, value ) =>
        @[ @front + index ] = value

    optimize: =>
        pointer, buffer = 1, {}

        for index = @front, @rear
            buffer[ pointer ] = @[ index ]
            @[ index ] = nil
            pointer += 1

        for index = 1, pointer
            @[ index ] = buffer[ index ]

        @front = 1
        @rear = pointer - 1

    peek: =>
        return @[ @front ]

    empty: =>
        for index = @front, @rear
            @[ index ] = nil

    @__base.push = @__base.enqueue
    @__base.pop = @__base.dequeue

do

    import abs, floor, ldexp, frexp, pow2 from math
    import band, rshift from (bit or bit32)

    buffer = setmetatable( {}, { __mode: "v" } )
    boolean = { [ 0 ]: false, [ 1 ]: true }

    class util.ByteStream
        __tostring: =>
            return format( "ByteStream: %p [%d/%d]", @, @pointer, @length )

        new: ( data ) =>
            if isstring( data )
                @length = len( data )
                @Data = data
            else
                @length = 0
                @Data = ""

            @pointer = 0

        Close: =>
            @pointer = 0

        Flush: =>
            @pointer = 0
            @length = 0
            @Data = ""

        Size: =>
            return @length

        Tell: =>
            return @pointer

        Seek: ( pointer ) =>
            if pointer
                ArgAssert( pointer, 2, "number" )
                pointer = min( max( pointer, 0 ), @length )
            else
                pointer = 0

            @pointer = pointer
            return pointer

        Skip: ( bytes ) =>
            if bytes
                ArgAssert( bytes, 2, "number" )
            else
                bytes = 1

            return @Seek( @pointer + bytes )

        EndOfFile: =>
            return @pointer >= @length

        -- Binary data
        Read: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes <= 0 or @EndOfFile!
                return

            pointer = @pointer
            @Skip( bytes )

            return sub( @Data, pointer + 1, pointer + bytes )

        Write: ( data ) =>
            length, size = @length, len( data )
            @Data = sub( @Data, 1, @pointer ) .. data .. sub( @Data, @pointer + 1, length )
            @length = length + size
            return @Skip( size )

        -- String
        ReadString: =>
            pointer, length = @pointer, @length
            if pointer >= length
                return

            bytes, data = 0, @Data
            for index = pointer, length
                if byte( data, index + 1 ) == 0
                    break

                bytes += 1

            if bytes == 0
                return

            return @Read( bytes ), @Skip( 1 )

        WriteString: ( str ) =>
            return @Write( str .. "\0" )

        -- Line
        ReadLine: =>
            pointer, length = @pointer, @length
            if pointer >= length
                return

            bytes, data = 0, @Data
            for index = pointer, length
                if byte( data, index + 1 ) == 0xA --[[ \n ]]
                    break

                bytes += 1

            if bytes == 0
                return "", @Skip( 1 )

            return @Read( bytes ), @Skip( 1 )

        WriteLine: ( str ) =>
            return @Write( str .. "\n" )

        -- Byte
        ReadByte: =>
            if @EndOfFile!
                return

            return byte( @Data, @Skip( 1 ) )

        WriteByte: ( number ) =>
            return @Write( char( number ) )

        -- Boolean
        ReadBool: =>
            return boolean[ @ReadByte! or -1 ]

        WriteBool: ( bool ) =>
            return @WriteByte( bool and 1 or 0 )

        -- UInt
        ReadUInt: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return

            uint = 0
            for index = 1, bytes
                number = @ReadByte!
                if number == nil
                    return

                uint += number * 0x100 ^ ( index - 1 )

            return uint

        WriteUInt: ( number, bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return @pointer

            for index = 1, bytes
                buffer[ index ] = char( band( number, 0xFF ) )
                number = rshift( number, 8 )

            return @Write( concat( buffer, "", 1, bytes ) )

        -- UShort
        ReadUShort: =>
            return @ReadUInt( 2 )

        WriteUShort: ( number ) =>
            return @WriteUInt( number, 2 )

        -- ULong
        ReadULong: =>
            return @ReadUInt( 4 )

        WriteULong: ( number ) =>
            return @WriteUInt( number, 4 )

        -- UInt64
        ReadUInt64: =>
            return @ReadUInt( 8 )

        WriteUInt64: ( number ) =>
            @WriteUInt( number, 8 )

        -- Int
        ReadInt: ( bytes ) =>
            ArgAssert( bytes, 2, "number" )
            if bytes == 0
                return

            uint = @ReadUInt( bytes )
            if uint == nil
                return

            limit = 0x100 ^ abs( bytes )
            if uint >= ( limit / 2 )
                return uint - limit

            return uint

        WriteInt: ( number, bytes ) =>
            for index = 1, bytes
                buffer[ index ] = char( number % 0x100 )
                number = floor( number / 0x100 )

            return @Write( concat( buffer, "", 1, bytes ) )

        -- Short
        ReadShort: =>
            return @ReadInt( 2 )

        WriteShort: ( number ) =>
            return @WriteInt( number, 2 )

        -- Long
        ReadLong: =>
            return @ReadInt( 4 )

        WriteLong: ( number ) =>
            return @WriteInt( number, 4 )

        -- Int64
        ReadInt64: =>
            return @ReadInt( 8 )

        WriteInt64: ( number ) =>
            return @WriteInt( number, 8 )

        -- Float
        ReadFloat: =>
            binary = @Read( 4 )
            if not binary or len( binary ) ~= 4
                return

            byte1, byte2, byte3, byte4 = byte( binary, 1, 4 )
            exponent = byte4 % 0x80 * 2 + floor( byte3 / 0x80 ) - 0x7F
            if exponent == 0x7F
                return 0

            return ldexp( ldexp( byte3 % 0x80 * 0x10000 + byte2 * 0x100 + byte1, -23 ) + 1, exponent ) * ( byte4 < 0x80 and 1 or -1 )

        WriteFloat: ( num ) =>
            -- TODO: Write this

        -- Double ( https://gist.github.com/Kubuxu/e5e04c028d8aaeab4be8 )
        ReadDouble: =>
            binary = @Read( 8 )
            if not binary or len( binary ) ~= 8
                return

            bytes = { byte( binary, 1, 8 ) }
            byte8, byte7 = bytes[ 8 ], bytes[ 7 ]

            sign = 1
            if byte8 > 127
                sign = -1

            exponent = ( byte8 % 0x80 ) * 16 + floor( byte7 / 16 )
            if exponent == 0
                return 0

            mantissa = byte7 % 16
            for index = 6, 1, -1
                mantissa = mantissa * 0x100 + bytes[ index ]

            mantissa = ( ldexp( mantissa, -52 ) + 1 ) * sign
            return ldexp( mantissa, exponent - 1023 )

        WriteDouble: ( number ) =>
            if number == 0
                return char( 0, 0, 0, 0, 0, 0, 0, 0 )

            absNumber = abs( number )

            mantissa, exponent = frexp( absNumber )
            mantissa = ( mantissa * 2 - 1 ) * 16
            exponent -= 1

            currentMantissa = floor( mantissa )
            mantissa -= currentMantissa

            sign = number ~= absNumber and 0x80 or 0
            exponent = exponent + 1023

            bytes = { 0, 0, 0, 0, 0, 0, ( exponent % 16 ) * 16 + currentMantissa, sign + floor( exponent / 16 ) }

            for index = 6, 1, -1
                mantissa = mantissa * 0x100
                currentMantissa = floor( mantissa )
                mantissa = mantissa - currentMantissa
                bytes[ index ] = currentMantissa

            return @Write( char( bytes[ 1 ], bytes[ 2 ], bytes[ 3 ], bytes[ 4 ], bytes[ 5 ], bytes[ 6 ], bytes[ 7 ], bytes[ 8 ] ) )

do

    import Simple from timer

    util.NextTick = ( func, a, b, c, d, e, f ) ->
        return Simple 0, ->
            func( a, b, c, d, e, f )
            return
