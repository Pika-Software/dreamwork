_G = _G
import gpm, SERVER from _G
import environment, Logger from gpm
import istable, pcall, require, tonumber, tostring from _G
import bit, math, string, table, os, util, argument, isstring, isnumber, isfunction, throw, type from environment
import char, byte, sub, gsub, len, find, format, match from string
import CRC, IsBinaryModuleInstalled from util
import concat, unpack from table
newClass = environment.class
import clamp from math
import time from os

do

    import BInt, struct from environment
    import FromBytes, ToBytes, ToNumber, CastSigned from BInt
    import io from struct

    local setEndianness
    do

        import Little, Set from io.endianness
        import Read from io.i

        setEndianness = ( isBigEndian ) ->
            if isBigEndian
                Set( "big" )
                return true

            Set( "little" )
            return false

    local readUInt, writeUInt
    do
        uint = io.I
        readUInt, writeUInt = uint.Read, uint.Write

    local SteamID
    do

        import IsSteamID, IsSteamID64 from string
        import setmetatable from _G
        import fdiv from math

        -- https://developer.valvesoftware.com/wiki/SteamID

        universes = {
            -- 4503603922337792
            [ 0 ]: { "450", 3603922337792, 3 }
            -- 76561197960265728
            [ 1 ]: { "765", 61197960265728, 3 }
            -- 148618791998193664
            [ 2 ]: { "1486", 18791998193664, 4 }
            -- 220676386036121600
            [ 3 ]: { "2206", 76386036121600, 4 }
            -- 292733980074049536
            [ 4 ]: { "2927", 33980074049536, 4 }
            -- 364791574111977472
            [ 5 ]: { "3647", 91574111977472, 4 }
        }

        util.SteamIDTo64 = ( str, fullUniverse ) ->
            x, y, z = match( str, "^STEAM_([0-5]):([01]):(%d+)$" )

            universe = tonumber( x, 10 )
            if not fullUniverse and universe == 0
                universe = 1

            data = universes[ universe ]
            return data[ 1 ] .. ( ( tonumber( z, 10 ) * 2 ) + data[ 2 ] ) + ( y == "1" and 1 or 0 )

        util.SteamIDFrom64 = ( str, skipUniverse ) ->
            local account_id, universe
            if skipUniverse == false
                for i = 0, 5
                    data = universes[ i ]
                    if data[ 1 ] == sub( str, 1, data[ 3 ] )
                        account_id = tonumber( sub( str, data[ 3 ] + 1 ), 10 ) - data[ 2 ]
                        universe = i
                        break

                unless universe
                    universe = 1
            else
                universe = 0
                account_id = tonumber( sub( str, 4 ), 10 ) - 61197960265728

            return "STEAM_"  .. ( universe or 0 ) .. ":" .. ( account_id % 2 == 0 and "0" or "1" ) .. ":" .. fdiv( account_id, 2 )

        metatable = {
            new: ( str, fullUniverse ) =>
                argument( str, 1, "string" )

                if IsSteamID64( str )
                    local account_id, universe
                    if fullUniverse
                        for i = 0, 5
                            data = universes[ i ]
                            if data[ 1 ] == sub( str, 1, data[ 3 ] )
                                account_id = tonumber( sub( str, data[ 3 ] + 1 ), 10 ) - data[ 2 ]
                                universe = i
                                break

                        unless universe
                            universe = 1
                    else
                        universe = 1
                        account_id = tonumber( sub( str, 4 ), 10 ) - 61197960265728

                    @universe, @id, @account_number, @account_id = universe, account_id % 2 ~= 0, fdiv( account_id, 2 ), account_id
                    return nil

                if IsSteamID( str )
                    x, y, z = match( str, "^STEAM_([0-5]):([01]):(%d+)$" )
                    universe, id, account_number = tonumber( x, 10 ), y == "1", tonumber( z, 10 )

                    if not fullUniverse and universe == 0
                        universe = 1

                    @universe, @id, @account_number, @account_id = universe, id, account_number, ( account_number * 2 ) + ( id and 1 or 0 )
                    return nil

                throw "Invalid SteamID", 3
                return nil

            ToXYZ: =>
                return @universe, @id, @account_number

            ToIntegers: =>
                return @universe, @id and 1 or 0, @account_number

            ToSteamID: =>
                return "STEAM_" .. @universe .. ":" .. ( @id and "1" or "0" ) .. ":" .. @account_number

            ToSteamID64: =>
                data = universes[ @universe ]
                return data[ 1 ] .. ( @account_id + data[ 2 ] )

            GetProfileURL: =>
                return "https://steamcommunity.com/profiles/" .. @ToSteamID64!

            ToAccountID: =>
                return @account_id

            ToHex: =>
                return format( "0x%x", @account_id )

            ToSteamID3: =>
                return "[U:" .. @universe .. ":" .. @account_id .. "]"

            ToBinary: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return writeUInt( nil, @account_id, 4 )

            GetUniverse: =>
                return @universe

            SetUniverse: ( universe ) =>
                argument( universe, 1, "number" )
                if universe < 0 or universe > 5
                    throw( "Invalid SteamID universe", 2 )

                @universe = universe
                return @

        }

        metatable.__tostring = metatable.ToSteamID

        metatable.__eq = ( other ) =>
            return getmetatable( other ) == metatable and @universe == other.universe and @id == other.id and @account_number == other.account_number

        SteamID = newClass( "SteamID", metatable, {
            IsValid: ( steamid ) ->
                argument( steamid, 1, "string" )
                return IsSteamID( steamid )

            FromSteamID: ( steamid ) ->
                argument( steamid, 1, "string" )

                unless IsSteamID( steamid )
                    throw( "Invalid SteamID", 2 )

                x, y, z = match( steamid, "^STEAM_([0-5]):([01]):(%d+)$" )
                id, account_number = y == "1", tonumber( z, 10 )

                return setmetatable( {
                    universe: tonumber( x, 10 )
                    id: id
                    account_number: account_number
                    account_id: ( account_number * 2 ) + ( id and 1 or 0 )
                }, metatable )

            FromSteamID64: ( steamid64, fullUniverse ) ->
                steamid64 = tostring( steamid64 )

                local account_id, universe
                if fullUniverse
                    for i = 0, 5
                        data = universes[ i ]
                        if data[ 1 ] == sub( steamid64, 1, data[ 3 ] )
                            account_id = tonumber( sub( steamid64, data[ 3 ] + 1 ), 10 ) - data[ 2 ]
                            universe = i
                            break

                    unless universe
                        universe = 1
                else
                    universe = 1
                    account_id = tonumber( sub( steamid64, 4 ), 10 ) - 61197960265728

                return setmetatable( {
                    universe: universe
                    id: account_id % 2 ~= 0
                    account_number: fdiv( account_id, 2 )
                    account_id: account_id
                }, metatable )

            FromSteamID3: ( sid3 ) ->
                x, z = match( sid3, "^%[?U:(%d):(%d+)%]?$" )

                account_number = tonumber( z, 10 ) or -1
                if account_number < 0
                    throw( "Invalid SteamID3", 2 )

                account_number, id = fdiv( account_number, 2 ), z % 2 ~= 0

                return setmetatable( {
                    universe: tonumber( x, 10 )
                    id: id
                    account_number: account_number
                    account_id: ( account_number * 2 ) + ( id and 1 or 0 )
                }, metatable )

            FromBinary: ( binary, isBigEndian ) ->
                setEndianness( isBigEndian )

                account_id = readUInt( nil, binary, 4 ) or -1
                if account_id < 0
                    throw( "Invalid binary SteamID", 2 )

                return setmetatable( {
                    universe: 1
                    id: account_id % 2 ~= 0
                    account_number: fdiv( account_id, 2 )
                    account_id: account_id
                }, metatable )

            FromHex: ( hex ) ->
                unless isnumber( hex )
                    hex = tonumber( hex, 16 )

                argument( hex, 1, "number" )

                if hex < 0
                    throw( "Invalid hex", 2 )

                return setmetatable( {
                    universe: 1
                    id: hex % 2 ~= 0
                    account_number: fdiv( hex, 2 )
                    account_id: hex
                }, metatable )

            FromAccountID: ( account_id ) ->
                argument( account_id, 1, "number" )

                return setmetatable( {
                    universe: 1
                    id: account_id % 2 ~= 0
                    account_number: fdiv( account_id, 2 )
                    account_id: account_id
                }, metatable )
        } )

        environment.SteamID = SteamID

    -- lua 5.3 string features
    do

        import Read, Write from struct

        string.pack = ( fmt, ... ) ->
            return Write( fmt, { ... } )

        string.unpack = ( fmt, binary, offset ) ->
            if offset
                return unpack( Read( fmt, sub( binary, offset, len( binary ) ) ) )

            return unpack( Read( fmt, binary ) )

        string.packsize = struct.SizeOf

    -- Byte Stream
    import deflate, Color from environment
    import unix2dos, dos2unix from os

    local readInt, writeInt
    do
        int = io.i
        readInt, writeInt = int.Read, int.Write

    local readFloat, writeFloat
    do
        float = io.f
        readFloat, writeFloat = float.Read, float.Write

    local readDouble, writeDouble
    do
        double = io.d
        readDouble, writeDouble = double.Read, double.Write

    noCompression = ( content ) ->
        return content

    compressionMethods = {
        -- No compression
        [ 0 ]: {
            [1]: noCompression,
            [2]: noCompression
        },

        -- Deflate
        [ 8 ]: {
            [1]: deflate.CompressDeflate,
            [2]: deflate.DecompressDeflate
        }
    }

    seek = ( position ) =>
        @Flush!

        if position
            argument( position, 2, "number" )
            position = clamp( position, 0, @size )
        else
            position = 0

        @pointer = position
        return position

    util.ByteStream = newClass(
        "ByteStream",
        {
            __tostring: =>
                return format( "ByteStream: %p [%d/%d]", @, @pointer, @size )

            IsValid: =>
                return @data ~= nil

            EndOfFile: =>
                return @pointer >= @size

            Size: =>
                return @size

            Tell: =>
                return @pointer

            Close: =>
                @Flush!
                @pointer = 0

            Seek: seek
            SeekTo: seek

            SeekToBegin: =>
                return @Seek( 0 )

            SeekToEnd: =>
                return @Seek( @size - @pointer )

            SkipEmpty: =>
                while not @EndOfFile!
                    if @ReadByte! ~= 0
                        @Skip( -1 )
                        break

            Skip: ( length ) =>
                if length
                    argument( length, 2, "number" )
                else
                    length = 1

                return @Seek( @pointer + length )

            -- Byte read
            Read: ( length ) =>
                :pointer, :size = @
                if length == "*a" or length == nil
                    length = size

                argument( length, 2, "number" )

                if length > 0
                    if pointer >= size
                        return nil, "eof"

                    return sub( @data, pointer + 1, @Skip( length ) )

                if length < 0
                    if pointer <= 0
                        return nil, "sof"

                    return sub( @data, @Skip( length ), pointer + 1 )

                return nil, "no data"

            ReadAll: =>
                @SeekToBegin!
                return @Read( @size )

            -- String
            ReadString: =>
                :pointer, :size = @
                if pointer >= size
                    return nil, "eof"

                length, data = 0, @data
                for index = pointer, size
                    if byte( data, index + 1 ) == 0
                        break

                    length += 1

                if length == 0
                    @Skip( 1 )
                    return nil

                str = @Read( length )
                @Skip( 1 )
                return str

            WriteString: ( str ) =>
                argument( str, 1, "string" )
                return @Write( str .. "\0" )

            -- Line
            ReadLine: =>
                :pointer, :size = @
                if pointer >= size
                    return nil, "eof"

                length, data = 0, @data
                for index = pointer, size
                    if byte( data, index + 1 ) == 0xA --[[ \n ]]
                        break

                    length += 1

                if length == 0
                    @Skip( 1 )
                    return nil

                return @Read( length )

            WriteLine: ( str ) =>
                argument( str, 1, "string" )
                return @Write( str .. "\n" )

            -- Byte
            ReadByte: =>
                if @EndOfFile!
                    return nil, "eof"

                return byte( @data, @Skip( 1 ) )

            WriteByte: ( number ) =>
                return @Write( char( number ) )

            -- Signed Byte
            ReadSignedByte: =>
                return @ReadByte! - 0x80

            WriteSignedByte: ( number ) =>
                return @WriteByte( number + 0x80 )

            -- Boolean
            ReadBool: =>
                if @EndOfFile!
                    return nil, "eof"
                else
                    return @ReadByte! ~= 0

            WriteBool: ( bool ) =>
                return @Write( bool and "\1" or "\0" )

            -- UInt
            ReadUInt: ( bytes, isBigEndian ) =>
                argument( bytes, 2, "number" )
                setEndianness( isBigEndian )
                return readUInt( nil, @Read( bytes ), bytes )

            WriteUInt: ( number, bytes, isBigEndian ) =>
                argument( number, 1, "number" )
                argument( bytes, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeUInt( nil, number, bytes ) )

            -- UShort
            ReadUShort: ( isBigEndian ) =>
                return @ReadUInt( 2, isBigEndian )

            WriteUShort: ( number, isBigEndian ) =>
                return @WriteUInt( number, 2, isBigEndian )

            -- ULong
            ReadULong: ( isBigEndian ) =>
                return @ReadUInt( 4, isBigEndian )

            WriteULong: ( number, isBigEndian ) =>
                return @WriteUInt( number, 4, isBigEndian )

            -- UInt64
            ReadUInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readUInt( nil, sub( binary, 3 ), 6 )

                    return FromBytes( binary, false )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readUInt( nil, binary, 6 )

                return FromBytes( binary, true )

            WriteUInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( ToBytes( number, 8, false ) )

                    return @Write( ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @Write( "\0\0" )

                    if isBint
                        return @Write( writeUInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeUInt( nil, number, 6 ) )

                if isBint
                    @Write( writeUInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeUInt( nil, number, 6 ) )

                return @Write( "\0\0" )

            -- Int
            ReadInt: ( bytes, isBigEndian ) =>
                argument( bytes, 2, "number" )
                setEndianness( isBigEndian )
                return readInt( nil, @Read( bytes ), bytes )

            WriteInt: ( number, bytes, isBigEndian ) =>
                argument( number, 1, "number" )
                argument( bytes, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeInt( nil, number, bytes ) )

            -- Short
            ReadShort: ( isBigEndian ) =>
                return @ReadInt( 2, isBigEndian )

            WriteShort: ( number, isBigEndian ) =>
                return @WriteInt( number, 2, isBigEndian )

            -- Long
            ReadLong: ( isBigEndian ) =>
                return @ReadInt( 4, isBigEndian )

            WriteLong: ( number, isBigEndian ) =>
                return @WriteInt( number, 4, isBigEndian )

            -- Int64
            ReadInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readInt( nil, sub( binary, 3 ), 6 )

                    return CastSigned( FromBytes( binary, false ), 8 )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readInt( nil, binary, 6 )

                return CastSigned( FromBytes( binary, true ), 8 )

            WriteInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( ToBytes( number, 8, false ) )

                    return @Write( ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @Write( "\0\0" )

                    if isBint
                        return @Write( writeInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeInt( nil, number, 6 ) )

                if isBint
                    @Write( writeInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeInt( nil, number, 6 ) )

                return @Write( "\0\0" )

            -- Float
            ReadFloat: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readFloat( nil, @Read( 4 ) )

            WriteFloat: ( number, isBigEndian ) =>
                argument( number, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeFloat( nil, number ) )

            -- Double
            ReadDouble: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readDouble( nil, @Read( 8 ) )

            WriteDouble: ( number, isBigEndian ) =>
                argument( number, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeDouble( nil, number ) )

            -- Time
            ReadTime: =>
                return dos2unix( @ReadUShort!, @ReadUShort! )

            WriteTime: ( u ) =>
                t, d = unix2dos( u )
                @WriteUShort( t )
                return @WriteUShort( d )

            -- ZipFile ( https://medium.com/@felixstridsberg/the-zip-file-format-6c8a160d1c34 )
            ReadZipFile: ( doCRC ) =>
                if @Read( 4 ) ~= "PK\x03\x04"
                    return

                data = {}

                @Skip( 4 )

                compressionMethod = data.compression = @ReadUShort!
                data.time = @ReadTime!

                crc = data.crc = @ReadULong!
                compressedSize = @ReadULong!
                data.size = @ReadULong!

                pathLength = @ReadUShort!
                extraLength = @ReadUShort!

                data.path = @Read( pathLength )
                @Skip( extraLength )

                method = compressionMethods[ compressionMethod ]
                unless method
                    return data, "compression method not supported"

                content = data.content = method[ 2 ]( @Read( compressedSize ) )

                if doCRC and content and crc ~= CRC( content )
                    return data, "crc-32 mismatch"

                return data

            WriteZipFile: ( fileName, content, compressionMethod = 0, unixTime = time! ) =>
                argument( fileName, 1, "string" )
                argument( content, 2, "string" )
                argument( compressionMethod, 3, "number" )
                argument( unixTime, 4, "number" )

                -- signature
                @Write( "PK\x03\x04" )

                -- Version needed to extract (minimum)
                @WriteUShort( 0 )

                -- General purpose bit flag
                @WriteUShort( 0 )

                method = compressionMethods[ compressionMethod ]
                unless method
                    throw "Unsupported compression method: " .. compressionMethod
                    return nil

                -- Compression method
                @WriteUShort( compressionMethod )

                -- Modification time
                @WriteTime( unixTime )

                -- CRC-32
                @WriteULong( tonumber( CRC( content ), 10 ) )
                fileSize = len( content )

                content = method[ 1 ]( content )

                -- Compressed size
                @WriteULong( len( content ) )

                -- Uncompressed size
                @WriteULong( fileSize )

                -- File name length
                @WriteUShort( len( fileName ) )

                -- Extra field length
                @WriteUShort( 0 )

                @Write( fileName )
                return @Write( content )

            -- Color
            ReadColor: =>
                return Color( byte( @Read( 4 ) ) )

            WriteColor: ( color ) =>
                return @Write( char( color.r, color.g, color.b, color.a ) )

            -- SteamID
            ReadSteamID: ( isBigEndian, withUniverse ) =>
                return SteamID.FromBinary( @Read( withUniverse and 5 or 4 ), setEndianness( isBigEndian ), withUniverse )

            WriteSteamID: ( steamid, withUniverse ) =>
                if isstring( steamid )
                    steamid = SteamID( steamid )

                argument( steamid, 1, "SteamID" )
                return @Write( steamid\ToBinary( withUniverse ) )

        },
        {
            CompressionMethods: compressionMethods
        },
        struct.Cursor
    )

    do

        import ceil, max, pow2, floor, isuint from math
        import Insert, Reverse from table
        string_ToBytes = string.ToBytes
        import band from bit

        metatable = {
            __tostring: =>
                return format( "BitStream: %p [%d/%d]", @, @pointer, @size )

            new: ( binary ) =>
                @buffer_size = 0
                @pointer = 0
                @buffer = {}

                if binary
                    argument( binary, 1, "string" )
                    bits, size = {}, 0

                    for uint in *{ byte( binary, 1, len( binary ) ) }
                        for i = 0, 7, 1
                            size += 1
                            bits[ size ] = band( uint, pow2[ i ] ) ~= 0

                    @bits, @size = bits, size
                    return nil

                @bits, @size = {}, 0
                return nil

            Flush: =>
                :buffer_size = @
                if buffer_size == 0
                    return @bits

                :bits, :pointer, :size = @

                if pointer > size
                    for index = size, pointer
                        bits[ index ] = false

                    size = pointer

                Insert( @buffer, pointer, buffer_size, pointer, bits )

                @pointer = pointer + buffer_size
                @size = size + buffer_size

                @buffer_size = 0
                @buffer = {}
                return bits

            Size: ( inBytes ) =>
                if inBytes
                    return ceil( @size * 0.125 )

                return @size

            SkipZeros: =>
                pointer = @pointer + 1
                :bits, :size = @

                while pointer <= size
                    pointer += 1

                    if bits[ pointer ]
                        pointer -= 1
                        break

                return @Seek( pointer )

            -- Bits
            ReadBits: ( length ) =>
                @Flush!

                :pointer, :size = @
                if length == "*a" or length == nil
                    length = size

                argument( length, 2, "number" )

                if length > 0
                    if pointer >= size
                        return nil, "eof"

                    return unpack( @bits, pointer + 1, pointer + length )

                if length < 0
                    if pointer <= 0
                        return nil, "sof"

                    start, finish = pointer + 1, pointer + length
                    return unpack( Reverse( { unpack( @bits, start, finish ) }, false ), start, finish )

                return nil

            WriteBits: ( ... ) =>
                :buffer, :buffer_size = @

                for value in *{ ... }
                    buffer_size += 1
                    buffer[ buffer_size ] = value == true

                @buffer_size = buffer_size
                return nil

            -- Boolean
            ReadBit: =>
                if @EndOfFile!
                    return nil, "eof"

                return @bits[ @Skip( 1 ) ] == true

            WriteBit: ( bool ) =>
                buffer_size = @buffer_size + 1
                @buffer[ buffer_size ] = bool == true
                @buffer_size = buffer_size
                return nil

            -- Byte
            ReadByte: =>
                :pointer = @
                if pointer >= @size
                    return nil, "eof"

                @pointer = pointer + 8
                :bits = @

                return ( bits[ pointer + 1 ] and 1 or 0 ) +
                    ( bits[ pointer + 2 ] and 2 or 0 ) +
                    ( bits[ pointer + 3 ] and 4 or 0 ) +
                    ( bits[ pointer + 4 ] and 8 or 0 ) +
                    ( bits[ pointer + 5 ] and 16 or 0 ) +
                    ( bits[ pointer + 6 ] and 32 or 0 ) +
                    ( bits[ pointer + 7 ] and 64 or 0 ) +
                    ( bits[ pointer + 8 ] and 128 or 0 )

            WriteByte: ( uint ) =>
                argument( uint, 1, "number" )

                if uint < 0 or uint > 255
                    throw "Invalid byte value", 2

                :buffer, :buffer_size = @

                for i = 0, 7
                    buffer_size += 1
                    buffer[ buffer_size ] = band( uint, pow2[ i ] ) ~= 0

                @buffer_size = buffer_size
                return @

            WriteNull: =>
                :buffer, :buffer_size = @

                for i = 1, 8
                    buffer_size += 1
                    buffer[ buffer_size ] = false

                @buffer_size = buffer_size
                return @

            -- Bytes
            Read: ( length ) =>
                @Flush!

                :pointer, :size = @

                local isNegative
                if length == nil
                    length = ceil( ( size - pointer ) / 8 )
                    isNegative = false
                elseif length == 0
                    return nil, "no data"
                else
                    isNegative = length < 0
                    if isNegative
                        if pointer <= 0
                            return nil, "sof"

                        length = max( -length, ceil( pointer / 8 ) )
                    elseif pointer >= size
                        return nil, "eof"
                    else
                        length = max( length, ceil( ( size - pointer ) / 8 ) )

                bytes = {}
                :bits = @

                if isNegative
                    @Skip( -length * 8 )
                    return @Read( length )

                for i = 1, length, 1
                    pointer += 1
                    uint = 0

                    for j = 0, 7, 1
                        if bits[ pointer + j ] == true
                            uint += pow2[ j ]

                    pointer += 7
                    bytes[ i ] = char( uint )

                @pointer = pointer

                return concat( bytes, "", 1, length )

            Write: ( str ) =>
                argument( str, 1, "string" )
                :buffer, :buffer_size = @

                for uint in *{ byte( str, 1, len( str ) ) }
                    for j = 0, 7, 1
                        buffer_size += 1
                        buffer[ buffer_size ] = band( uint, pow2[ j ] ) ~= 0

                @buffer_size = buffer_size
                return @

            -- String
            ReadString: =>
                :pointer = @
                if pointer >= @size
                    return nil, "eof"

                parts, length = {}, 0

                uint = @ReadByte!
                while uint ~= 0
                    length += 1
                    parts[ length ] = char( uint )
                    uint = @ReadByte!

                if length == 0
                    return nil, "no data"

                return concat( parts, "", 1, length )

            WriteString: ( str ) =>
                argument( str, 1, "string" )
                @Write( str .. "\0" )
                return @

            ReadLine: =>
                :pointer, :size = @
                if pointer >= size
                    return nil, "eof"

                length = 0
                for index = pointer, size
                    uint = @ReadByte!
                    unless uint
                        return nil, "eof"

                    if uint == 0xA --[[ \n ]] or uint == 0
                        break

                    length += 1

                if length == 0
                    return nil

                @Seek( pointer )
                return @Read( length )

            -- Binary String
            ReadBinaryString: =>
                :pointer, :size, :bits = @
                chars, count = {}, 0

                for index = pointer + 1, size, 1
                    count += 1
                    chars[ count ] = bits[ index ] and "1" or "0"

                @pointer = size

                return concat( chars, "", 1, count )

            WriteBinaryString: ( str ) =>
                argument( str, 1, "string" )

                :buffer, :buffer_size = @

                bytes, length = string_ToBytes( str )
                for i = 1, length
                    buffer_size += 1
                    buffer[ buffer_size ] = bytes[ i ] == 0x31

                @buffer_size = buffer_size
                return @

            -- UInt
            ReadUInt: ( bitCount ) =>
                if bitCount == 0
                    return 0
                elseif bitCount < 0
                    throw "uint cannot be negative", 2

                unless isuint( bitCount )
                    bitCount = ceil( bitCount )

                @Flush!

                :pointer = @
                endPos = pointer + bitCount
                if endPos > @size
                    return nil, "eof"

                @position = pointer
                :bits = @
                uint = 0

                for i = pointer + 1, endPos, 1
                    if bits[ i ] == true
                        uint += pow2[ bitCount - i ]

                return uint

            WriteUInt: ( uint, bitCount, isBigEndian ) =>
                argument( uint, 1, "number" )
                argument( bitCount, 2, "number" )

                bitCount = max( isuint( bitCount ) and bitCount or ceil( bitCount ), 0 )
                if bitCount == 0
                    return @

                if uint > ( pow2[ bitCount ] - 1 )
                    throw format( "UInt '%i' cannot fit in %i bits (max: %i)", uint, bitCount, pow2[ bitCount ] - 1 ), 2

                :buffer, :buffer_size = @

                for i = bitCount - 1, 0, -1
                    if uint == 0
                        for j = buffer_size + ( i + 1 ), buffer_size + 1, -1
                            buffer[ j ] = false
                        break
                    else
                        buffer[ buffer_size + ( i + 1 ) ] = uint % 2 == 1
                        uint = floor( uint * 0.5 )

                @buffer_size = buffer_size + bitCount
                return @

            -- UShort
            ReadUShort: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readUInt( nil, @Read( 2 ), 2 )

            WriteUShort: ( number, isBigEndian ) =>
                argument( number, 1, "number" )
                setEndianness( isBigEndian )
                return @Write( writeUInt( nil, number, 2 ) )

            -- ULong
            ReadULong: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readUInt( nil, @Read( 4 ), 4 )

            WriteULong: ( number, isBigEndian ) =>
                argument( number, 1, "number" )
                setEndianness( isBigEndian )
                return @Write( writeUInt( nil, number, 4 ) )

            -- Int
            ReadInt: ( bitCount ) =>
                return @ReadUInt( bitCount ) - pow2[ bitCount - 1 ]

            WriteInt: ( int, bitCount ) =>
                return @WriteUInt( int + pow2[ bitCount - 1 ], bitCount )

            -- Short
            ReadShort: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readInt( nil, @Read( 2 ), 2 )

            WriteShort: ( number, isBigEndian ) =>
                argument( number, 1, "number" )
                setEndianness( isBigEndian )
                return @Write( writeInt( nil, number, 2 ) )

            -- Long
            ReadLong: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readInt( nil, @Read( 4 ), 4 )

            WriteLong: ( number, isBigEndian ) =>
                argument( number, 1, "number" )
                setEndianness( isBigEndian )
                return @Write( writeInt( nil, number, 4 ) )

            -- UInt64
            ReadUInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readUInt( nil, sub( binary, 3 ), 6 )

                    return FromBytes( binary, false )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readUInt( nil, binary, 6 )

                return FromBytes( binary, true )

            WriteUInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( string_ToBytes( number, 8, false ) )

                    return @Write( string_ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @WriteNull!
                    @WriteNull!

                    if isBint
                        return @Write( writeUInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeUInt( nil, number, 6 ) )

                if isBint
                    @Write( writeUInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeUInt( nil, number, 6 ) )

                @WriteNull!
                return @WriteNull!

            -- Int64
            ReadInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readInt( nil, sub( binary, 3 ), 6 )

                    return CastSigned( FromBytes( binary, false ), 8 )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readInt( nil, binary, 6 )

                return CastSigned( FromBytes( binary, true ), 8 )

            WriteInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( string_ToBytes( number, 8, false ) )

                    return @Write( string_ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @WriteNull!
                    @WriteNull!

                    if isBint
                        return @Write( writeInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeInt( nil, number, 6 ) )

                if isBint
                    @Write( writeInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeInt( nil, number, 6 ) )

                @WriteNull!
                return @WriteNull!

            -- Color
            ReadColor: =>
                return Color( @ReadByte!, @ReadByte!, @ReadByte!, @ReadByte! )

            WriteColor: ( color ) =>
                @WriteByte( color.r )
                @WriteByte( color.g )
                @WriteByte( color.b )
                return @WriteByte( color.a )

        }

        -- Yep, in bitstream bool is a bit
        metatable.ReadBool = metatable.ReadBit
        metatable.WriteBool = metatable.WriteBit

        import inf, nan, isnegative, ldexp, frexp from math
        import implode, explode from struct

        -- Float
        do

            -- constants
            c0 = pow2[ 7 ]
            c1 = pow2[ 8 ] - 1
            c2 = pow2[ 23 ]
            c3 = 1 - 23 - c0
            c4 = pow2[ 22 ]
            bias = c0 - 1
            c5 = bias + 1
            c6 = pow2[ 24 ]

            metatable.ReadFloat = =>
                @Flush!

                :pointer = @
                endPos = pointer + 32
                if endPos > @size
                    return nil, "eof"

                :bits = @

                fraction = implode( bits, 23, pointer )
                exponent = implode( bits, 8, pointer + 23 )
                sign = bits[ endPos ] and -1 or 1

                if exponent == c1
                    if fraction == 0 or sign == -1
                        return sign * inf

                    return nan

                if exponent ~= 0
                    fraction += c2
                else
                    exponent = 1

                return sign * ldexp( fraction, exponent + c3 )

            metatable.WriteFloat = ( float ) =>
                argument( float, 1, "number" )

                local sign
                if isnegative( float )
                    sign = true
                    float = -float
                else
                    sign = false

                local exponent, fraction

                if float == inf
                    exponent = c5
                    fraction = 0

                elseif float ~= float
                    exponent = c5
                    fraction = c4

                elseif float == 0
                    exponent = -bias
                    fraction = 0

                else
                    fraction, exponent = frexp( float )

                    ebs = exponent + bias
                    if ebs <= 1
                        fraction *= pow2[ 22 + ebs ]
                        exponent = -bias

                    else
                        fraction -= 0.5
                        exponent -= 1

                        fraction *= c6

                bits = explode( fraction )
                exponentBits = explode( exponent + bias )

                for index = 1, 8
                    bits[ 23 + index ] = exponentBits[ index ]

                bits[ 32 ] = sign

                :buffer, :buffer_size = @

                for index = 1, 32
                    buffer_size += 1
                    buffer[ buffer_size ] = bits[ index ] == true

                @buffer_size = buffer_size
                return @

        -- Double
        do

            -- constants
            c0 = pow2[ 11 ] - 1
            c1 = pow2[ 52 ]
            c2 = pow2[ 10 ]
            c3 = 1 - 52 - c2
            c4 = pow2[ 51 ]
            bias = c2 - 1
            c5 = bias + 1
            c6 = pow2[ 53 ]

            metatable.ReadDouble = =>
                @Flush!

                :pointer = @
                endPos = pointer + 64
                if endPos > @size
                    return nil, "eof"

                :bits = @

                fraction = implode( bits, 52, pointer )
                exponent = implode( bits, 11, pointer + 52 )
                sign = bits[ endPos ] and -1 or 1

                if exponent == c0
                    if fraction == 0 or sign == -1
                        return sign * inf

                    return nan

                if exponent ~= 0
                    fraction += c1
                else
                    exponent = 1

                return sign * ldexp( fraction, exponent + c3 )

            metatable.WriteDouble = ( double ) =>
                argument( double, 2, "number" )

                local sign
                if isnegative( double )
                    sign = true
                    double = -double
                else
                    sign = false

                local exponent, fraction

                if double == inf
                    exponent = c5
                    fraction = 0

                elseif double ~= double
                    exponent = c5
                    fraction = c4

                elseif double == 0
                    exponent = -bias
                    fraction = 0

                else
                    fraction, exponent = frexp( double )

                    ebs = exponent + bias
                    if ebs <= 1
                        fraction *= pow2[ 51 + ebs ]
                        exponent = -bias

                    else
                        fraction -= 0.5
                        exponent -= 1

                        fraction *= c6

                bits = explode( fraction )
                exponentBits = explode( exponent + bias )

                for index = 1, 11
                    bits[ 52 + index ] = exponentBits[ index ]

                bits[ 64 ] = sign

                :buffer, :buffer_size = @

                for index = 1, 64
                    buffer_size += 1
                    buffer[ buffer_size ] = bits[ index ] == true

                @buffer_size = buffer_size
                return @

        util.BitStream = environment.extend( util.ByteStream, "BitStream", metatable )
