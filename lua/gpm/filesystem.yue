file = file
gpm = gpm

:util, :path, :string, :Logger, :Error, :ArgAssert, :Promise = gpm
:GetPathFromFilename, :GetExtensionFromFilename = string
:async, :await = Promise
SERVER = SERVER
CLIENT = CLIENT
select = select
error = error
:Find = file
:Join = path

-- https://github.com/Pika-Software/gm_efsw
if SERVER and not efsw and util.IsBinaryModuleInstalled( "efsw" ) and pcall( require, "efsw" )
    Logger\Info( "gm_efsw is initialized, package auto-reloading are available." )

lib = gpm.Table( gpm, "file", gpm.metaworks.CreateLink, file, true )

-- file.Move( filePath, newFilePath ) - moves file to new path
lib.Move = file.Rename

-- file.Time( filePath, gamePath ) - returns file creation time as number
lib.Time = file.Time

-- file.Find( filePath, gamePath, sorting ) - returns list of found files and folders
lib.Find = Find

-- file.LuaPath - "LUA" or "lsv"
luaPath = SERVER and "lsv" or "LUA"
lib.LuaPath = luaPath

isMounted = nil
do

    -- file.MountedFiles - table of mounted files
    mountedFiles = gpm.Table lib, "MountedFiles", ->
        :StartsWith = string
        :insert = gpm.table
        rawset = rawset

        return setmetatable( {}, {
            "__index": ( tbl, key ) ->
                for value in *tbl
                    if StartsWith( value, key )
                        return true

                return false

            "__newindex": ( tbl, key ) ->
                rawset( tbl, key, true )
                insert( tbl, 1, key )
        } )

    -- file.IsMounted( filePath, gamePath, onlyDir ) - returns true if file was mounted
    isMounted = ( filePath, gamePath, onlyDir ) ->
        if onlyDir and GetExtensionFromFilename( filePath )
            return

        if gamePath == "LUA" or gamePath == "lsv" or gamePath == "lcl"
            filePath = "lua/" .. filePath

        return mountedFiles[ filePath ]

    lib.IsMounted = isMounted

    -- file.MountGMA( filePath ) - mounts gma file to game filesystem and returns state and list of files
    do

        ok, length = false, 0
        :MountGMA = game

        lib.MountGMA = ( filePath ) ->
            ok, files = MountGMA( filePath )
            if ok
                length = #files
                for index = 1, length
                    mountedFiles[ files[ index ] ] = true

                Logger\Debug( "GMA file '%s' was mounted to GAME with %d files.", filePath, length )
                return ok, files

            return false

isDir, isFile, createDir = nil, nil, nil
do

    :Delete, :Exists, :IsDir = file
    :Split = string

    -- file.Exists( filePath, gamePath ) - check if the path exists
    lib.Exists = ( filePath, gamePath ) ->
        return isMounted( filePath, gamePath ) or Exists( filePath, gamePath )

    -- file.IsDir( filePath, gamePath ) - check if the path is a directory
    do

        :HasValue = gpm.table

        isDir = ( filePath, gamePath ) ->
            if isMounted( filePath, gamePath, true ) or IsDir( filePath, gamePath )
                return true

            folders = select( 2, Find( filePath .. "*", gamePath ) )
            if folders == nil or #folders == 0
                return false

            splits = Split( filePath, "/" )
            return HasValue( folders, splits[ #splits ], true )

        lib.IsDir = isDir

    -- file.IsFile( filePath, gamePath ) - check if the path is a file
    isFile = ( filePath, gamePath ) ->
        return isMounted( filePath, gamePath ) or ( Exists( filePath, gamePath ) and not isDir( filePath, gamePath ) )

    lib.IsFile = isFile

    -- file.Delete( filePath, gamePath ) - delete the file or folder
    do

        delete = ( filePath, gamePath ) ->
            gamePath = gamePath or "DATA"

            if isDir( filePath, gamePath )
                files, folders = Find( Join( filePath, "*" ), gamePath )
                for folderName in *folders
                    delete( Join( filePath, folderName ), gamePath )

                for fileName in *files
                    Delete( Join( filePath, fileName ), gamePath )

                return Delete( filePath, gamePath )

            return Delete( filePath, gamePath )

        lib.Delete = delete

    -- file.CreateDir( folderPath, force ) - create the folders by the path
    do

        :CreateDir = file

        createDir = ( folderPath, force ) ->
            if force
                currentPath = nil
                for folderName in *Split( folderPath, "/" )
                    if folderName
                        if currentPath
                            currentPath ..= "/" .. folderName
                        else
                            currentPath = folderName

                        if IsDir( currentPath, "DATA" )
                            continue

                        Delete( currentPath, "DATA" )
                        CreateDir( currentPath )

                return currentPath

            CreateDir( folderPath )
            return folderPath

        lib.CreateDir = createDir

    -- file.Size( filePath, gamePath ) - return the size of the file or folder in bytes as a number
    do

        :Size = file
        result = 0

        size = ( filePath, gamePath ) ->
            unless isDir( filePath, gamePath )
                return Size( filePath, gamePath )

            result = 0

            files, folders = Find( Join( filePath, "*" ), gamePath )
            for fileName in *files
                result += Size( Join( filePath, fileName ), gamePath )

            for folderName in *folders
                result += size( Join( filePath, folderName ), gamePath )

            return result

        lib.Size = size

-- file.BuildFilePath( filePath, force ) - build the file path
buildFilePath = ( filePath, force ) ->
    folderPath = GetPathFromFilename( filePath )
    if folderPath
        createDir( folderPath, force )

    return folderPath

lib.BuildFilePath = buildFilePath

-- file.IsCompilable( filePath, doPreCache ) - check if the file can be compiled
isCompilable = nil
do

    :moonloader = gpm
    :sub = string

    preCacheFunc = moonloader and moonloader.PreCacheFile or nil
    supportedExtensions = { moon: true, yue: true, lua: true }
    preCacheableExtensions = { "moon", "yue" }

    isCompilable = ( filePath, doPreCache ) ->
        extension = GetExtensionFromFilename( filePath )
        if extension
            if supportedExtensions[ extension ]
                filePath = sub( filePath, 1, #filePath - ( #extension + 1 ) )
            else
                return false

        for index = 1, 2
            preCachePath = filePath .. "." .. preCacheableExtensions[ index ]
            if isFile( preCachePath, luaPath )
                if doPreCache and preCacheFunc
                    if preCacheFunc( preCachePath )
                        Logger\Debug( "Pre-compiling '%s' into Lua completed successfully.", preCachePath )
                    else
                        error( "Pre-compiling '" .. preCachePath .. "' file in Lua failed." )

                return true

        return isFile( filePath .. ".lua", luaPath )

    lib.IsCompilable = isCompilable

do

    File = FindMetaTable( "File" )
    :Close, :Read, :Write = File
    :Open = file

    do

        :ReadULong, :WriteULong, :ReadByte, :WriteByte, :EndOfFile, :Seek, :Skip, :Tell = File

        -- File::SkipEmpty() - skips empty bytes
        File.SkipEmpty = ( fileHandle ) ->
            while not EndOfFile( fileHandle )
                if ReadByte( fileHandle ) ~= 0
                    Skip( fileHandle, -1 )
                    break

        -- File::ReadString() - reads string to first empty byte
        File.ReadString = ( fileHandle ) ->
            startPos, len = Tell( fileHandle ), 0
            while not EndOfFile( fileHandle ) and ReadByte( fileHandle ) ~= 0
                len = len + 1

            Seek( fileHandle, startPos )
            data = Read( fileHandle, len )
            Skip( fileHandle, 1 )
            return data

        -- File::WriteString( str ) - writes string and empty byte
        File.WriteString = ( fileHandle, str ) ->
            Write( fileHandle, str )
            WriteByte( fileHandle, 0 )

        -- File::ReadUInt64() - reads 4 bytes as number and skips 4 bytes
        if File.ReadUInt64 == nil
            File.ReadUInt64 = ( fileHandle ) ->
                number = ReadULong( fileHandle )
                Skip( fileHandle, 4 )
                return number

        -- File::WriteUInt64( number ) - writes 4 bytes as number and 4 empty bytes
        if File.WriteUInt64 == nil
            File.WriteUInt64 = ( fileHandle, number ) ->
                WriteULong( fileHandle, number )
                WriteULong( fileHandle, 0 )

    -- file.Open( filePath, mode, gamePath ) - opens file and returns file handler
    lib.Open = Open

    -- file.Append( filePath, content, force ) - appends content to file
    lib.Append = ( filePath, content, force ) ->
        if force
            buildFilePath( filePath, true )

        fileHandle = Open( filePath, "ab", "DATA" )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

    -- file.Read( filePath, gamePath, length ) - returns file content as string
    lib.Read = ( filePath, gamePath, length ) ->
        fileHandle = Open( filePath, "rb", gamePath )
        if fileHandle
            return Read( fileHandle, length ), Close( fileHandle )

    -- file.Write( filePath, content, force ) - writes content to file
    lib.Write = ( filePath, content, force ) ->
        if force
            buildFilePath( filePath, true )

        fileHandle = Open( filePath, "wb", "DATA" )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

if SERVER

    :ReplaceExtension, :RemoveBackslash = path
    AddCSLuaFile = AddCSLuaFile
    :getfpath = debug

    -- file.AddCSLuaFile( filePath )
    lib.AddCSLuaFile = ( fileName ) ->
        currentPath = getfpath!
        if not fileName and currentPath and isFile( currentPath, luaPath )
            AddCSLuaFile( currentPath )
            return

        ArgAssert( fileName, 1, "string" )
        fileName = ReplaceExtension( fileName, "lua" )

        if currentPath
            currentFolder = GetPathFromFilename( currentPath )
            if currentFolder
                filePath = currentFolder .. fileName
                if isCompilable( filePath, true )
                    AddCSLuaFile( filePath )
                    return

        if isCompilable( fileName, true )
            AddCSLuaFile( fileName )
            return

        error( "Couldn't AddCSLuaFile file '" .. fileName .. "' - File not found" )

    -- file.AddCSLuaFolder( folderPath )
    addCSLuaFolder = ( folderPath ) ->
        folderPath = RemoveBackslash( folderPath )
        files, folders = Find( folderPath .. "/*", "lsv" )

        for folderName in *folders
            addCSLuaFolder( folderPath .. "/" .. folderName )

        for fileName in *files
            filePath = folderPath .. "/" .. fileName
            if isCompilable( filePath, true )
                AddCSLuaFile( ReplaceExtension( filePath, "lua" ) )

    lib.AddCSLuaFolder = addCSLuaFolder

if istable( efsw )

    :Watch, :Unwatch = efsw

    -- file.WatchList
    watchList = gpm.Table( lib, "WatchList" )

    -- file.Watch( filePath, gamePath )
    watch = ( filePath, gamePath ) ->
        if watchList[ filePath .. ";" .. gamePath ] or ( CLIENT and isMounted( filePath, gamePath ) )
            return false

        if isDir( filePath, gamePath )
            filePath ..= "/"

            for folderName in *select( 2, Find( filePath .. "*", gamePath ) )
                watch( filePath .. folderName, gamePath )

        watchList[ filePath .. ";" .. gamePath ] = Watch( filePath, gamePath )
        return true

    lib.Watch = watch

    -- file.UnWatch( filePath, gamePath ) - stops file watching
    unWatch = ( filePath, gamePath ) ->
        watchID = watchList[ filePath .. ";" .. gamePath ]
        if watchID
            if isDir( filePath, gamePath )
                filePath ..= "/"

                for folderName in *select( 2, Find( filePath .. "*", gamePath ) )
                    unWatch( filePath .. folderName, gamePath )

            watchList[ filePath .. ";" .. gamePath ] = nil
            Unwatch( watchID )
            return true

        return false

    lib.UnWatch = unWatch

else

    lib.Watch = ->
        return false

    lib.Unwatch = ->
        return false

asyncRead = nil
do

    asyncFunctions = { "Append": false, "Write": false, "Read": false }

    do

        sources = {
            {
                "Name": "gm_asyncio"
                "Available": util.IsBinaryModuleInstalled( "asyncio" )
                "Get": ->
                    require( "asyncio" )
                    return {
                        "Append": asyncio.AsyncAppend
                        "Read": asyncio.AsyncRead
                        "Write": asyncio.AsyncWrite
                    }
            },
            {
                "Name": "async_write"
                "Available": util.IsBinaryModuleInstalled( "async_write" )
                "Get": ->
                    require( "async_write" )
                    return {
                        "Append": file.AsyncAppen
                        "Write": file.AsyncWrite
                    }
            },
            {
                "Name": "Garry's Mod Async"
                "Available": not MENU_DLL
                "Get": ->
                    return {
                        "Read": file.AsyncRead
                    }
            },
            {
                "Name": "Garry's Mod"
                "Available": true
                "Get": ->
                    :Append, :Read, :Write = lib

                    return {
                        "Append": ( fileName, content, func ) ->
                            state = Append( fileName, content, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state

                        "Read": ( fileName, gamePath, func ) ->
                            content = Read( fileName, gamePath )
                            state = content == nil and -1 or 0
                            func( fileName, gamePath, state, content )
                            return state

                        "Write": ( fileName, content, func ) ->
                            state = Write( fileName, content, "wb", true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                    }
            }
        }

        count = 0
        for source in *sources
            if source.Available
                functions = source.Get!
                installed = 0

                for funcName, func in pairs( asyncFunctions )
                    if func == false
                        func = functions[ funcName ]
                        if func
                            asyncFunctions[ funcName ] = func
                            installed += 1
                            count += 1

                if installed > 0
                    Logger\Info "'%s' was connected as filesystem API.", source.Name

                if count > 2
                    break

    -- file.FileSystemAsyncError - async error
    class FileSystemAsyncError extends Error
    lib.FileSystemAsyncError = FileSystemAsyncError

    -- file.FSASYNC - async error messages table
    FSASYNC = {
        [ -8 ]: "Filename not part of the specified file system, try a different one."
        [ -7 ]: "Failure for a reason that might be temporary, you might retry, but not immediately."
        [ -6 ]: "Read parameters invalid for unbuffered IO."
        [ -5 ]: "Hard subsystem failure."
        [ -4 ]: "Read error on file."
        [ -3 ]: "Out of memory for file read."
        [ -2 ]: "Caller's provided id is not recognized."
        [ -1 ]: "Filename could not be opened (bad path, not exist, etc)."
        [  0 ]: "Operation is successful."
        [  1 ]: "File is properly queued, waiting for service."
        [  2 ]: "File is being accessed."
        [  3 ]: "File was aborted by caller."
        [  4 ]: "File is not yet queued."
    }

    lib.FSASYNC = FSASYNC

    -- file.AsyncAppend( filePath, content, force ) - async append function that returns promise
    do

        :Append = asyncFunctions

        lib.AsyncAppend = ( filePath, content, force ) ->
            if force
                buildFilePath( filePath, true )

            p = Promise!

            state = Append filePath, content, ( fileName, gamePath, code ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath } )

                p\Reject( FileSystemAsyncError FSASYNC[ code ] )

            if state ~= 0
                p\Reject( FileSystemAsyncError FSASYNC[ state ] )

            return p

    -- file.AsyncRead( filePath, gameDir ) - async read function that returns promise
    do

        :Read = asyncFunctions

        asyncRead = ( filePath, gameDir ) ->
            p = Promise!

            state = Read filePath, gameDir, ( fileName, gamePath, code, content ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath, :content } )

                p\Reject( FileSystemAsyncError FSASYNC[ code ] )

            if state ~= 0
                p\Reject( FileSystemAsyncError FSASYNC[ state ] )

            return p

        lib.AsyncRead = asyncRead

    -- file.AsyncWrite( filePath, content, force ) - async write function that returns promise
    do

        :Write = asyncFunctions

        lib.AsyncWrite = ( filePath, content, force ) ->
            if force
                buildFilePath( filePath, true )

            p = Promise!

            state = Write filePath, content, ( fileName, gamePath, code ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath } )

                p\Reject( FileSystemAsyncError FSASYNC[ code ] )

            if state ~= 0
                p\Reject( FileSystemAsyncError FSASYNC[ state ] )

            return p

do

    -- file.FileSystemCompileError - compile error
    class FileSystemCompileError extends Error
    lib.FileSystemCompileError = FileSystemCompileError

    -- file.CompileLua( filePath, gamePath, handleError ) - async lua file compile function that returns promise
    compileLua = nil
    do

        CompileString, CompileFile = CompileString, CompileFile

        compileLua = async ( filePath, gamePath, handleError ) ->
            if CLIENT and isMounted( filePath, gamePath )
                filePath = "lua/" .. filePath
                gamePath = "GAME"

            :content = await asyncRead( filePath, gamePath )
            unless content
                error FileSystemCompileError "File '" .. filePath .. "' cannot be read."

            func = CompileString( content, filePath, handleError )
            if not func and ( gamePath == "LUA" or gamePath == "lsv" or gamePath == "lcl" )
                func = CompileFile( filePath )

            if func
                return func

            error FileSystemCompileError "File '" .. filePath .. "' is missing in file system."

        lib.CompileLua = compileLua

    -- file.CompileMoon( filePath, gamePath, handleError ) - async moon file compile function that returns promise
    compileMoon = nil
    do

        :CompileMoonString = util

        compileMoon = async ( filePath, gamePath, handleError ) ->
            :content = await asyncRead( filePath, gamePath )
            unless content
                error FileSystemCompileError "File '" .. filePath .. "' cannot be read."

            return CompileMoonString( content, filePath, handleError )

        lib.CompileMoon = compileMoon

    -- file.CompileYue( filePath, gamePath, handleError, yueConfig ) - async yue file compile function that returns promise
    compileYue = nil
    do

        :CompileYueString = util

        compileYue = async ( filePath, gamePath, handleError, yueConfig ) ->
            :content = await asyncRead( filePath, gamePath )
            unless content
                error FileSystemCompileError "File '" .. filePath .. "' cannot be read."

            return CompileYueString( content, filePath, handleError, yueConfig )

        lib.CompileYue = compileYue

    -- file.Compile( filePath, gamePath, handleError, yueConfig ) - async file compile function that returns promise
    do

        :StripExtension = string

        lib.Compile = ( filePath, gamePath, handleError, yueConfig ) ->
            fileName = StripExtension( filePath )

            compilePath = fileName .. ".lua"
            if isFile( compilePath, gamePath )
                return compileLua( compilePath, gamePath, handleError )

            compilePath = fileName .. ".moon"
            if isFile( compilePath, gamePath )
                return compileMoon( compilePath, gamePath, handleError )

            compilePath = fileName .. ".yue"
            if isFile( compilePath, gamePath )
                return compileYue( compilePath, gamePath, handleError, yueConfig )

            error FileSystemCompileError "File '" .. filePath .. "' cannot be found."

-- file.DecompressDeflate( fileHandle, doCRC ) - zip files iterator
do

    :DecompressDeflate = gpm.deflate
    tostring = tostring
    :fempty = debug
    :CRC = util

    lib.IterateZipFiles = ( fileHandle, doCRC ) ->
        unless fileHandle
            return fempty

        return ->
            if fileHandle\Read( 4 ) ~= "PK\x03\x04"
                return
            fileHandle\Skip( 4 )

            compressionMethod = fileHandle\ReadUShort!
            fileHandle\Skip( 4 )

            crc = fileHandle\ReadULong!
            compressedSize = fileHandle\ReadULong!
            fileHandle\Skip( 4 )

            fileNameLen = fileHandle\ReadUShort!
            extraLen = fileHandle\ReadUShort!
            fileName = fileHandle\Read( fileNameLen )
            fileHandle\Skip( extraLen )

            data = nil
            switch compressionMethod
                -- Without compression
                when 0
                    data = fileHandle\Read( compressedSize )

                -- Deflate compression
                when 8
                    compressedData = fileHandle\Read( compressedSize )
                    data = DecompressDeflate( compressedData )

            if data ~= nil and doCRC ~= false and tostring( crc ) ~= CRC( data )
                data = nil

            return fileName, data

return lib
