gpm = gpm
:util, :path, :string, :metaworks, :Logger, :Error, :ArgAssert = gpm
string_GetPathFromFilename = string.GetPathFromFilename
istable = istable
SERVER = SERVER
CLIENT = CLIENT
error = error
file = file

-- https://github.com/Pika-Software/gm_efsw
if SERVER and not efsw and util.IsBinaryModuleInstalled( "efsw" ) and pcall( require, "efsw" )
    Logger\Info( "gm_efsw is initialized, package auto-reloading are available." )

lib = gpm.Table( gpm, "fs", metaworks.CreateLink, file, true )

luaGameDir = SERVER and "lsv" or "LUA"
lib.LuaGameDir = luaGameDir

lib.Move = file.Rename
lib.Time = file.Time

string_GetExtensionFromFilename = string.GetExtensionFromFilename
lib_IsMounted = nil
do

    mountedFiles = gpm.Table( lib, "MountedFiles", ->
        string_StartsWith = string.StartsWith
        rawget, rawset = rawget, rawset
        table_insert = table.insert
        return setmetatable( {}, {
            __index: ( tbl, key ) ->
                for value in *tbl
                    if string_StartsWith( value, key )
                        return true
                return false
            __newindex: ( tbl, key ) ->
                unless rawget( tbl, key )
                    table_insert( tbl, 1, key )
                    rawset( tbl, key, true )
        } )
    )

    lib_IsMounted = ( filePath, gamePath, onlyDir ) ->
        if onlyDir and string_GetExtensionFromFilename( filePath )
            return

        if gamePath == "LUA" or gamePath == "lsv" or gamePath == "lcl"
            filePath = "lua/" .. filePath

        return mountedFiles[ filePath ]
    lib.IsMounted = lib_IsMounted

    game_MountGMA = game.MountGMA
    lib.MountGMA = ( gmaPath ) ->
        ok, files = game_MountGMA( gmaPath )
        unless ok
            return false

        for filePath in *files
            mountedFiles[ filePath ] = true

        Logger\Debug( "GMA file '%s' was mounted to GAME with %d files.", gmaPath, #files )
        return ok, files

lib_CreateDir, lib_IsFile, lib_IsDir = nil, nil, nil
path_Join = path.Join
lib_Find = file.Find
lib.Find = lib_Find

do
    table_HasIValue = table.HasIValue
    string_Split = string.Split
    file_Exists = file.Exists
    file_Delete = file.Delete
    file_IsDir = file.IsDir

    lib.Exists = ( filePath, gamePath ) ->
        return lib_IsMounted( filePath, gamePath ) or file_Exists( filePath, gamePath )

    lib_IsDir = ( filePath, gamePath ) ->
        if lib_IsMounted( filePath, gamePath, true ) or file_IsDir( filePath, gamePath )
            return true

        _, folders = lib_Find( filePath .. "*", gamePath )
        if folders == nil or #folders == 0
            return false

        splits = string_Split( filePath, "/" )
        return table_HasIValue( folders, splits[ #splits ] )
    lib.IsDir = lib_IsDir

    lib_IsFile = ( filePath, gamePath ) ->
        return lib_IsMounted( filePath, gamePath ) or ( file_Exists( filePath, gamePath ) and not lib_IsDir( filePath, gamePath ) )
    lib.IsFile = lib_IsFile

    lib_Delete = ( filePath, gamePath, force ) ->
            gamePath = gamePath or "DATA"

            if lib_IsDir( filePath, gamePath )
                if force
                    files, folders = lib_Find( path_Join( filePath, "*" ), gamePath )
                    for folderName in *folders
                        lib_Delete( path_Join( filePath, folderName ), gamePath, force )

                    for fileName in *files
                        file_Delete( path_Join( filePath, fileName ), gamePath, force )

                file_Delete( filePath, gamePath )
                return not lib_IsDir( filePath, gamePath )

            file_Delete( filePath, gamePath )
            return not lib_IsFile( filePath, gamePath )
    lib.Delete = lib_Delete

    do
        file_CreateDir = file.CreateDir
        lib_CreateDir = ( folderPath, force ) ->
            unless force
                file_CreateDir( folderPath )
                return folderPath

            currentPath = nil
            for folderName in *string_Split( folderPath, "/" )
                if folderName
                    unless currentPath
                        currentPath = folderName
                    else
                        currentPath ..= "/" .. folderName

                    unless file_IsDir( currentPath, "DATA" )
                        file_Delete( currentPath, "DATA" )
                        file_CreateDir( currentPath )
            return currentPath
        lib.CreateDir = lib_CreateDir

    do
        file_Size = file.Size
        lib_Size = ( filePath, gamePath ) ->
            if not lib_IsDir( filePath, gamePath )
                return file_Size( filePath, gamePath )

            size, files, folders = 0, lib_Find( path_Join( filePath, "*" ), gamePath )
            for fileName in *files
                size += file_Size( path_Join( filePath, fileName ), gamePath )

            for folderName in *folders
                size += lib_Size( path_Join( filePath, folderName ), gamePath )

            return size
        lib.Size = lib_Size

lib_BuildFilePath = ( filePath ) ->
    folderPath = string_GetPathFromFilename( filePath )
    if folderPath
        lib_CreateDir( folderPath )
    return folderPath
lib.BuildFilePath = lib_BuildFilePath

lib_IsCompilable = nil
do

    moonloader = gpm.moonloader
    moonloader_PreCacheFile = moonloader and moonloader.PreCacheFile or nil
    string_sub = string.sub

    compilableExtensions = { "moon", "yue" }
    codeExtensions = {
        moon: true
        yue: true
        lua: true
    }

    lib_IsCompilable = ( filePath, preCompile ) ->
        extension = string_GetExtensionFromFilename( filePath )
        if extension ~= nil
            unless codeExtensions[ extension ]
                return false
            filePath = string_sub( filePath, 1, #filePath - ( #extension + 1 ) )

        if preCompile and moonloader_PreCacheFile ~= nil
            for extension in *compilableExtensions
                alternativeFilePath = filePath .. extension
                if lib_IsFile( alternativeFilePath, luaGameDir )
                    unless moonloader_PreCacheFile( alternativeFilePath )
                        error( "Pre-compiling '#{alternativeFilePath}' file in Lua failed." )
                    Logger\Debug( "Pre-compiling '%s' into Lua completed successfully.", alternativeFilePath )
                return true
        return lib_IsFile( filePath .. ".lua", luaGameDir )
    lib.IsCompilable = lib_IsCompilable

lib_Read, lib_Write = nil, nil
do

    File = FindMetaTable( "File" )
    File_Close = File.Close
    File_Write = File.Write
    File_Read = File.Read

    do

        File_WriteULong = File.WriteULong
        File_ReadULong = File.ReadULong
        File_WriteByte = File.WriteByte
        File_EndOfFile = File.EndOfFile
        File_ReadByte = File.ReadByte
        File_Seek = File.Seek
        File_Skip = File.Skip
        File_Tell = File.Tell

        File.SkipEmpty = ( fileHandle ) ->
            while not File_EndOfFile( fileHandle )
                if File_ReadByte( fileHandle ) ~= 0
                    File_Skip( fileHandle, -1 )
                    break

        File.ReadString = ( fileHandle ) ->
            startPos, len = File_Tell( fileHandle ), 0
            while not File_EndOfFile( fileHandle ) and File_ReadByte( fileHandle ) ~= 0
                len = len + 1

            File_Seek( fileHandle, startPos )
            data = File_Read( fileHandle, len )
            File_Skip( fileHandle, 1 )
            return data

        File.WriteString = ( fileHandle, str ) ->
            File_Write( fileHandle, str )
            File_WriteByte( fileHandle, 0 )

        unless File.ReadUInt64
            File.ReadUInt64 = ( fileHandle ) ->
                number = File_ReadULong( fileHandle )
                File_Skip( fileHandle, 4 )
                return number

        unless File.WriteUInt64
            File.WriteUInt64 = ( fileHandle, number ) ->
                File_WriteULong( fileHandle, number )
                File_WriteULong( fileHandle, 0 )

    lib_Open = file.Open
    lib.Open = lib_Open

    lib_Read = ( filePath, gamePath, length ) ->
        fileHandle = lib_Open( filePath, "rb", gamePath )
        unless fileHandle
            return false

        content = File_Read( fileHandle, length )
        File_Close( fileHandle )
        return true, content
    lib.Read = lib_Read

    lib_Write = ( filePath, content, fileMode, fastMode ) ->
        unless fastMode
            lib_BuildFilePath( filePath )

        fileHandle = lib_Open( filePath, fileMode or "wb", "DATA" )
        unless fileHandle
            return false

        File_Write( fileHandle, content )
        File_Close( fileHandle )
        return true
    lib.Write = lib_Write

lib_Append = ( filePath, content, fastMode ) ->
    return lib_Write( filePath, content, "ab", fastMode )
lib.Append = lib_Append

path_Fix = path.Fix

if SERVER
    path_ReplaceExtension = path.ReplaceExtension
    path_RemoveBackslash = path.RemoveBackslash
    debug_getfpath = debug.getfpath
    AddCSLuaFile = AddCSLuaFile

    lib.AddCSLuaFile = ( fileName ) ->
        currentPath = debug_getfpath!
        if not fileName and currentPath and lib_IsFile( currentPath, luaGameDir )
            AddCSLuaFile( currentPath )
            return

        ArgAssert( fileName, 1, "string" )
        fileName = path_ReplaceExtension( path_Fix( fileName ), "lua" )

        if currentPath
            currentFolder = string_GetPathFromFilename( currentPath )
            if currentFolder
                filePath = currentFolder .. fileName
                if lib_IsCompilable( filePath, true )
                    AddCSLuaFile( filePath )
                    return

        if lib_IsCompilable( fileName, true )
            AddCSLuaFile( fileName )
            return

        error( "Couldn't AddCSLuaFile file '" .. fileName .. "' - File not found" )

    lib_AddCSLuaFolder = ( folderPath ) ->
        folderPath = path_RemoveBackslash( path_Fix( folderPath ) )
        files, folders = lib_Find( folderPath .. "/*", "lsv" )

        for folderName in *folders
            lib_AddCSLuaFolder( folderPath .. "/" .. folderName )

        for fileName in *files
            filePath = folderPath .. "/" .. fileName
            if lib_IsCompilable( filePath, true )
                AddCSLuaFile( path_ReplaceExtension( filePath, "lua" ) )
    lib.AddCSLuaFolder = lib_AddCSLuaFolder

if istable( efsw )
    watchList = gpm.Table( lib, "WatchList" )

    do
        efsw_Watch = efsw.Watch
        lib_Watch = ( filePath, gamePath, recursively ) ->
            filePath = path_Fix( filePath )

            if watchList[ filePath .. ";" .. gamePath ] or ( CLIENT and lib_IsMounted( filePath, gamePath ) )
                return false

            if lib_IsDir( filePath, gamePath )
                filePath = filePath .. "/"
                if recursively
                    _, folders = lib_Find( filePath .. "*", gamePath )
                    for folderName in *folders
                        lib_Watch( filePath .. folderName, gamePath, recursively )

            watchList[ filePath .. ";" .. gamePath ] = efsw_Watch( filePath, gamePath )
            return true
        lib.Watch = lib_Watch

    do
        efsw_Unwatch = efsw.Unwatch
        lib_UnWatch = ( filePath, gamePath, recursively ) ->
            filePath = path_Fix( filePath )

            watchID = watchList[ filePath .. ";" .. gamePath ]
            if not watchID
                return false

            if lib_IsDir( filePath, gamePath )
                filePath = filePath .. "/"
                if recursively
                    _, folders = lib_Find( filePath .. "*", gamePath )
                    for folderName in *folders
                        lib_UnWatch( filePath .. folderName, gamePath, recursively )

            efsw_Unwatch( watchID )
            watchList[ filePath .. ";" .. gamePath ] = nil
            return true
        lib.UnWatch = lib_UnWatch

Promise = gpm.Promise
:async, :await = Promise

lib_AsyncRead = nil
do

    asyncFunctions = {
        Append: false,
        Write: false,
        Read: false
    }

    do

        sources = {
            {
                Name: "gm_asyncio"
                Available: util.IsBinaryModuleInstalled( "asyncio" )
                Get: ->
                    require( "asyncio" )
                    return {
                        Append: asyncio.AsyncAppend
                        Write: asyncio.AsyncWrite
                        Read: asyncio.AsyncRead
                    }
            },
            {
                Name: "async_write"
                Available: util.IsBinaryModuleInstalled( "async_write" )
                Get: ->
                    require( "async_write" )
                    return {
                        Append: file.AsyncAppen
                        Write: file.AsyncWrite
                    }
            },
            {
                Name: "Legacy Async"
                Available: not MENU_DLL
                Get: ->
                    return {
                        Read: file.AsyncRead
                    }
            },
            {
                Name: "Legacy"
                Available: true
                Get: ->
                    return {
                        Append: ( fileName, content, func ) ->
                            state = lib_Append( fileName, content, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                        Write: ( fileName, content, func ) ->
                            state = lib_Write( fileName, content, "wb", true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                        Read: ( fileName, gamePath, func ) ->
                            ok, content = lib_Read( fileName, gamePath )
                            state = ok and 0 or -1
                            func( fileName, gamePath, state, content )
                            return state
                    }
            }
        }

        count = 0
        for source in *sources
            unless source.Available
                continue

            functions = source.Get!
            installed = 0
            for funcName, func in pairs( asyncFunctions )
                unless func
                    func = functions[ funcName ]
                    if func
                        asyncFunctions[ funcName ] = func
                        installed += 1
                        count += 1

            if installed > 0
                Logger\Info "'%s' was connected as filesystem API.", source.Name

            if count > 2
                break

    class FileSystemAsyncError extends Error

    FSASYNC = {
        [ -8 ]: "Filename not part of the specified file system, try a different one."
        [ -7 ]: "Failure for a reason that might be temporary, you might retry, but not immediately."
        [ -6 ]: "Read parameters invalid for unbuffered IO."
        [ -5 ]: "Hard subsystem failure."
        [ -4 ]: "Read error on file."
        [ -3 ]: "Out of memory for file read."
        [ -2 ]: "Caller's provided id is not recognized."
        [ -1 ]: "Filename could not be opened (bad path, not exist, etc)."
        [  0 ]: "Operation is successful."
        [  1 ]: "File is properly queued, waiting for service."
        [  2 ]: "File is being accessed."
        [  3 ]: "File was aborted by caller."
        [  4 ]: "File is not yet queued."
    }

    lib.FileSystemAsyncError = FileSystemAsyncError
    lib.FSASYNC = FSASYNC

    do

        async_Read = asyncFunctions.Read

        lib_AsyncRead = ( filePath, gameDir ) ->
            p = Promise!

            code = async_Read( filePath, gameDir, ( fileName, gamePath, code, content ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath, :content } )
                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )
            )

            if code ~= 0
                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )

            return p
        lib.AsyncRead = lib_AsyncRead

    do

        async_Write = asyncFunctions.Write

        lib.AsyncWrite = ( filePath, content, fastMode ) ->
            unless fastMode
                lib_BuildFilePath( filePath )

            p = Promise!

            code = async_Write( filePath, content, ( fileName, gamePath, code ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath } )
                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )
            )

            if code ~= 0
                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )

            return p

    do

        async_Append = asyncFunctions.Append

        lib.AsyncAppend = ( filePath, content, fastMode ) ->
            unless fastMode
                lib_BuildFilePath( filePath )

            p = Promise!

            code = async_Append( filePath, content, ( fileName, gamePath, code ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath } )
                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )
            )

            if code ~= 0
                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )

            return p

do

    class FileSystemCompileError extends Error
    lib.FileSystemCompileError = FileSystemCompileError

    do

        CompileString = CompileString
        CompileFile = CompileFile

        lib.CompileLua = async ( filePath, gamePath, handleError ) ->
            if CLIENT and lib_IsMounted( filePath, gamePath )
                filePath = "lua/" .. filePath
                gamePath = "GAME"

            :content = await lib_AsyncRead( filePath, gamePath )
            unless content
                error FileSystemCompileError "File #{filePath} cannot be read."

            func = CompileString( content, filePath, handleError )
            if not func and ( gamePath == "LUA" or gamePath == "lsv" or gamePath == "lcl" )
                func = CompileFile( filePath )

            if func
                return func
            error FileSystemCompileError "File '#{filePath}' is missing in file system."

    do

        util_CompileMoonString = util.CompileMoonString

        lib.CompileMoon = async ( filePath, gamePath, handleError ) ->
            :content = await lib_AsyncRead( filePath, gamePath )
            unless content
                error FileSystemCompileError "File #{filePath} cannot be read."
            return util_CompileMoonString( content, filePath, handleError )

    do

        util_CompileYueString = util.CompileYueString

        lib.CompileYue = async ( filePath, gamePath, handleError, yueConfig ) ->
            :content = await lib_AsyncRead( filePath, gamePath )
            unless content
                error FileSystemCompileError "File #{filePath} cannot be read."
            return util_CompileYueString( content, filePath, handleError, yueConfig )

do

    deflate_DecompressDeflate = gpm.deflate.DecompressDeflate
    debug_fempty = debug.fempty
    tostring = tostring
    util_CRC = util.CRC

    lib.IterateZipFiles = ( fileHandle ) ->
        unless fileHandle
            return debug_fempty

        return ->
            if fileHandle\Read( 4 ) ~= "PK\x03\x04"
                return
            fileHandle\Skip( 4 )

            compressionMethod = fileHandle\ReadUShort!
            fileHandle\Skip( 4 )

            crc = fileHandle\ReadULong()
            compressedSize = fileHandle\ReadULong!
            fileHandle\Skip( 4 )

            fileNameLen = fileHandle\ReadUShort!
            extraLen = fileHandle\ReadUShort!
            fileName = fileHandle\Read( fileNameLen )
            fileHandle\Skip( extraLen )

            data = nil
            if compressionMethod == 0
                -- No compression
                data = fileHandle\Read( compressedSize )
            elseif compressionMethod == 8
                -- Deflate compression
                compressedData = fileHandle\Read( compressedSize )
                data = deflate_DecompressDeflate( compressedData )

            if data and tostring( crc ) ~= util_CRC( data )
                data = nil

            return fileName, data

return lib