gpm = gpm

:util, :path, :string, :Logger, :Error, :ArgAssert, :Promise = gpm
:GetPathFromFilename = string
:async, :await = Promise
SERVER = SERVER
CLIENT = CLIENT
select = select
error = error
file = file

-- https://github.com/Pika-Software/gm_efsw
if SERVER and not efsw and util.IsBinaryModuleInstalled( "efsw" ) and pcall( require, "efsw" )
    Logger\Info( "gm_efsw is initialized, package auto-reloading are available." )

lib = gpm.Table( gpm, "file", gpm.metaworks.CreateLink, file, true )

RealmGameDir = SERVER and "lsv" or "LUA"
lib.RealmGameDir = RealmGameDir

lib.Move = file.Rename
lib.Time = file.Time

:GetExtensionFromFilename = string
lib_IsMounted = nil
do

    mountedFiles = gpm.Table lib, "MountedFiles", ->
        :StartsWith = string
        :insert = gpm.table
        rawset = rawset

        return setmetatable {}, {
            __index: ( tbl, key ) ->
                for value in *tbl
                    if StartsWith( value, key )
                        return true

                return false

            __newindex: ( tbl, key ) ->
                rawset( tbl, key, true )
                insert( tbl, 1, key )
        }

    lib_IsMounted = ( filePath, gamePath, onlyDir ) ->
        if onlyDir and GetExtensionFromFilename( filePath )
            return

        if gamePath == "LUA" or gamePath == "lsv" or gamePath == "lcl"
            filePath = "lua/" .. filePath

        return mountedFiles[ filePath ]

    lib.IsMounted = lib_IsMounted

    :MountGMA = game

    lib.MountGMA = ( gmaPath ) ->
        ok, files = MountGMA( gmaPath )
        unless ok
            return false

        for filePath in *files
            mountedFiles[ filePath ] = true

        Logger\Debug( "GMA file '%s' was mounted to GAME with %d files.", gmaPath, #files )
        return ok, files

:Join = path
:Find = file
lib.Find = Find

lib_CreateDir, lib_IsFile, lib_IsDir = nil, nil, nil
do

    :Exists, :IsDir, :Delete = file
    :Split = string

    lib.Exists = ( filePath, gamePath ) ->
        return lib_IsMounted( filePath, gamePath ) or Exists( filePath, gamePath )

    do

        :HasValue = gpm.table

        lib_IsDir = ( filePath, gamePath ) ->
            if lib_IsMounted( filePath, gamePath, true ) or IsDir( filePath, gamePath )
                return true

            _, folders = Find( filePath .. "*", gamePath )
            if folders == nil or #folders == 0
                return false

            splits = Split( filePath, "/" )
            return HasValue( folders, splits[ #splits ], true )

        lib.IsDir = lib_IsDir

    lib_IsFile = ( filePath, gamePath ) ->
        return lib_IsMounted( filePath, gamePath ) or ( Exists( filePath, gamePath ) and not lib_IsDir( filePath, gamePath ) )

    lib.IsFile = lib_IsFile

    lib_Delete = ( filePath, gamePath, force ) ->
            gamePath = gamePath or "DATA"

            if lib_IsDir( filePath, gamePath )
                if force
                    files, folders = Find( Join( filePath, "*" ), gamePath )
                    for folderName in *folders
                        lib_Delete( Join( filePath, folderName ), gamePath, force )

                    for fileName in *files
                        Delete( Join( filePath, fileName ), gamePath, force )

                Delete( filePath, gamePath )
                return not lib_IsDir( filePath, gamePath )

            Delete( filePath, gamePath )
            return not lib_IsFile( filePath, gamePath )

    lib.Delete = lib_Delete

    do

        :CreateDir = file

        lib_CreateDir = ( folderPath, force ) ->
            unless force
                CreateDir( folderPath )
                return folderPath

            currentPath = nil
            for folderName in *Split( folderPath, "/" )
                if folderName
                    unless currentPath
                        currentPath = folderName
                    else
                        currentPath ..= "/" .. folderName

                    unless IsDir( currentPath, "DATA" )
                        Delete( currentPath, "DATA" )
                        CreateDir( currentPath )

            return currentPath

        lib.CreateDir = lib_CreateDir

    do

        :Size = file
        result = 0

        lib_Size = ( filePath, gamePath ) ->
            unless lib_IsDir( filePath, gamePath )
                return Size( filePath, gamePath )

            result = 0

            files, folders = Find( Join( filePath, "*" ), gamePath )
            for fileName in *files
                result += Size( Join( filePath, fileName ), gamePath )

            for folderName in *folders
                result += lib_Size( Join( filePath, folderName ), gamePath )

            return result

        lib.Size = lib_Size

lib_BuildFilePath = ( filePath ) ->
    folderPath = GetPathFromFilename( filePath )
    if folderPath
        lib_CreateDir( folderPath )

    return folderPath

lib.BuildFilePath = lib_BuildFilePath

lib_IsCompilable = nil
do

    :moonloader = gpm
    :sub = string

    PreCacheFile = moonloader and moonloader.PreCacheFile or nil
    preCacheableExtensions = { "moon", "yue" }
    supportedExtensions = {
        moon: true
        yue: true
        lua: true
    }

    lib_IsCompilable = ( filePath, preCompile ) ->
        extension = GetExtensionFromFilename( filePath )
        if extension ~= nil
            unless supportedExtensions[ extension ]
                return false

            filePath = sub( filePath, 1, #filePath - ( #extension + 1 ) )

        if preCompile and PreCacheFile ~= nil
            for i = 1, 2
                preCachePath = filePath .. preCacheableExtensions[ i ]
                if lib_IsFile( preCachePath, RealmGameDir )
                    unless PreCacheFile( preCachePath )
                        error( "Pre-compiling '" .. preCachePath .. "' file in Lua failed." )

                    Logger\Debug( "Pre-compiling '%s' into Lua completed successfully.", preCachePath )

                return true

        return lib_IsFile( filePath .. ".lua", RealmGameDir )

    lib.IsCompilable = lib_IsCompilable

lib_Read, lib_Write = nil, nil
do

    File = FindMetaTable( "File" )
    :Read, :Close, :Write = File

    do

        :ReadULong, :WriteULong, :ReadByte, :WriteByte, :EndOfFile, :Seek, :Skip, :Tell = File

        File.SkipEmpty = ( fileHandle ) ->
            while not EndOfFile( fileHandle )
                if ReadByte( fileHandle ) ~= 0
                    Skip( fileHandle, -1 )
                    break

        File.ReadString = ( fileHandle ) ->
            startPos, len = Tell( fileHandle ), 0
            while not EndOfFile( fileHandle ) and ReadByte( fileHandle ) ~= 0
                len = len + 1

            Seek( fileHandle, startPos )
            data = Read( fileHandle, len )
            Skip( fileHandle, 1 )
            return data

        File.WriteString = ( fileHandle, str ) ->
            Write( fileHandle, str )
            WriteByte( fileHandle, 0 )

        if File.ReadUInt64 == nil
            File.ReadUInt64 = ( fileHandle ) ->
                number = ReadULong( fileHandle )
                Skip( fileHandle, 4 )
                return number

        if File.WriteUInt64 == nil
            File.WriteUInt64 = ( fileHandle, number ) ->
                WriteULong( fileHandle, number )
                WriteULong( fileHandle, 0 )

    :Open = file
    lib.Open = Open

    lib_Read = ( filePath, gamePath, length ) ->
        fileHandle = Open( filePath, "rb", gamePath )
        unless fileHandle
            return false

        content = Read( fileHandle, length )
        Close( fileHandle )
        return true, content

    lib.Read = lib_Read

    lib_Write = ( filePath, content, fileMode, fastMode ) ->
        unless fastMode
            lib_BuildFilePath( filePath )

        fileHandle = Open( filePath, fileMode or "wb", "DATA" )
        unless fileHandle
            return false

        Write( fileHandle, content )
        Close( fileHandle )
        return true

    lib.Write = lib_Write

lib_Append = ( filePath, content, fastMode ) ->
    return lib_Write( filePath, content, "ab", fastMode )

lib.Append = lib_Append

:Fix = path

if SERVER

    :ReplaceExtension = path
    AddCSLuaFile = AddCSLuaFile
    :getfpath = debug

    lib.AddCSLuaFile = ( fileName ) ->
        currentPath = getfpath!
        if not fileName and currentPath and lib_IsFile( currentPath, RealmGameDir )
            AddCSLuaFile( currentPath )
            return

        ArgAssert( fileName, 1, "string" )
        fileName = ReplaceExtension( Fix( fileName ), "lua" )

        if currentPath
            currentFolder = GetPathFromFilename( currentPath )
            if currentFolder
                filePath = currentFolder .. fileName
                if lib_IsCompilable( filePath, true )
                    AddCSLuaFile( filePath )
                    return

        if lib_IsCompilable( fileName, true )
            AddCSLuaFile( fileName )
            return

        error( "Couldn't AddCSLuaFile file '" .. fileName .. "' - File not found" )

    lib_AddCSLuaFolder = ( folderPath ) ->
        folderPath = Fix( folderPath )
        files, folders = Find( folderPath .. "/*", "lsv" )

        for folderName in *folders
            lib_AddCSLuaFolder( folderPath .. "/" .. folderName )

        for fileName in *files
            filePath = folderPath .. "/" .. fileName
            if lib_IsCompilable( filePath, true )
                AddCSLuaFile( ReplaceExtension( filePath, "lua" ) )

    lib.AddCSLuaFolder = lib_AddCSLuaFolder

if istable( efsw )
    watchList = gpm.Table( lib, "WatchList" )
    :Watch, :Unwatch = efsw

    lib_Watch = ( filePath, gamePath, recursively ) ->
        filePath = Fix( filePath )

        if watchList[ filePath .. ";" .. gamePath ] or ( CLIENT and lib_IsMounted( filePath, gamePath ) )
            return false

        if lib_IsDir( filePath, gamePath )
            filePath = filePath .. "/"
            if recursively
                for folderName in *select( 2, Find( filePath .. "*", gamePath ) )
                    lib_Watch( filePath .. folderName, gamePath, recursively )

        watchList[ filePath .. ";" .. gamePath ] = Watch( filePath, gamePath )
        return true

    lib.Watch = lib_Watch

    lib_UnWatch = ( filePath, gamePath, recursively ) ->
        filePath = Fix( filePath )

        watchID = watchList[ filePath .. ";" .. gamePath ]
        if not watchID
            return false

        if lib_IsDir( filePath, gamePath )
            filePath = filePath .. "/"
            if recursively
                for folderName in *select( 2, Find( filePath .. "*", gamePath ) )
                    lib_UnWatch( filePath .. folderName, gamePath, recursively )

        Unwatch( watchID )
        watchList[ filePath .. ";" .. gamePath ] = nil
        return true

    lib.UnWatch = lib_UnWatch

lib_AsyncRead = nil
do

    asyncFunctions = {
        Append: false,
        Write: false,
        Read: false
    }

    do

        sources = {
            {
                Name: "gm_asyncio"
                Available: util.IsBinaryModuleInstalled( "asyncio" )
                Get: ->
                    require( "asyncio" )
                    return {
                        Append: asyncio.AsyncAppend
                        Write: asyncio.AsyncWrite
                        Read: asyncio.AsyncRead
                    }
            },
            {
                Name: "async_write"
                Available: util.IsBinaryModuleInstalled( "async_write" )
                Get: ->
                    require( "async_write" )
                    return {
                        Append: file.AsyncAppen
                        Write: file.AsyncWrite
                    }
            },
            {
                Name: "Garry's Mod Async"
                Available: not MENU_DLL
                Get: ->
                    return {
                        Read: file.AsyncRead
                    }
            },
            {
                Name: "Garry's Mod"
                Available: true
                Get: ->
                    return {
                        Append: ( fileName, content, func ) ->
                            state = lib_Append( fileName, content, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                        Write: ( fileName, content, func ) ->
                            state = lib_Write( fileName, content, "wb", true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                        Read: ( fileName, gamePath, func ) ->
                            ok, content = lib_Read( fileName, gamePath )
                            state = ok and 0 or -1
                            func( fileName, gamePath, state, content )
                            return state
                    }
            }
        }

        count = 0
        for source in *sources
            unless source.Available
                continue

            functions = source.Get!
            installed = 0

            for funcName, func in pairs( asyncFunctions )
                if func == false
                    func = functions[ funcName ]
                    if func ~= nil
                        asyncFunctions[ funcName ] = func
                        installed += 1
                        count += 1

            if installed > 0
                Logger\Info "'%s' was connected as filesystem API.", source.Name

            if count > 2
                break

    class FileSystemAsyncError extends Error

    FSASYNC = {
        [ -8 ]: "Filename not part of the specified file system, try a different one."
        [ -7 ]: "Failure for a reason that might be temporary, you might retry, but not immediately."
        [ -6 ]: "Read parameters invalid for unbuffered IO."
        [ -5 ]: "Hard subsystem failure."
        [ -4 ]: "Read error on file."
        [ -3 ]: "Out of memory for file read."
        [ -2 ]: "Caller's provided id is not recognized."
        [ -1 ]: "Filename could not be opened (bad path, not exist, etc)."
        [  0 ]: "Operation is successful."
        [  1 ]: "File is properly queued, waiting for service."
        [  2 ]: "File is being accessed."
        [  3 ]: "File was aborted by caller."
        [  4 ]: "File is not yet queued."
    }

    lib.FileSystemAsyncError = FileSystemAsyncError
    lib.FSASYNC = FSASYNC

    do

        :Read = asyncFunctions

        lib_AsyncRead = ( filePath, gameDir ) ->
            p = Promise!

            code = Read filePath, gameDir, ( fileName, gamePath, code, content ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath, :content } )

                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )

            if code ~= 0
                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )

            return p

        lib.AsyncRead = lib_AsyncRead

    do

        :Write = asyncFunctions

        lib.AsyncWrite = ( filePath, content, fastMode ) ->
            unless fastMode
                lib_BuildFilePath( filePath )

            p = Promise!

            code = Write filePath, content, ( fileName, gamePath, code ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath } )

                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )

            if code ~= 0
                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )

            return p

    do

        :Append = asyncFunctions

        lib.AsyncAppend = ( filePath, content, fastMode ) ->
            unless fastMode
                lib_BuildFilePath( filePath )

            p = Promise!

            code = Append filePath, content, ( fileName, gamePath, code ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath } )

                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )

            if code ~= 0
                p\Reject( FileSystemAsyncError( FSASYNC[ code ] ) )

            return p

do

    class FileSystemCompileError extends Error
    lib.FileSystemCompileError = FileSystemCompileError

    do

        CompileString, CompileFile = CompileString, CompileFile

        lib.CompileLua = async ( filePath, gamePath, handleError ) ->
            if CLIENT and lib_IsMounted( filePath, gamePath )
                filePath = "lua/" .. filePath
                gamePath = "GAME"

            :content = await lib_AsyncRead( filePath, gamePath )
            unless content
                error FileSystemCompileError "File #{filePath} cannot be read."

            func = CompileString( content, filePath, handleError )
            if not func and ( gamePath == "LUA" or gamePath == "lsv" or gamePath == "lcl" )
                func = CompileFile( filePath )

            if func
                return func

            error FileSystemCompileError "File '#{filePath}' is missing in file system."

    do

        :CompileMoonString = util

        lib.CompileMoon = async ( filePath, gamePath, handleError ) ->
            :content = await lib_AsyncRead( filePath, gamePath )
            unless content
                error FileSystemCompileError "File #{filePath} cannot be read."

            return CompileMoonString( content, filePath, handleError )

    do

        :CompileYueString = util

        lib.CompileYue = async ( filePath, gamePath, handleError, yueConfig ) ->
            :content = await lib_AsyncRead( filePath, gamePath )
            unless content
                error FileSystemCompileError "File #{filePath} cannot be read."

            return CompileYueString( content, filePath, handleError, yueConfig )

do

    :DecompressDeflate = gpm.deflate
    tostring = tostring
    :fempty = debug
    :CRC = util

    lib.IterateZipFiles = ( fileHandle, doCRC ) ->
        unless fileHandle
            return fempty

        return ->
            if fileHandle\Read( 4 ) ~= "PK\x03\x04"
                return
            fileHandle\Skip( 4 )

            compressionMethod = fileHandle\ReadUShort!
            fileHandle\Skip( 4 )

            crc = fileHandle\ReadULong!
            compressedSize = fileHandle\ReadULong!
            fileHandle\Skip( 4 )

            fileNameLen = fileHandle\ReadUShort!
            extraLen = fileHandle\ReadUShort!
            fileName = fileHandle\Read( fileNameLen )
            fileHandle\Skip( extraLen )

            data = nil
            switch compressionMethod
                -- Without compression
                when 0
                    data = fileHandle\Read( compressedSize )

                -- Deflate compression
                when 8
                    compressedData = fileHandle\Read( compressedSize )
                    data = DecompressDeflate( compressedData )

            if data ~= nil and doCRC ~= false and tostring( crc ) ~= CRC( data )
                data = nil

            return fileName, data

return lib
