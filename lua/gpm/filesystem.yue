import Environment, InitTable, Logger from gpm
SERVER = SERVER
CLIENT = CLIENT
error = error
file = file

import async, await, debug, util, path, string, ArgAssert, Promise from Environment
import FastSplit, GetPathFromFilename, GetExtensionFromFilename from string
import Join, Resolve, Fix from path
import Find from file

-- https://github.com/Pika-Software/gm_efsw
if SERVER and not efsw and util.IsBinaryModuleInstalled( "efsw" ) and pcall( require, "efsw" )
    Logger\Info( "gm_efsw is initialized, package auto-reloading are available." )

lib = InitTable Environment, "file", ->
    return setmetatable( {}, { __index: file } )

-- file.Time( filePath, gamePath ) - returns file creation time as number
lib.Time = file.Time

-- file.Find( filePath, gamePath, sorting ) - returns list of found files and folders
lib.Find = Find

-- file.LuaPath - "LUA" or "lsv"
luaPath = SERVER and "lsv" or "LUA"
lib.LuaPath = luaPath

-- file.LuaGamePaths - table of lua game paths
luaGamePaths = {
    "LuaMenu": true
    "lsv": true
    "LUA": true
    "lcl": true
}

lib.LuaGamePaths = luaGamePaths

do

    import LocalizeLua from path
    import getfpath from debug

    file.ResolvePath = ( ... ) ->
        return Resolve( LocalizeLua( getfpath! ), ... )

do

    import GetFileFromFilename from string
    import Rename from file

    -- file.Move( filePath, newFilePath ) - moves file to new path
    lib.Move = ( filePath, newFilePath ) ->
        return Rename( filePath, Resolve( filePath, newFilePath .. "/" .. GetFileFromFilename( filePath ) ) )

    -- file.Rename( filePath, newFileName ) - renames file
    lib.Rename = ( filePath, newFileName ) ->
        return Rename( filePath, Resolve( GetPathFromFilename( filePath ) .. "/" .. newFileName ) )

local isFileMounted, isDirMounted
do

    mountedFiles, mountedFolders = InitTable( lib, "MountedFiles" ), InitTable( lib, "MountedFolders" )

    allowedGamePaths = {
        "LUA": true
        "lsv": true
        "lcl": true
        "GAME": true
        "WORKSHOP": true
        "THIRDPARTY": true
    }

    isFileMounted = ( filePath, gamePath ) ->
        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFiles[ filePath ]

    lib.IsFileMounted = isFileMounted

    isDirMounted = ( filePath, gamePath ) ->
        unless allowedGamePaths[ gamePath ]
            return false

        if luaGamePaths[ gamePath ]
            filePath = "lua/" .. filePath

        return mountedFolders[ filePath ]

    lib.IsDirMounted = isDirMounted

    -- file.MountGMA( filePath ) - mounts gma file to game filesystem and returns state and list of files
    do

        import MountGMA from game
        import concat from table

        lib.MountGMA = ( filePath ) ->
            success, files = MountGMA( filePath )
            if success
                fileCount = #files
                for index = 1, fileCount
                    filePath = files[ index ]

                    -- mounted files
                    mountedFiles[ filePath ] = true

                    -- mounted folders
                    segments, segmentCount = FastSplit( GetPathFromFilename( filePath ), 0x2F --[[ / ]] )
                    segmentCount -= 1

                    while segmentCount ~= 0
                        mountedFolders[ concat( segments, "/", 1, segmentCount ) ] = true
                        segmentCount -= 1

                Logger\Debug( "GMA file '%s' was mounted to GAME with %d files.", filePath, fileCount )

            return success, files

local isDir, isFile, createDir
do

    import Delete, Exists, IsDir from file

    -- file.Exists( filePath, gamePath ) - check if the path exists
    lib.Exists = ( filePath, gamePath ) ->
        return Exists( filePath, gamePath ) or isFileMounted( filePath, gamePath ) or isDirMounted( filePath, gamePath )

    -- file.IsDir( filePath, gamePath ) - check if the path is a directory
    isDir = ( filePath, gamePath ) ->
        return IsDir( filePath, gamePath ) or isDirMounted( filePath, gamePath )

    lib.IsDir = isDir

    -- file.IsFile( filePath, gamePath ) - check if the path is a file
    isFile = ( filePath, gamePath ) ->
        if isDir( filePath, gamePath )
            return false

        return isFileMounted( filePath, gamePath ) or Exists( filePath, gamePath )

    lib.IsFile = isFile

    -- file.Delete( filePath, gamePath ) - delete the file or folder
    do

        delete = ( filePath, gamePath ) ->
            gamePath = gamePath or "DATA"

            if isDir( filePath, gamePath )
                files, folders = Find( Join( filePath, "*" ), gamePath )
                for folderName in *folders
                    delete( Join( filePath, folderName ), gamePath )

                for fileName in *files
                    Delete( Join( filePath, fileName ), gamePath )

                return Delete( filePath, gamePath )

            return Delete( filePath, gamePath )

        lib.Delete = delete

    -- file.CreateDir( folderPath, force ) - create the folders by the path
    do

        import CreateDir from file

        createDir = ( folderPath, force ) ->
            if force
                currentPath = nil
                for folderName in *FastSplit( folderPath, 0x2F --[[ / ]] )
                    if folderName
                        if currentPath
                            currentPath ..= "/" .. folderName
                        else
                            currentPath = folderName

                        if IsDir( currentPath, "DATA" )
                            continue

                        Delete( currentPath, "DATA" )
                        CreateDir( currentPath )

                return currentPath

            CreateDir( folderPath )
            return folderPath

        lib.CreateDir = createDir

    -- file.Size( filePath, gamePath ) - return the size of the file or folder in bytes as a number
    import Size from file

    size = ( filePath, gamePath ) ->
        unless isDir( filePath, gamePath )
            return Size( filePath, gamePath )

        result = 0

        files, folders = Find( Join( filePath, "*" ), gamePath )
        for fileName in *files
            result += Size( Join( filePath, fileName ), gamePath )

        for folderName in *folders
            result += size( Join( filePath, folderName ), gamePath )

        return result

    lib.Size = size

-- file.BuildFilePath( filePath, force ) - build the file path
buildFilePath = ( filePath, force ) ->
    folderPath = GetPathFromFilename( filePath )
    if folderPath
        createDir( folderPath, force )

    return folderPath

lib.BuildFilePath = buildFilePath

-- file.GetFilePaths( folderPath, gamePath ) - return all files and subfolders in the folder like a table with strings
do

    getFilePaths = ( folderPath, gamePath, result, length ) ->
        unless result
            result, length = {}, 0

        folderPath = Resolve( folderPath .. "/" )

        files, folders = Find( folderPath .. "*", gamePath or "GAME" )
        unless files
            return result, length

        for fileName in *files
            length += 1
            result[ length ] = folderPath .. fileName

        for folderName in *folders
            getFilePaths( folderPath .. folderName, gamePath, result, length )

        return result, length

    lib.GetFilePaths = getFilePaths

-- file.IsCompilable( filePath, doPreCache ) - check if the file can be compiled
local isCompilable
do

    preCacheFunc = Environment.moonloader and Environment.moonloader.PreCacheFile
    import sub from string

    supportedExtensions = { moon: true, yue: true, lua: true }
    preCacheableExtensions = { "moon", "yue" }

    isCompilable = ( filePath, doPreCache ) ->
        extension = GetExtensionFromFilename( filePath )
        if extension
            if supportedExtensions[ extension ]
                filePath = sub( filePath, 1, #filePath - ( #extension + 1 ) )
            else
                return false

        for index = 1, 2
            preCachePath = filePath .. "." .. preCacheableExtensions[ index ]
            if isFile( preCachePath, luaPath )
                if doPreCache and preCacheFunc
                    if preCacheFunc( preCachePath )
                        Logger\Debug( "Pre-compiling '%s' into Lua completed successfully.", preCachePath )
                    else
                        error( "Pre-compiling '" .. preCachePath .. "' file in Lua failed." )

                return true

        return isFile( filePath .. ".lua", luaPath )

    lib.IsCompilable = isCompilable

do

    import Open from file

    File = FindMetaTable( "File" )
    :Close, :Read, :Write = File

    do

        :ReadULong, :WriteULong, :ReadByte, :WriteByte, :EndOfFile, :Seek, :Skip, :Tell = File

        -- File::SkipEmpty() - skips empty bytes
        File.SkipEmpty = ( fileHandle ) ->
            while not EndOfFile( fileHandle )
                if ReadByte( fileHandle ) ~= 0
                    Skip( fileHandle, -1 )
                    break

        -- File::ReadString() - reads string to first empty byte
        File.ReadString = ( fileHandle ) ->
            startPos, length = Tell( fileHandle ), 0
            while not EndOfFile( fileHandle ) and ReadByte( fileHandle ) ~= 0
                length += 1

            Seek( fileHandle, startPos )
            data = Read( fileHandle, length )
            Skip( fileHandle, 1 )
            return data

        -- File::WriteString( str ) - writes string and empty byte
        File.WriteString = ( fileHandle, str ) ->
            Write( fileHandle, str )
            WriteByte( fileHandle, 0 )

        -- File::ReadUInt64() - reads 4 bytes as number and skips 4 bytes
        if File.ReadUInt64 == nil
            File.ReadUInt64 = ( fileHandle ) ->
                number = ReadULong( fileHandle )
                Skip( fileHandle, 4 )
                return number

        -- File::WriteUInt64( number ) - writes 4 bytes as number and 4 empty bytes
        if File.WriteUInt64 == nil
            File.WriteUInt64 = ( fileHandle, number ) ->
                WriteULong( fileHandle, number )
                WriteULong( fileHandle, 0 )

    -- file.Open( filePath, mode, gamePath ) - opens file and returns file handler
    lib.Open = Open

    -- file.Append( filePath, content, force ) - appends content to file
    lib.Append = ( filePath, content, force ) ->
        if force
            buildFilePath( filePath, true )

        fileHandle = Open( filePath, "ab", "DATA" )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

    -- file.Read( filePath, gamePath, length ) - returns file content as string
    lib.Read = ( filePath, gamePath, length ) ->
        fileHandle = Open( filePath, "rb", gamePath )
        if fileHandle
            return Read( fileHandle, length ), Close( fileHandle )

    -- file.Write( filePath, content, force ) - writes content to file
    lib.Write = ( filePath, content, force ) ->
        if force
            buildFilePath( filePath, true )

        fileHandle = Open( filePath, "wb", "DATA" )
        if fileHandle
            Write( fileHandle, content )
            Close( fileHandle )
            return true

        return false

if SERVER

    import ReplaceExtension from path
    AddCSLuaFile = AddCSLuaFile
    import getfpath from debug

    -- file.AddCSLuaFile( filePath )
    lib.AddCSLuaFile = ( fileName ) ->
        currentPath = getfpath!
        if not fileName and currentPath and isFile( currentPath, luaPath )
            AddCSLuaFile( currentPath )
            return

        ArgAssert( fileName, 1, "string" )
        fileName = ReplaceExtension( fileName, "lua" )

        if currentPath
            currentFolder = GetPathFromFilename( currentPath )
            if currentFolder
                filePath = currentFolder .. fileName
                if isCompilable( filePath, true )
                    AddCSLuaFile( filePath )
                    return

        if isCompilable( fileName, true )
            AddCSLuaFile( fileName )
            return

        error( "Couldn't AddCSLuaFile file '" .. fileName .. "' - File not found" )

    -- file.AddCSLuaFolder( folderPath )
    addCSLuaFolder = ( folderPath ) ->
        folderPath = Fix( folderPath .. "/" )

        files, folders = Find( folderPath .. "*", "lsv" )
        for folderName in *folders
            addCSLuaFolder( folderPath .. folderName )

        for fileName in *files
            filePath = folderPath .. fileName
            if isCompilable( filePath, true )
                AddCSLuaFile( ReplaceExtension( filePath, "lua" ) )

    lib.AddCSLuaFolder = addCSLuaFolder

-- Entropia File System Watcher
if istable( efsw )
    import Watch, Unwatch from efsw

    -- file.WatchList
    observedFiles = InitTable( lib, "ObservedFiles" )

    -- file.Watch( filePath, gamePath )
    watch = ( filePath, gamePath ) ->
        if observedFiles[ filePath .. ";" .. gamePath ]
            return false

        observedFiles[ filePath .. ";" .. gamePath ] = Watch( filePath, gamePath )

        if isDir( filePath, gamePath )
            filePath = Fix( filePath .. "/" )

            _, folders = Find( filePath .. "*", gamePath )
            for folderName in *folders
                watch( filePath .. folderName, gamePath )

        return true

    lib.Watch = watch

    -- file.UnWatch( filePath, gamePath ) - stops file watching
    unWatch = ( filePath, gamePath ) ->
        watchID = observedFiles[ filePath .. ";" .. gamePath ]
        if watchID
            observedFiles[ filePath .. ";" .. gamePath ] = nil
            Unwatch( watchID )

            if isDir( filePath, gamePath )
                filePath = Fix( filePath .. "/" )

                _, folders = Find( filePath .. "*", gamePath )
                for folderName in *folders
                    unWatch( filePath .. folderName, gamePath )

            return true

        return false

    lib.UnWatch = unWatch

else

    lib.Watch = ->
        return false

    lib.Unwatch = lib.Watch

local asyncRead
do

    asyncFunctions = {
        "Append": false
        "Write": false
        "Read": false
    }

    do

        sources = {
            {
                "Name": "gm_asyncio"
                "Available": util.IsBinaryModuleInstalled( "asyncio" )
                "Get": ->
                    require( "asyncio" )
                    return {
                        "Append": asyncio.AsyncAppend
                        "Read": asyncio.AsyncRead
                        "Write": asyncio.AsyncWrite
                    }
            },
            {
                "Name": "async_write"
                "Available": util.IsBinaryModuleInstalled( "async_write" )
                "Get": ->
                    require( "async_write" )
                    return {
                        "Append": file.AsyncAppen
                        "Write": file.AsyncWrite
                    }
            },
            {
                "Name": "Garry's Mod Async"
                "Available": not MENU_DLL
                "Get": ->
                    return {
                        "Read": file.AsyncRead
                    }
            },
            {
                "Name": "Garry's Mod"
                "Available": true
                "Get": ->
                    :Append, :Read, :Write = lib

                    return {
                        "Append": ( fileName, content, func ) ->
                            state = Append( fileName, content, true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state

                        "Read": ( fileName, gamePath, func ) ->
                            content = Read( fileName, gamePath )
                            state = content == nil and -1 or 0
                            func( fileName, gamePath, state, content )
                            return state

                        "Write": ( fileName, content, func ) ->
                            state = Write( fileName, content, "wb", true ) and 0 or -1
                            func( fileName, "DATA", state )
                            return state
                    }
            }
        }

        count = 0
        for source in *sources
            if source.Available
                functions = source.Get!
                installed = 0

                for funcName, func in pairs( asyncFunctions )
                    if func == false
                        func = functions[ funcName ]
                        if func
                            asyncFunctions[ funcName ] = func
                            installed += 1
                            count += 1

                if installed > 0
                    Logger\Info "'%s' was connected as filesystem API.", source.Name

                if count > 2
                    break

    -- Environment.FileSystemAsyncError - async error
    class FileSystemAsyncError extends Environment.Error
    Environment.FileSystemAsyncError = FileSystemAsyncError

    -- file.FSASYNC - async error messages table
    FSASYNC = {
        [ -8 ]: "Filename not part of the specified file system, try a different one."
        [ -7 ]: "Failure for a reason that might be temporary, you might retry, but not immediately."
        [ -6 ]: "Read parameters invalid for unbuffered IO."
        [ -5 ]: "Hard subsystem failure."
        [ -4 ]: "Read error on file."
        [ -3 ]: "Out of memory for file read."
        [ -2 ]: "Caller's provided id is not recognized."
        [ -1 ]: "Filename could not be opened (bad path, not exist, etc)."
        [  0 ]: "Operation is successful."
        [  1 ]: "File is properly queued, waiting for service."
        [  2 ]: "File is being accessed."
        [  3 ]: "File was aborted by caller."
        [  4 ]: "File is not yet queued."
    }

    lib.FSASYNC = FSASYNC

    -- file.AsyncAppend( filePath, content, force ) - async append function that returns promise
    do

        :Append = asyncFunctions

        lib.AsyncAppend = ( filePath, content, force ) ->
            if force
                buildFilePath( filePath, true )

            p = Promise!

            state = Append filePath, content, ( fileName, gamePath, code ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath } )

                p\Reject( FileSystemAsyncError FSASYNC[ code ] )

            if state ~= 0
                p\Reject( FileSystemAsyncError FSASYNC[ state ] )

            return p

    -- file.AsyncRead( filePath, gameDir ) - async read function that returns promise
    do

        :Read = asyncFunctions

        asyncRead = ( filePath, gameDir ) ->
            p = Promise!

            state = Read filePath, gameDir, ( fileName, gamePath, code, content ) ->
                if code == 0
                    return p\Resolve( content )

                p\Reject( FileSystemAsyncError FSASYNC[ code ] )

            if state ~= 0
                p\Reject( FileSystemAsyncError FSASYNC[ state ] )

            return p

        lib.AsyncRead = asyncRead

    -- file.AsyncWrite( filePath, content, force ) - async write function that returns promise
    do

        :Write = asyncFunctions

        lib.AsyncWrite = ( filePath, content, force ) ->
            if force
                buildFilePath( filePath, true )

            p = Promise!

            state = Write filePath, content, ( fileName, gamePath, code ) ->
                if code == 0
                    return p\Resolve( { :fileName, :gamePath } )

                p\Reject( FileSystemAsyncError FSASYNC[ code ] )

            if state ~= 0
                p\Reject( FileSystemAsyncError FSASYNC[ state ] )

            return p

do

    -- file.LuaCompileError - compile error
    class LuaCompileError extends Environment.Error
    Environment.LuaCompileError = LuaCompileError

    -- file.CompileLua( filePath, gamePath, handleError ) - async lua file compile function that returns promise
    local compileLua
    do

        CompileString = CompileString
        CompileFile = CompileFile

        compileLua = async ( filePath, gamePath, handleError ) ->
            if CLIENT and isFileMounted( filePath, gamePath )
                if luaGamePaths[ gamePath ]
                    filePath = "lua/" .. filePath

                gamePath = "WORKSHOP"

            content = await asyncRead( filePath, gamePath )
            unless content
                error LuaCompileError "File '" .. filePath .. "' cannot be read."

            func = CompileString( content, filePath, handleError )
            if not func and luaGamePaths[ gamePath ]
                func = CompileFile( filePath )

            if func
                return func

            error LuaCompileError "File '" .. filePath .. "' is missing in file system."

        lib.CompileLua = compileLua

    -- file.CompileMoon( filePath, gamePath, handleError ) - async moon file compile function that returns promise
    local compileMoon
    do

        import CompileMoonString from util

        compileMoon = async ( filePath, gamePath, handleError ) ->
            content = await asyncRead( filePath, gamePath )
            unless content
                error LuaCompileError "File '" .. filePath .. "' cannot be read."

            return CompileMoonString( content, filePath, handleError )

        lib.CompileMoon = compileMoon

    -- file.CompileYue( filePath, gamePath, handleError, yueConfig ) - async yue file compile function that returns promise
    local compileYue
    do

        import CompileYueString from util

        compileYue = async ( filePath, gamePath, handleError, yueConfig ) ->
            content = await asyncRead( filePath, gamePath )
            unless content
                error LuaCompileError "File '" .. filePath .. "' cannot be read."

            return CompileYueString( content, filePath, handleError, yueConfig )

        lib.CompileYue = compileYue

    -- file.Compile( filePath, gamePath, handleError, yueConfig ) - async file compile function that returns promise
    do

        import StripExtension from string

        lib.Compile = ( fullPath, gamePath, handleError, yueConfig ) ->
            filePath = Fix( StripExtension( fullPath ) )

            compilePath = filePath .. ".lua"
            if isFile( compilePath, gamePath )
                return compileLua( compilePath, gamePath, handleError )

            compilePath = filePath .. ".moon"
            if isFile( compilePath, gamePath )
                return compileMoon( compilePath, gamePath, handleError )

            compilePath = filePath .. ".yue"
            if isFile( compilePath, gamePath )
                return compileYue( compilePath, gamePath, handleError, yueConfig )

            error LuaCompileError "File '" .. fullPath .. "' cannot be found."

-- file.DecompressDeflate( fileHandle, doCRC ) - zip files iterator
do

    import DecompressDeflate from Environment.deflate
    import fempty from debug
    import CRC from util
    tostring = tostring

    lib.IterateZipFiles = ( fileHandle, doCRC ) ->
        unless fileHandle
            return fempty

        return ->
            if fileHandle\Read( 4 ) ~= "PK\x03\x04"
                return
            fileHandle\Skip( 4 )

            compressionMethod = fileHandle\ReadUShort!
            fileHandle\Skip( 4 )

            crc = fileHandle\ReadULong!
            compressedSize = fileHandle\ReadULong!
            fileHandle\Skip( 4 )

            fileNameLen = fileHandle\ReadUShort!
            extraLen = fileHandle\ReadUShort!
            fileName = fileHandle\Read( fileNameLen )
            fileHandle\Skip( extraLen )

            data = nil
            switch compressionMethod
                -- Without compression
                when 0
                    data = fileHandle\Read( compressedSize )

                -- Deflate compression
                when 8
                    compressedData = fileHandle\Read( compressedSize )
                    data = DecompressDeflate( compressedData )

            if data ~= nil and doCRC ~= false and tostring( crc ) ~= CRC( data )
                data = nil

            return fileName, data

return lib
