_G = _G
import isnumber, gpm, SERVER from _G
import environment, Logger from gpm
import getmetatable, setmetatable, istable, pcall from _G
import math, string, table, os, util, argument, isfunction, isstring, error from environment
import byte, sub, gsub, len, find from string
import concat from table
import fdiv from math
import time from os

do

    import CodeCompileError from environment
    local installed

    if util.IsBinaryModuleInstalled( "moonloader" )
        ok, msg = pcall( require, "moonloader" )
        if ok and istable( moonloader )
            Logger\Loaded( "gm_moonloader v%s", moonloader._VERSION )
            installed = true
        else
            Logger\Error( "gm_moonloader startup error: %s", msg or "unknown error" )
            installed = false
    else
        installed = false

    yueFail = ->
        error CodeCompileError "Attempt to compile Yuescript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader."

    if installed
        moonloader = environment.moon = _G.moonloader

        -- Yuescript
        import yue from moonloader

        if istable( yue )
            environment.yue = yue
        else

            environment.yue = {
                ToLua: yueFail
            }

            Logger\Warn( "Yuescript support is missing, yue package execution is unavailable!" )

    else

        moonFail = ->
            error CodeCompileError "Attempt to compile MoonScript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader."

        environment.moon = {
            PreCacheFile: moonFail,
            PreCacheDir: moonFail,
            ToLua: moonFail
        }

        environment.yue = {
            ToLua: yueFail
        }

        Logger\Warn( "gm_moonloader is missing, support for moon and yue scripts is unavailable!" )

do


    -- https://github.com/willox/gmbc
    byteCodeSupported = false
    if util.IsBinaryModuleInstalled( "gmbc" )
        byteCodeSupported = pcall( require, "gmbc" )

    import CompileString, gmbc_load_bytecode, setfenv from _G
    import yue, moon from environment
    import IsBytecode from string

    environment.loadstring = ( code, identifier, handleError = true, ignoreBytecode ) ->
        if not ignoreBytecode and IsBytecode( code )
            if byteCodeSupported
                return gmbc_load_bytecode( code )

            msg = "Bytecode compilation is not supported. Please install gmbc (https://github.com/willox/gmbc)"
            if handleError
                error msg, 2
                return nil

            return msg

        return CompileString( code, identifier, handleError )

    load = ( chunk, chunkName, mode = "bt", env = getfenv( 2 ), config, handleError = true ) ->
        argument( chunkName, 2, "string" )

        if mode == ""
            mode = "bt"

        switch type( chunk )
            when "string"
                modes = {}
                for byte0 in *{ byte( mode, 1, len( mode ) ) }
                    modes[ byte0 ] = true

                local func
                if modes[ 0x62 --[[ b ]] ] and IsBytecode( chunk )
                    if byteCodeSupported
                        func = gmbc_load_bytecode( chunk )

                    msg = "Bytecode compilation is not supported."
                    if handleError
                        error msg, 2
                        return nil

                    return msg

                if modes[ 0x79 --[[ y ]] ]
                    if config
                        argument( config, 5, "table" )
                        chunk = yue.ToLua( chunk, config )
                    else
                        chunk = yue.ToLua( chunk )

                elseif modes[ 0x6D --[[ m ]] ]
                    chunk = moon.ToLua( chunk )

                if modes[ 0x74 --[[ t ]] ]
                    func = CompileString( chunk, chunkName, handleError )

                if func
                    if isfunction( func ) and env
                        setfenv( func, env )

                    return func

                msg = "wrong load mode"
                if handleError
                    error msg, 2
                    return nil

                return msg

            when "function"
                result, length = {}, 0

                str = chunk!
                while str
                    length += 1
                    result[ length ] = str
                    str = chunk!

                if length == 0
                    return ->

                return load( concat( result, "", 1, length ), chunkName, mode, env, config, handleError )

        error "Invalid argument #1 to 'load' (string/function expected)", 2
        return nil

    environment.load = load

do

    import Delay, SafeAwait from environment.Promise

    environment.sleep = ( delay = 0 ) ->
        argument( delay, 1, "number" )
        SafeAwait( Delay( delay ) )
        return nil

table.Flip = ( tbl ) ->
    length = #tbl
    finish = fdiv( length, 2 )
    length += 1

    for index = 1, finish, 1
        tbl[ index ], tbl[ length - index ] = tbl[ length - index ], tbl[ index ]

    return tbl

do

    import struct from environment
    import io from struct

    -- lua 5.3 string features
    do

        import Read, Write from struct
        import unpack from table

        string.pack = ( fmt, ... ) ->
            return Write( fmt, { ... } )

        string.unpack = ( fmt, binary, offset ) ->
            if offset
                return unpack( Read( fmt, sub( binary, offset, len( binary ) ) ) )

            return unpack( Read( fmt, binary ) )

        string.packsize = struct.SizeOf

    import Read from io.i
    import Little from io.endianness

    util.LZMA_PROPS_SIZE = 5

    util.CompressedSize = ( binary ) ->
        if binary == ""
            return 0

        Little!
        return Read( nil, sub( binary, 6, 14 ), 8 )

    -- Byte Stream
    import char, reverse, format from string
    import deflate, Color from environment
    import unix2dos, dos2unix from os
    import CRC, Date from util
    import clamp from math

    local readInt, writeInt
    do
        int = io.i
        readInt, writeInt = int.Read, int.Write

    local readUInt, writeUInt
    do
        uint = io.I
        readUInt, writeUInt = uint.Read, uint.Write

    local readFloat, writeFloat
    do
        float = io.f
        readFloat, writeFloat = float.Read, float.Write

    local readDouble, writeDouble
    do
        double = io.d
        readDouble, writeDouble = double.Read, double.Write

    local readQuad, writeQuad
    do
        quad = io.q
        readQuad, writeQuad = quad.Read, quad.Write

    import endianness from io
    setEndianness = endianness.Set

    noCompression = ( content ) ->
        return content

    compressionMethods = {
        -- No compression
        [ 0 ]: {
            [1]: noCompression,
            [2]: noCompression
        },

        -- Deflate
        [ 8 ]: {
            [1]: deflate.CompressDeflate,
            [2]: deflate.DecompressDeflate
        }
    }

    seek = ( position ) =>
        @Flush!

        if position
            argument( position, 2, "number" )
            position = clamp( position, 0, @size )
        else
            position = 0

        @position = position
        return position

    Int64 = environment.Int64 = util.Bint( 64 )
    import FromBigEndian, FromLittleEndian, ToBigEndian, ToLittleEndian from Int64

    util.ByteStream = environment.class(
        "ByteStream",
        {
            __tostring: =>
                return format( "ByteStream: %p [%d/%d]", @, @position, @size )

            IsValid: =>
                return @data ~= nil

            EndOfFile: =>
                return @position >= @size

            Size: =>
                return @size

            Tell: =>
                return @position

            Close: =>
                @Flush!
                @position = 0

            Seek: seek
            SeekTo: seek

            SeekToBegin: =>
                return @Seek( 0 )

            SeekToEnd: =>
                return @Seek( @size - @position )

            SkipEmpty: =>
                while not @EndOfFile!
                    if @ReadByte! ~= 0
                        @Skip( -1 )
                        break

            Skip: ( bytes ) =>
                if bytes
                    argument( bytes, 2, "number" )
                else
                    bytes = 1

                return @Seek( @position + bytes )

            -- Byte read
            Read: ( bytes ) =>
                :position, :size = @

                if bytes == "*a" or bytes == nil
                    bytes = size

                argument( bytes, 2, "number" )

                if bytes > 0
                    if position >= size
                        return nil, "eof"

                    return sub( @data, position + 1, @Skip( bytes ) )

                if bytes < 0
                    if position <= 0
                        return nil, "sof"

                    return reverse( sub( @data, position + 1, @Skip( bytes ) ) )

            ReadAll: =>
                @SeekToBegin!
                return @Read( @size )

            -- String
            ReadString: =>
                :position, :size = @
                if position >= size
                    return nil, "eof"

                bytes, data = 0, @data
                for index = position, size
                    if byte( data, index + 1 ) == 0
                        break

                    bytes += 1

                if bytes == 0
                    @Skip( 1 )
                    return nil

                str = @Read( bytes )
                @Skip( 1 )
                return str

            WriteString: ( str ) =>
                argument( str, 1, "string" )
                return @Write( str .. "\0" )

            -- Line
            ReadLine: =>
                :position, :size = @
                if position >= size
                    return nil, "eof"

                bytes, data = 0, @data
                for index = position, size
                    if byte( data, index + 1 ) == 0xA --[[ \n ]]
                        break

                    bytes += 1

                if bytes == 0
                    @Skip( 1 )
                    return nil

                line = @Read( bytes )
                @Skip( 1 )
                return line

            WriteLine: ( str ) =>
                argument( str, 1, "string" )
                return @Write( str .. "\n" )

            -- Byte
            ReadByte: =>
                if @EndOfFile!
                    return nil, "eof"

                return byte( @data, @Skip( 1 ) )

            WriteByte: ( number ) =>
                return @Write( char( number ) )

            -- Boolean
            ReadBool: =>
                switch @ReadByte!
                    when 0
                        return false

                    when 1
                        return true

                return nil, "eof"

            WriteBool: ( bool ) =>
                return @WriteByte( bool and 1 or 0 )

            -- UInt
            ReadUInt: ( bytes, endianness ) =>
                argument( bytes, 2, "number", 4 )
                setEndianness( endianness or "little" )
                return readUInt( nil, @Read( bytes ), bytes )

            WriteUInt: ( number, bytes, endianness ) =>
                if isstring( number )
                    number = tonumber( number, 10 )

                argument( number, 1, "number", 4 )
                argument( bytes, 2, "number", 4 )
                setEndianness( endianness or "little" )
                return @Write( writeUInt( nil, number, bytes ) )

            -- UShort
            ReadUShort: ( endianness ) =>
                return @ReadUInt( 2, endianness )

            WriteUShort: ( number, endianness ) =>
                return @WriteUInt( number, 2, endianness )

            -- ULong
            ReadULong: ( endianness ) =>
                return @ReadUInt( 4, endianness )

            WriteULong: ( number, endianness ) =>
                return @WriteUInt( number, 4, endianness )

            -- UInt64
            ReadUInt64: ( endianness ) =>
                return @ReadUInt( 8, endianness )

            WriteUInt64: ( number, endianness ) =>
                @WriteUInt( number, 8, endianness )

            -- Int
            ReadInt: ( bytes, endianness ) =>
                argument( bytes, 2, "number", 4 )
                setEndianness( endianness or "little" )
                return readInt( nil, @Read( bytes ), bytes )

            WriteInt: ( number, bytes, endianness ) =>
                argument( number, 1, "number", 4 )
                argument( bytes, 2, "number", 4 )
                setEndianness( endianness or "little" )
                return @Write( writeInt( nil, number, bytes ) )

            -- Short
            ReadShort: ( endianness ) =>
                return @ReadInt( 2, endianness )

            WriteShort: ( number, endianness ) =>
                return @WriteInt( number, 2, endianness )

            -- Long
            ReadLong: ( endianness ) =>
                return @ReadInt( 4, endianness )

            WriteLong: ( number, endianness ) =>
                return @WriteInt( number, 4, endianness )

            -- Int64
            ReadInt64: ( endianness ) =>
                if endianness.value == "big"
                    return FromBigEndian( @Read( 8 ) )

                return FromLittleEndian( @Read( 8 ) )

            WriteInt64: ( number, endianness ) =>
                if endianness.value == "big"
                    return @Write( ToBigEndian( number ) )

                return @Write( ToLittleEndian( number ) )

            -- Float
            ReadFloat: ( endianness ) =>
                setEndianness( endianness or "little" )
                return readFloat( nil, @Read( 4 ), 4 )

            WriteFloat: ( number, endianness ) =>
                argument( number, 2, "number" )
                setEndianness( endianness or "little" )
                return @Write( writeFloat( nil, number, 4 ) )

            -- Double
            ReadDouble: ( endianness ) =>
                setEndianness( endianness or "little" )
                return readDouble( nil, @Read( 8 ), 8 )

            WriteDouble: ( number, endianness ) =>
                argument( number, 2, "number" )
                setEndianness( endianness or "little" )
                return @Write( writeDouble( nil, number, 8 ) )

            -- Quad
            ReadQuad: ( endianness ) =>
                setEndianness( endianness or "little" )
                return readQuad( nil, @Read( 16 ), 16 )

            WriteQuad: ( number, endianness ) =>
                argument( number, 2, "number" )
                setEndianness( endianness or "little" )
                return @Write( writeQuad( nil, number, 16 ) )

            -- Time
            ReadTime: =>
                return dos2unix( @ReadUShort!, @ReadUShort! )

            WriteTime: ( u ) =>
                t, d = unix2dos( u )
                @WriteUShort( t )
                return @WriteUShort( d )

            -- ZipFile ( https://medium.com/@felixstridsberg/the-zip-file-format-6c8a160d1c34 )
            ReadZipFile: ( doCRC ) =>
                if @Read( 4 ) ~= "PK\x03\x04"
                    return

                data = {}

                @Skip( 4 )

                compressionMethod = data.compression = @ReadUShort!
                data.time = @ReadTime!

                crc = data.crc = @ReadULong!
                compressedSize = @ReadULong!
                data.size = @ReadULong!

                pathLength = @ReadUShort!
                extraLength = @ReadUShort!

                data.path = @Read( pathLength )
                @Skip( extraLength )

                method = compressionMethods[ compressionMethod ]
                unless method
                    return data, "compression method not supported"

                content = data.content = method[ 2 ]( @Read( compressedSize ) )

                if doCRC and content and crc ~= CRC( content )
                    return data, "crc-32 mismatch"

                return data

            WriteZipFile: ( fileName, content, compressionMethod = 0, unixTime = time! ) =>
                argument( fileName, 1, "string" )
                argument( content, 2, "string" )
                argument( compressionMethod, 3, "number" )
                argument( unixTime, 4, "number" )

                -- signature
                @Write( "PK\x03\x04" )

                -- Version needed to extract (minimum)
                @WriteUShort( 0 )

                -- General purpose bit flag
                @WriteUShort( 0 )

                method = compressionMethods[ compressionMethod ]
                unless method
                    error "Unsupported compression method: " .. compressionMethod
                    return nil

                -- Compression method
                @WriteUShort( compressionMethod )

                -- Modification time
                @WriteTime( unixTime )

                -- CRC-32
                @WriteULong( tonumber( CRC( content ), 10 ) )
                fileSize = len( content )

                content = method[ 1 ]( content )

                -- Compressed size
                @WriteULong( len( content ) )

                -- Uncompressed size
                @WriteULong( fileSize )

                -- File name length
                @WriteUShort( len( fileName ) )

                -- Extra field length
                @WriteUShort( 0 )

                @Write( fileName )
                return @Write( content )

            -- Color
            ReadColor: =>
                return Color( byte( @Read( 4 ) ) )

            WriteColor: ( color ) =>
                return @Write( char( color.r, color.g, color.b, color.a ) )

            -- Date
            ReadDate: =>
                return Date.FromBinary( @Read( 12 ) )

            WriteDate: ( date ) =>
                return @Write( date\ToBinary! )

        },
        {
            CompressionMethods: compressionMethods
        },
        struct.Cursor
    )

-- Version
do

    import ByteSplit, lower from string

    do

        import URL, isurl from environment
        import Flip from table

        string.PathFromURL = ( url ) ->
            unless isurl( url )
                url = URL( url )

            if not url.hostname or url.hostname == ""
                return url.scheme .. "/" .. lower(url.pathname)

            return url.scheme .. "/" .. concat( Flip( ByteSplit( lower(url.hostname), 0x2E --[[ . ]] ) ), "/" ) .. lower(url.pathname)

    import band, bor, lshift, rshift from environment.bit
    import match, ByteCount from string
    import tostring, tonumber from _G
    import isuint, max from math
    import sort from table

    compare = ( a, b ) ->
        return a == b and 0 or a < b and -1 or 1

    compareIDs = ( value, value2 ) ->
        if value == value2
            return 0

        unless value
            return -1

        unless value2
            return 1

        number, number2 = tonumber( value ), tonumber( value2 )
        if number and number2
            return compare( number, number2 )

        if number
            return -1

        if number2
            return 1

        return compare( value, value2 )

    smallerPreRelease = ( first, second ) ->
        if not first or first == second
            return false

        unless second
            return true

        fisrt, fcount = ByteSplit( first, 0x2E --[[ . ]] )
        second, scount = ByteSplit( second, 0x2E --[[ . ]] )

        local comparison
        for index = 1, fcount
            comparison = compareIDs( fisrt[ index ], second[ index ] )
            if comparison ~= 0
                return comparison == -1

        return fcount < scount

    parsePreRelease = ( str ) ->
        if str == ""
            return nil

        preRelease = match( str, "^-(%w[%.%w-]*)$" )
        if not preRelease or match( preRelease, "%.%." )
            error "the pre-release '" .. str .. "' is not valid"
            return nil

        return preRelease

    parseBuild = ( str ) ->
        if str == ""
            return nil

        build = match( str, "^%+(%w[%.%w-]*)$" )
        if not build or match( build, "%.%." )
            error "the build '" .. str .. "' is not valid"
            return nil

        return build

    parsePreReleaseAndBuild = ( str ) =>
        if not str or str == ""
            return nil

        preRelease, build = match( str, "^(%-[^+]+)(%+.+)$" )
        unless preRelease and build
            switch byte( str, 1 )
                when 0x2d --[[ - ]]
                    preRelease = parsePrerelease( str )

                when 0x2b --[[ + ]]
                    build = parseBuild( str )

                else
                    error "the parameter '" .. str .. "' must begin with + or - to denote a pre-release or a build", 3
                    return nil

        return preRelease, build

    -- Semver lua parser. Based on https://github.com/kikito/semver.lua
    -- https://github.com/Pika-Software/gpm_legacy/blob/main/lua/gpm/sh_semver.lua
    numbersToString = ( major, minor, patch, preRelease, build ) ->
        if preRelease and build
            return major .. "." .. minor .. "." .. patch .. "-" .. preRelease .. "+" .. build

        if preRelease
            return major .. "." .. minor .. "." .. patch .. "-" .. preRelease

        if build
            return major .. "." .. minor .. "." .. patch .. "+" .. build

        return major .. "." .. minor .. "." .. patch

    parse = ( major, minor, patch, preRelease, build ) ->
        unless major
            error "at least one parameter is needed", 2
            return nil

        if isnumber( major )
            unless isuint( major )
                error "major version must be unsigned integer", 2

            if minor
                unless isnumber( minor )
                    error "minor version must be a number", 2

                unless isuint( minor )
                    error "minor version must be unsigned integer", 2

            else
                minor = 0

            if patch
                unless isnumber( patch )
                    error "patch version must be a number", 2

                unless isuint( patch )
                    error "patch version must be unsigned integer", 2

            else
                patch = 0

            if isstring( build )
                if isstring( preRelease )
                    preRelease = parsePreRelease( preRelease )

                build = parseBuild( build )
            elseif isnumber( preRelease )
                preRelease, build = parsePreReleaseAndBuild( preRelease )

        else

            major, minor, patch, extra = match( tostring( major ), "^(%d+)%.?(%d*)%.?(%d*)(.-)$" )
            unless major
                error "the major version of '#{str}' is missing", 2
                return nil

            major = tonumber( major, 10 )

            if minor == ""
                minor = "0"

            minor = tonumber( minor, 10 )

            if patch == ""
                patch = "0"

            patch = tonumber( patch, 10 )

            preRelease, build = parsePreReleaseAndBuild( extra )

        if major > 0x3ff or minor > 0x7ff or patch > 0x7ff
            error "version is too large (max 1023.2047.2047)", 2

        elseif major < 0 or minor < 0 or patch < 0
            error "version is too small (min 0.0.0)", 2

        return major, minor, patch, preRelease, build

    versions = {}

    sort_fn = ( a, b ) ->
        return a > b

    local versionClass
    versionClass = environment.class(
        "Version",
        {
            __tostring: =>
                return @__string

            new: ( major, minor, patch, preRelease, build ) =>
                major, minor, patch, preRelease, build = parse( major, minor, patch, preRelease, build )
                str = numbersToString( major, minor, patch, preRelease, build )

                version = versions[ str ]
                if version and version.major == major and version.minor == minor and version.patch == patch and version.prerelease == preRelease and version.build == build
                    return true, version

                @major, @minor, @patch, @prerelease, @build = major, minor, patch, preRelease, build
                versions[ str ] = @
                @__string = str
                return false, nil

            __eq: ( other ) =>
                return @__string == other.__string

            __lt: ( other ) =>
                if @major ~= other.major
                    return @major < other.major

                if @minor ~= other.minor
                    return @minor < other.minor

                if @patch ~= other.patch
                    return @patch < other.patch

                return smallerPreRelease( @prerelease, other.prerelease )

            __pow: ( other ) =>
                if @major == 0
                    return @ == other

                return @major == other.major and @minor <= other.minor

            -- This works like 'satisfies' (fuzzy matching) in npm.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver
            -- A version range is a set of comparators which specify versions that satisfy the range.
            -- A comparator is composed of an operator and a version. The set of primitive operators is:
            --   < Less than
            --   <= Less than or equal to
            --   > Greater than
            --   >= Greater than or equal to
            --   = Equal. If no operator is specified, then equality is assumed, so this operator
            --     is optional, but MAY be included.
            -- Comparators can be joined by whitespace to form a comparator set, which is satisfied by
            -- the intersection of all of the comparators it includes.
            -- A range is composed of one or more comparator sets, joined by ||. A version matches
            -- a range if and only if every comparator in at least one of the ||-separated comparator
            -- sets is satisfied by the version.
            -- A 'version' is described by the v2.0.0 specification found at https://semver.org/.
            -- A leading '=' or 'v' character is stripped off and ignored
            __mod: ( str ) =>
                -- version range := comparator sets
                if find( str, "||", 1, true )
                    local pos, part
                    start = 1

                    while true
                        pos = find( str, "||", start, true )
                        part = sub( str, start, pos and ( pos - 1 ) )

                        if @ % part
                            return true

                        unless pos
                            return false

                        start = pos + 2

                -- comparator set := comparators
                str = gsub( gsub( gsub( str, "%s+", " " ), "^%s+", "" ), "%s+$", "" )

                if find( str, " ", 1, true )
                    local pos, part
                    start = 1

                    while true
                        pos = find( str, " ", start, true )
                        part = sub( str, start, pos and ( pos - 1 ) )

                        -- Hyphen Ranges: X.Y.Z - A.B.C
                        -- https://docs.npmjs.com/cli/v6/using-npm/semver#hyphen-ranges-xyz---abc
                        if pos and sub( str, pos, pos + 2 ) == " - "
                            unless @ % ( ">=" .. part )
                                return false

                            start = pos + 3
                            pos = find( str, " ", start, true )
                            part = sub( str, start, pos and ( pos - 1 ) )

                            unless @ % ( "<=" .. part )
                                return false

                        elseif not ( @ % part )
                            return false

                        unless pos
                            return true

                        start = pos + 1

                    return true

                -- comparators := operator + version
                str = gsub( gsub( str, "^=", "" ), "^v", "" )

                -- X-Ranges *
                -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
                if str == "" or str == "*"
                    return @ % ">=0.0.0"

                pos = find( str, "%d" )
                unless pos
                    error "Version range must starts with number: " .. str, 2
                    return nil

                -- X-Ranges 1.2.x 1.X 1.2.*
                -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
                local operator
                if pos == 1
                    operator = "="
                else
                    operator = sub( str, 1, pos - 1 )

                version = gsub( sub( str, pos ), "%.[xX*]", "" )
                xrange = max( 2 - ByteCount( version, 0x2e --[[ . ]] ), 0 )

                for i = 1, xrange
                    version = version .. ".0"

                sv = versionClass( version )
                if operator == "<"
                    return @ < sv

                -- primitive operators
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#ranges
                if operator == "<="
                    if xrange > 0
                        if xrange == 1
                            sv = sv\nextMinor!
                        elseif xrange == 2
                            sv = sv\nextMajor!

                        return @ < sv

                    return @ <= sv

                if operator == ">"
                    if xrange > 0
                        if xrange == 1
                            sv = sv\nextMinor!
                        elseif xrange == 2
                            sv = sv\nextMajor!

                        return @ >= sv

                    return @ > sv

                if operator == ">="
                    return @ >= sv

                if operator == "="
                    if xrange > 0
                        if @ < sv
                            return false

                        if xrange == 1
                            sv = sv\nextMinor!
                        elseif xrange == 2
                            sv = sv\nextMajor!

                        return @ < sv

                    return @ == sv

                -- Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4
                -- Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple.
                -- In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for
                -- versions 0.X >=0.1.0, and no updates for versions 0.0.X.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#caret-ranges-123-025-004
                if operator == "^"
                    if sv.major == 0 and xrange < 2
                        if sv.minor == 0 and xrange < 1
                            return @major == 0 and @minor == 0 and @ >= sv and @ < sv\nextPatch!

                        return @major == 0 and @ >= sv and @ < sv\nextMinor!

                    return @major == sv.major and @ >= sv and @ < sv\nextMajor!

                -- Tilde Ranges ~1.2.3 ~1.2 ~1
                -- Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#tilde-ranges-123-12-1
                if operator == "~"
                    if @ < sv
                        return false

                    if xrange == 2
                        return @ < sv\nextMajor!

                    return @ < sv\nextMinor!

                error "Invaild operator: '" .. operator .. "'", 2
                return nil

            nextMajor: =>
                return versionClass( @major + 1, 0, 0 )

            nextMinor: =>
                return versionClass( @major, @minor + 1, 0 )

            nextPatch: =>
                return versionClass( @major, @minor, @patch + 1 )

            toNumber: =>
                major = tonumber( @major )
                if major > 0x3ff
                    error "major version is too large (max 1023)", 2
                    return nil

                minor = tonumber( @minor )
                if minor > 0x7ff
                    error "minor version is too large (max 2047)", 2
                    return nil

                patch = tonumber( @patch )
                if patch > 0x7ff
                    error "patch version is too large (max 2047)", 2
                    return nil

                return bor( lshift( patch, 21 ), lshift( minor, 10 ), major )
        },
        {
            :parse
            tostring: ( ... ) ->
                return numbersToString( parse( ... ) )

            fromNumber: ( uint ) ->
                return versionClass( band( uint, 0x3ff ), band( rshift( uint, 10 ), 0x7ff ), band( rshift( uint, 21 ), 0x7ff ) )

            select: ( target, versions ) ->
                sort( versions, sort_fn )

                for index = 1, #versions
                    version = versionClass( versions[ index ] )
                    if version % target
                        return version, index

                return nil, -1
        }
    )

    util.Version = versionClass

do

    import GetValue, SetValue from table
    import Create, Remove from environment.timer
    import serialize, deserialize from environment.yaml
    import IsFile, AsyncWrite, Read, Write from environment.file

    environment.Config = environment.class( "Config", {
        new: ( name, defaults, @config_type = "yaml" ) =>
            argument( name, 1, "string" )
            @name = name

            filePath = "/data/config/" .. name .. ".txt"
            @timer = "GPM::Config - " .. name
            @filepath = filePath

            if IsFile( filePath )
                @data = @Deserialize( Read( filePath ) )

            elseif defaults
                argument( defaults, 2, "table" )
                @data = defaults
                Write( filePath, @Serialize! )

            else
                @data = {}

            return nil

        GetAll: =>
            return @data

        Get: ( key ) =>
            return GetValue( @data, key )

        Set: ( key, value ) =>
            argument( key, 1, "string" )
            SetValue( @data, key, value )
            Create @timer, 1, 1, ->
                @Write!

            return nil

        Write: =>
            AsyncWrite( @filepath, @Serialize! )
            Remove( @timer )
            return nil

        Read: =>
            @data = @Deserialize( Read( @filepath ) )
            return nil

        Serialize: =>
            if @config_type == "yaml"
                return serialize( @data )

            return TableToJSON( @data, true )

        Deserialize: ( str ) =>
            if @config_type == "yaml"
                return deserialize( str )

            return JSONToTable( str, true, true )

    } )

--[[

    Standard SQL library

--]]

if _G.sql

    import SQLError, throw from environment
    import sql, pairs, xpcall from _G
    import SQLSafe from string
    import Query from sql
    lib = environment.sql

    -- truncate WAL journal on shutdown
    _G.hook.Add "ShutDown", "GLua Package Manager::SQLite", ->
        if Query( "pragma wal_checkpoint(TRUNCATE)" ) == false
            Logger\Error( "Failed to truncate WAL journal: %s", sql.m_strError )

        return nil

    lib.LastError = ->
        return sql.m_strError

    escape = lib.Escape = ( str ) ->
        return str == nil and "null" or SQLSafe( str )

    queryString = lib.QueryString = ( str ) ->
        Logger\Debug( "Executing SQL query: " .. str )

        result = Query( str )
        if result == false
            throw SQLError sql.m_strError, nil, nil, 4

        return result

    -- optimize sqlite database
    unless sql.__optimized
        pragma_values = queryString( "pragma foreign_keys; pragma journal_mode; pragma synchronous; pragma wal_autocheckpoint" )
        if pragma_values[ 1 ].foreign_keys == "0"
            queryString( "pragma foreign_keys = 1" )

        if pragma_values[ 2 ].journal_mode == "delete"
            queryString( "pragma journal_mode = wal" )

        if pragma_values[ 3 ].synchronous == "0"
            queryString( "pragma synchronous = normal" )

        if pragma_values[ 4 ].wal_autocheckpoint == "1000"
            queryString( "pragma wal_autocheckpoint = 100" )

        sql.__optimized = true

    tableExists = lib.TableExists = ( name ) ->
        return queryString( "select name from sqlite_master where name=" .. escape( name ) .. " and type='table'" ) and true or false

    lib.IndexExists = ( name ) ->
        return queryString( "select name from sqlite_master where name=" .. escape( name ) .. " and type='index'" ) and true or false

    lib.Begin = ->
        queryString( "begin" )
        return nil

    lib.Commit = ->
        queryString( "commit" )
        return nil

    lib.Rollback = ->
        queryString( "rollback" )
        return nil

    query = lib.Query = ( str, ... ) ->
        args, index = { ... }, 0
        str = gsub str, "?", ->
            index += 1
            return escape( args[ index ] )

        result = queryString( str )

        -- convert NULL values into nil
        if result
            for tbl in *result
                for key, value in pairs( tbl )
                    if value == "NULL"
                        tbl[ key ] = nil

        return result

    queryRow = lib.QueryRow = ( str, row = 1, ... ) ->
        if result := query( str, ... )
            return result[ row ]

        return nil

    queryOne = lib.QueryOne = ( str, ... ) ->
        return queryRow( str, 1, ... )

    lib.QueryValue = ( str, ... ) ->
        if result := queryOne( str, ... )
            return next( result )

        return nil

    transaction = lib.Transaction = ( func ) ->
        queryString( "begin" )

        ok, result = pcall( func )
        if ok
            queryString( "commit" )
            return result

        queryString( "rollback" )
        throw result
        return nil

    gpm_sql = gpm.sql
    unless istable( gpm_sql )
        gpm_sql = gpm.sql = {}

    --[[

        Libraries

    --]]

    -- http_cache table, used for etag caching in http library
    do

        http_cache = gpm_sql.http_cache = {}

        http_cache.get = ( url ) ->
            argument( url, 1, "string" )

            result = query( "select etag, content from 'gpm.http_cache' where url=? limit 1", url )
            return result and result[ 1 ]

        MAX_SIZE = http_cache.MAX_SIZE = 50 * 1024

        http_cache.set = ( url, etag, content ) ->
            argument( url, 1, "string" )
            argument( etag, 2, "string" )
            argument( content, 3, "string" )

            if len( content ) > MAX_SIZE -- 50KB
                -- do not cache content that are larger than 50KB
                return nil

            if find( content, "\x00", 1, true )
                -- we are unable to store null bytes in sqlite
                return nil

            query( "insert or replace into 'gpm.http_cache' (url, etag, timestamp, content) values (?, ?, ?, ?)", url, etag, time!, content )
            return nil

    -- key-value store for gpm
    do

        store = gpm_sql.store = {}

        store.set = ( key, value ) ->
            argument( key, 1, "string" )
            query( "insert or replace into 'gpm.store' values (?, ?)", key, value )
            return nil

        store.get = ( key ) ->
            argument( key, 1, "string" )
            result = query( "select value from 'gpm.store' where key=?", key )
            return result and result[ 1 ].value

    --- repositories
    if SERVER

        repositories = gpm_sql.repositories = {}

        repositories.getRepositories = ->
            return query( "select * from 'gpm.repositories'" ) or {}

        repositories.addRepository = ( url ) ->
            argument( url, 1, "string" )
            return queryOne( "insert or ignore into 'gpm.repositories' (url) values (?); select * from 'gpm.repositories' where url=?", url, url )

        do

            url_str = ""

            transactionFunc = ->
                repository = queryOne( "select id from 'gpm.repositories' where url=?", url_str )
                unless repository
                    return nil

                repositoryId = repository.id

                -- delete all versions, packages and repository
                for package in *query( "select id from 'gpm.packages' where repositoryId=?", repositoryId )
                    packageId = package.id
                    query( "delete from 'gpm.package_versions' where packageId=?; delete from 'gpm.packages' where id=?", packageId, packageId )

                query( "delete from 'gpm.repositories' where id=?", repositoryId )
                return nil

            repositories.removeRepository = ( url ) ->
                argument( url, 1, "string" )
                url_str = url

                transaction( transactionFunc )
                url_str = nil
                return nil

        getRepositoryId = ( repository ) ->
            if isnumber( repository )
                return repository

            if istable( repository )
                return repository.id or repository.url

            if isstring( repository )
                result = queryOne( "select id from 'gpm.repositories' where url=?", repository )
                return result and result.id or nil

            return nil

        repositories.getPackage = ( repository, name ) ->
            argument( name, 2, "string" )

            repositoryId = getRepositoryId( repository )
            unless repositoryId
                throw SQLError "invalid repository '#{repository}' was given as #1 argument"

            if pkg := queryOne( "select * from 'gpm.packages' where name=? and repositoryId=?", name, repositoryId )
                pkg.versions = query( "select version, metadata from 'gpm.package_versions' where packageId=?", pkg.id )
                return pkg

            return nil

        repositories.getPackages = ( repository ) ->
            repositoryId = getRepositoryId( repository )
            unless repositoryId
                throw SQLError "invalid repository '#{repository}' was given as #1 argument"

            packages = query( "select * from 'gpm.packages' where repositoryId=?", repositoryId )
            unless packages
                return {}

            for index = 1, #packages, 1
                pkg = packages[ index ]
                pkg.versions = query( "select version, metadata from 'gpm.package_versions' where packageId=?", pkg.id )

            return packages

        do

            local pkgs, old_pkgs, repositoryId

            transactionFunc = ->
                hasOldPkgs = old_pkgs ~= nil

                for name, pkg in pairs( pkgs )
                    query( "insert or replace into 'gpm.packages' (name, url, type, repositoryId) values (?, ?, ?, ?)", pkg.name, pkg.url, pkg.type, repositoryId )

                    package = queryOne( "select id from 'gpm.packages' where name=? and repositoryId=?", pkg.name, repositoryId )
                    if package
                        packageId = package.id

                        query( "delete from 'gpm.package_versions' where packageId=?", packageId )

                        for tbl in *pkg.versions
                            query( "insert into 'gpm.package_versions' (version, metadata, packageId) values (?, ?, ?)", tbl.version, tbl.metadata, packageId )

                    if hasOldPkgs
                        old_pkgs[ name ] = nil

                -- remove old packages
                if hasOldPkgs
                    for name, id in pairs( old_pkgs )
                        query( "delete from 'gpm.package_versions' where packageId=?; delete from 'gpm.packages' where id=?", id, id )

                return nil

            repositories.updateRepository = ( repository, packages ) ->
                argument( packages, 2, "table" )

                repositoryId = getRepositoryId( repository )
                unless repositoryId
                    throw SQLError "invalid repository '#{repository}' was given as #1 argument"

                oldPackages = query( "select id, name from 'gpm.packages' where repositoryId=?", repositoryId )
                if oldPackages
                    oldPackages = { pkg.name, pkg.id for pkg in *oldPackages }

                pkgs, old_pkgs = packages, oldPackages
                transaction( transactionFunc )
                pkgs, old_pkgs = nil, nil
                repositoryId = nil
                return nil

    --[[

        Migrations

    --]]

    migrations = [
        {
            name: "initial"
            execute: -> -- deprecated
        }
        {
            name: "http_cache add primary key"
            execute: ->
                queryString( "drop table if exists 'gpm.http_cache'" )
                queryString( [[create table 'gpm.http_cache' (
                    url text primary key,
                    etag text,
                    timestamp int,
                    content blob
                )]] )

                return nil
        }
        {
            name: "added key-value store"
            execute: ->
                queryString( "create table 'gpm.store' ( key text unique, value text )" )
                return nil
        }
        {
            name: "initial repositories and packages"
            execute: ->
                queryString( "drop table if exists 'gpm.table_version'" )
                queryString( "drop table if exists 'gpm.repository'" )
                queryString( "drop table if exists 'gpm.packages'" )

                if SERVER
                    queryString( "create table 'gpm.repositories' ( id integer primary key autoincrement, url text unique not null )" )

                    queryString( [[
                        create table 'gpm.packages' (
                            id integer primary key autoincrement,
                            name text not null,
                            url text not null,
                            type int not null,
                            repositoryId integer,

                            foreign key(repositoryId) references 'gpm.repositories' (id)
                            unique(name, repositoryId) on conflict replace
                        )
                    ]] )

                    queryString( [[
                        create table 'gpm.package_versions' (
                            version text not null,
                            metadata text,
                            packageId integer not null,

                            foreign key(packageId) references 'gpm.packages' (id)
                            unique(version, packageId) on conflict replace
                        )
                    ]] )

                return nil
        }
    ]

    gpm_sql.migrations = migrations

    unless tableExists( "gpm.migration_history" )
        queryString( "create table 'gpm.migration_history' (name text, timestamp integer)" )

    migrationExists = gpm_sql.migrationExists = ( name ) ->
        for migration in *migrations
            if migration.name == name
                return true

        return false

    local runMigration
    do

        :display = SQLError

        runMigration = gpm_sql.runMigration = ( migration ) ->
            unless isfunction( migration.execute )
                throw SQLError "Migration '#{migration.name}' does not have an execute function"

            Logger\Info( "Running migration '#{migration.name}'..." )

            queryString( "begin" ) -- begin transaction so we can rollback if something goes wrong

            ok = xpcall( migration.execute, display )
            if ok
                query( "insert into 'gpm.migration_history' (name, timestamp) values (?, ?)", migration.name, time! )
                queryString( "commit" )
            else
                queryString( "rollback" )

            return ok

    gpm_sql.migrate = ( name ) ->
        unless isstring( name )
            throw SQLError "Migration name must be a string, not #{name}"

        history = queryString( "select name from 'gpm.migration_history'" ) or {}
        for migration in *history
            history[ migration.name ] = true

        -- find if given migration name exists
        unless migrationExists( name )
            throw SQLError "Migration '" .. name .. "' not found"

        -- first execute migrations
        for migration in *migrations
            unless history[ migration.name ]
                if runMigration( migration ) == false
                    break

            if migration.name == name -- this is our last migration
                break
