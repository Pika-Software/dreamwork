_G = _G
import gpm, SERVER from _G
import environment, Logger from gpm
import istable, pcall, require, tonumber, tostring from _G
import math, string, table, os, util, argument, isstring, isnumber, isfunction, throw, type from environment
import byte, sub, gsub, len, find, format, match from string
import Create, Remove, Simple from environment.timer
import CRC, IsBinaryModuleInstalled from util
newClass = environment.class
import concat from table
import time from os

do

    import CodeCompileError from environment

    installed, filePath = IsBinaryModuleInstalled( "moonloader" )
    if installed
        ok, msg = pcall( require, "moonloader" )
        if ok and istable( moonloader )
            Logger\Info( "gm_moonloader v%s loaded.", moonloader._VERSION )
            installed = true
        else
            Logger\Error( "gm_moonloader startup error: %s", msg or "unknown error" )
            installed = false

    yueFail = ->
        throw CodeCompileError "Attempt to compile Yuescript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader."

    if installed
        moonloader = environment.moon = _G.moonloader

        -- Yuescript
        import yue from moonloader

        if istable( yue )
            environment.yue = yue
        else

            environment.yue = {
                ToLua: yueFail
            }

            Logger\Warn( "Yuescript support is missing, yuescript code compilation is unavailable." )

    else

        moonFail = ->
            throw CodeCompileError "Attempt to compile MoonScript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader."

        environment.moon = {
            PreCacheFile: moonFail,
            PreCacheDir: moonFail,
            ToLua: moonFail
        }

        environment.yue = {
            ToLua: yueFail
        }

        Logger\Warn( "Binary module '" .. filePath .. "' is missing, support for moon and yue scripts is unavailable." )

-- https://github.com/WilliamVenner/gmsv_workshop
if SERVER and not ( istable( steamworks ) and isfunction( steamworks.DownloadUGC ) )
    installed, filePath = IsBinaryModuleInstalled( "workshop" )
    if installed
        unless pcall( require, "workshop" )
            Logger\Error( "Binary module '" .. filePath .. "' was corrupted!" )
    else
        Logger\Warn( "Binary module '" .. filePath .. "' is missing, Steam workshop downloads is unavailable." )

do

    local byteCodeSupported
    if SERVER
        -- https://github.com/willox/gmbc
        byteCodeSupported, filePath = IsBinaryModuleInstalled( "gmbc" )
        if byteCodeSupported
            byteCodeSupported = pcall( require, "gmbc" )
        else
            Logger\Warn( "Binary module '" .. filePath .. "' is missing, bytecode compilation is unavailable." )
    else
        byteCodeSupported = false

    import CompileString, gmbc_load_bytecode, setfenv from _G
    import yue, moon from environment
    import IsBytecode from string

    environment.loadstring = ( code, identifier, handleError = true, ignoreBytecode ) ->
        if not ignoreBytecode and IsBytecode( code )
            if byteCodeSupported
                return gmbc_load_bytecode( code )

            msg = "Bytecode compilation is not supported. Please install gmbc (https://github.com/willox/gmbc)"
            if handleError
                throw msg, 2
                return nil

            return msg

        return CompileString( code, identifier, handleError )

    load = ( chunk, chunkName, mode = "bt", env = getfenv( 2 ), config, handleError = true ) ->
        argument( chunkName, 2, "string" )

        switch type( chunk )
            when "string"
                modes = {}
                for byte0 in *{ byte( mode, 1, len( mode ) ) }
                    modes[ byte0 ] = true

                local func
                if modes[ 0x62 --[[ b ]] ] and IsBytecode( chunk )
                    if byteCodeSupported
                        func = gmbc_load_bytecode( chunk )

                    msg = "Bytecode compilation is not supported."
                    if handleError
                        throw msg, 2
                        return nil

                    return msg

                if modes[ 0x79 --[[ y ]] ]
                    if config
                        argument( config, 5, "table" )
                        chunk = yue.ToLua( chunk, config )
                    else
                        chunk = yue.ToLua( chunk )

                elseif modes[ 0x6D --[[ m ]] ]
                    chunk = moon.ToLua( chunk )

                if modes[ 0x74 --[[ t ]] ]
                    func = CompileString( chunk, chunkName, handleError )

                if func
                    if isfunction( func ) and env
                        setfenv( func, env )

                    return func

                msg = "wrong load mode"
                if handleError
                    throw msg, 2
                    return nil

                return msg

            when "function"
                result, length = {}, 0

                str = chunk!
                while str
                    length += 1
                    result[ length ] = str
                    str = chunk!

                if length == 0
                    return ->

                return load( concat( result, "", 1, length ), chunkName, mode, env, config, handleError )

        throw "Invalid argument #1 to 'load' (string/function expected)", 2
        return nil

    environment.load = load

do

    import BInt, IsBInt from environment
    import FromBytes, ToBytes, ToNumber, CastSigned from BInt

    do

        import IsSteamID from string
        import ToDec from BInt
        import fdiv from math

        base = BInt( "76561197960265728" )

        unless util.SteamIDTo64
            util.SteamIDTo64 = ( sid ) ->
                y, z = match( sid, "^STEAM_[0-5]:([01]):(%d+)$" )

                sid64 = tonumber( z, 10 ) * 2
                if y == "1"
                    sid64 += 1

                return ToDec( base + sid64 )

        unless util.SteamIDFrom64
            zero = BInt.Zero
            two = BInt.Two

            util.SteamIDFrom64 = ( sid ) ->
                y = BInt( sid ) - base
                return "STEAM_0:" .. ( ( y % two == zero ) and "0" or "1" ) .. ":" .. ToDec( y / two )

        import SteamIDTo64, SteamIDFrom64 from util

        metatable = {
            __tostring: =>
                return @steamid

            __eq: ( other ) =>
                return @steamid == tostring( other )

            new: ( str ) =>
                argument( str, 1, "string" )

                if IsSteamID( str )
                    @steamid = str
                else
                    str = SteamIDFrom64( str )
                    if str and byte( str, 11 ) ~= 0x2D --[[ - ]]
                        @steamid = str
                    else
                        throw "Invalid SteamID64", 3

                return false, nil

            ToXYZ: =>
                return match( @steamid, "^STEAM_([0-5]):([01]):(%d+)$" )

            ToIntegers: =>
                x, y, z = @ToXYZ!
                return tonumber( x, 10 ), tonumber( y, 10 ), tonumber( z, 10 )

            ToSteamID: =>
                return @steamid

            ToSteamID64: =>
                return SteamIDTo64( @steamid )

            ToAccountID: =>
                y, z = match( @steamid, "^STEAM_[0-5]:([01]):(%d+)$" )
                return ( tonumber( z, 10 ) * 2 ) + tonumber( y, 10 )

            ToHex: =>
                return format("0x%x", @ToAccountID! )

            ToSteamID3: =>
                return format( "[U:1:%d]", @ToAccountID! )

            ToBinary: ( bigEndian ) =>
                return ToBytes( BInt( SteamIDTo64( @steamid ) ), bigEndian ~= true )

            GetUniverse: =>
                return tonumber( match( @steamid, "^STEAM_([0-5]):[01]:%d+$" ) or 0, 10 )

            SetUniverse: ( universe ) =>
                argument( universe, 1, "number" )
                if universe < 0 or universe > 5
                    throw( "Invalid SteamID universe", 2 )

                @steamid = "STEAM_" .. universe .. match( @steamid, "^STEAM_[0-5](:[01]:%d+)$" )
                return @

        }

        environment.SteamID = newClass( "SteamID", metatable, {
            IsValid: ( steamid ) ->
                argument( steamid, 1, "string" )
                return IsSteamID( steamid )

            FromSteamID: ( steamid ) ->
                argument( steamid, 1, "string" )

                unless IsSteamID( steamid )
                    throw( "Invalid SteamID", 2 )

                return setmetatable( { :steamid }, metatable )

            FromSteamID64: ( steamid64 ) ->
                steamid = SteamIDFrom64( tostring( steamid64 ) )
                if not steamid or byte( str, 11 ) == 0x2D --[[ - ]]
                    throw( "Invalid SteamID64", 2 )

                return setmetatable( { :steamid }, metatable )

            FromSteamID3: ( sid3 ) ->
                z = tonumber( match( sid3, "^%[U:%d:(%d+)%]$" ) or -1, 10 )
                if z < 0
                    throw( "Invalid SteamID3", 2 )

                return setmetatable( {
                    steamid: format( "STEAM_0:%s:%d", ( z % 2 == 0 ) and "0" or "1", z / 2 )
                }, metatable )

            FromBinary: ( binary, bigEndian ) ->
                argument( binary, 1, "string" )
                return setmetatable( {
                    steamid: SteamIDFrom64( ToDec( FromBytes( binary, bigEndian ~= true ) ) )
                }, metatable )

            FromHex: ( hex ) ->
                unless isnumber( hex )
                    hex = tonumber( hex, 16 )

                argument( hex, 1, "number" )

                if hex < 0
                    throw( "Invalid hex", 2 )

                return setmetatable( {
                    steamid: format( "STEAM_0:%s:%d", ( hex % 2 == 0 ) and "0" or "1", fdiv( hex, 2 ) )
                }, metatable )

            FromAccountID: ( accountid ) ->
                argument( accountid, 1, "number" )

                return setmetatable( {
                    steamid: format( "STEAM_0:%s:%d", ( accountid % 2 == 0 ) and "0" or "1", fdiv( accountid, 2 ) )
                }, metatable )
        } )

    import struct from environment
    import io from struct

    -- lua 5.3 string features
    do

        import Read, Write from struct
        import unpack from table

        string.pack = ( fmt, ... ) ->
            return Write( fmt, { ... } )

        string.unpack = ( fmt, binary, offset ) ->
            if offset
                return unpack( Read( fmt, sub( binary, offset, len( binary ) ) ) )

            return unpack( Read( fmt, binary ) )

        string.packsize = struct.SizeOf

    -- Byte Stream
    import deflate, Color from environment
    import unix2dos, dos2unix from os
    import char, reverse from string
    import clamp from math
    import Date from util

    local readInt, writeInt
    do
        int = io.i
        readInt, writeInt = int.Read, int.Write

    local readUInt, writeUInt
    do
        uint = io.I
        readUInt, writeUInt = uint.Read, uint.Write

    local readFloat, writeFloat
    do
        float = io.f
        readFloat, writeFloat = float.Read, float.Write

    local readDouble, writeDouble
    do
        double = io.d
        readDouble, writeDouble = double.Read, double.Write

    local readQuad, writeQuad
    do
        quad = io.q
        readQuad, writeQuad = quad.Read, quad.Write

    local setEndianness
    do

        import Little, Set from io.endianness
        import Read from io.i

        util.LZMA_PROPS_SIZE = 5

        util.CompressedSize = ( binary ) ->
            if binary == ""
                return 0

            Little!
            return Read( nil, sub( binary, 6, 14 ), 8 )

        setEndianness = ( isBigEndian ) ->
            if isBigEndian
                Set( "big" )
                return true

            Set( "little" )
            return false

    noCompression = ( content ) ->
        return content

    compressionMethods = {
        -- No compression
        [ 0 ]: {
            [1]: noCompression,
            [2]: noCompression
        },

        -- Deflate
        [ 8 ]: {
            [1]: deflate.CompressDeflate,
            [2]: deflate.DecompressDeflate
        }
    }

    seek = ( position ) =>
        @Flush!

        if position
            argument( position, 2, "number" )
            position = clamp( position, 0, @size )
        else
            position = 0

        @position = position
        return position

    util.ByteStream = newClass(
        "ByteStream",
        {
            __tostring: =>
                return format( "ByteStream: %p [%d/%d]", @, @position, @size )

            IsValid: =>
                return @data ~= nil

            EndOfFile: =>
                return @position >= @size

            Size: =>
                return @size

            Tell: =>
                return @position

            Close: =>
                @Flush!
                @position = 0

            Seek: seek
            SeekTo: seek

            SeekToBegin: =>
                return @Seek( 0 )

            SeekToEnd: =>
                return @Seek( @size - @position )

            SkipEmpty: =>
                while not @EndOfFile!
                    if @ReadByte! ~= 0
                        @Skip( -1 )
                        break

            Skip: ( bytes ) =>
                if bytes
                    argument( bytes, 2, "number" )
                else
                    bytes = 1

                return @Seek( @position + bytes )

            -- Byte read
            Read: ( bytes ) =>
                :position, :size = @

                if bytes == "*a" or bytes == nil
                    bytes = size

                argument( bytes, 2, "number" )

                if bytes > 0
                    if position >= size
                        return nil, "eof"

                    return sub( @data, position + 1, @Skip( bytes ) )

                if bytes < 0
                    if position <= 0
                        return nil, "sof"

                    return reverse( sub( @data, position + 1, @Skip( bytes ) ) )

            ReadAll: =>
                @SeekToBegin!
                return @Read( @size )

            -- String
            ReadString: =>
                :position, :size = @
                if position >= size
                    return nil, "eof"

                bytes, data = 0, @data
                for index = position, size
                    if byte( data, index + 1 ) == 0
                        break

                    bytes += 1

                if bytes == 0
                    @Skip( 1 )
                    return nil

                str = @Read( bytes )
                @Skip( 1 )
                return str

            WriteString: ( str ) =>
                argument( str, 1, "string" )
                return @Write( str .. "\0" )

            -- Line
            ReadLine: =>
                :position, :size = @
                if position >= size
                    return nil, "eof"

                bytes, data = 0, @data
                for index = position, size
                    if byte( data, index + 1 ) == 0xA --[[ \n ]]
                        break

                    bytes += 1

                if bytes == 0
                    @Skip( 1 )
                    return nil

                line = @Read( bytes )
                @Skip( 1 )
                return line

            WriteLine: ( str ) =>
                argument( str, 1, "string" )
                return @Write( str .. "\n" )

            -- Byte
            ReadByte: =>
                if @EndOfFile!
                    return nil, "eof"

                return byte( @data, @Skip( 1 ) )

            WriteByte: ( number ) =>
                return @Write( char( number ) )

            -- Boolean
            ReadBool: =>
                switch @ReadByte!
                    when 0
                        return false

                    when 1
                        return true

                return nil, "eof"

            WriteBool: ( bool ) =>
                return @WriteByte( bool and 1 or 0 )

            -- UInt
            ReadUInt: ( bytes, isBigEndian ) =>
                argument( bytes, 2, "number", 4 )
                setEndianness( isBigEndian )
                return readUInt( nil, @Read( bytes ), bytes )

            WriteUInt: ( number, bytes, isBigEndian ) =>
                argument( number, 1, "number", 4 )
                argument( bytes, 2, "number", 4 )
                setEndianness( isBigEndian )
                return @Write( writeUInt( nil, number, bytes ) )

            -- UShort
            ReadUShort: ( isBigEndian ) =>
                return @ReadUInt( 2, isBigEndian )

            WriteUShort: ( number, isBigEndian ) =>
                return @WriteUInt( number, 2, isBigEndian )

            -- ULong
            ReadULong: ( isBigEndian ) =>
                return @ReadUInt( 4, isBigEndian )

            WriteULong: ( number, isBigEndian ) =>
                return @WriteUInt( number, 4, isBigEndian )

            -- UInt64
            ReadUInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readUInt( nil, sub( binary, 3 ), 6 )

                    return FromBytes( binary, false )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readUInt( nil, binary, 6 )

                return FromBytes( binary, true )

            WriteUInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( ToBytes( number, 8, false ) )

                    return @Write( ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @Write( "\0\0" )

                    if isBint
                        return @Write( writeUInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeUInt( nil, number, 6 ) )

                if isBint
                    @Write( writeUInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeUInt( nil, number, 6 ) )

                return @Write( "\0\0" )

            -- Int
            ReadInt: ( bytes, isBigEndian ) =>
                argument( bytes, 2, "number", 4 )
                setEndianness( isBigEndian )
                return readInt( nil, @Read( bytes ), bytes )

            WriteInt: ( number, bytes, isBigEndian ) =>
                argument( number, 1, "number", 4 )
                argument( bytes, 2, "number", 4 )
                setEndianness( isBigEndian )
                return @Write( writeInt( nil, number, bytes ) )

            -- Short
            ReadShort: ( isBigEndian ) =>
                return @ReadInt( 2, isBigEndian )

            WriteShort: ( number, isBigEndian ) =>
                return @WriteInt( number, 2, isBigEndian )

            -- Long
            ReadLong: ( isBigEndian ) =>
                return @ReadInt( 4, isBigEndian )

            WriteLong: ( number, isBigEndian ) =>
                return @WriteInt( number, 4, isBigEndian )

            -- Int64
            ReadInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readInt( nil, sub( binary, 3 ), 6 )

                    return CastSigned( FromBytes( binary, false ), 8 )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readInt( nil, binary, 6 )

                return CastSigned( FromBytes( binary, true ), 8 )

            WriteInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( ToBytes( number, 8, false ) )

                    return @Write( ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @Write( "\0\0" )

                    if isBint
                        return @Write( writeInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeInt( nil, number, 6 ) )

                if isBint
                    @Write( writeInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeInt( nil, number, 6 ) )

                return @Write( "\0\0" )

            -- Float
            ReadFloat: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readFloat( nil, @Read( 4 ), 4 )

            WriteFloat: ( number, isBigEndian ) =>
                argument( number, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeFloat( nil, number, 4 ) )

            -- Double
            ReadDouble: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readDouble( nil, @Read( 8 ), 8 )

            WriteDouble: ( number, isBigEndian ) =>
                argument( number, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeDouble( nil, number, 8 ) )

            -- Quad
            ReadQuad: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readQuad( nil, @Read( 16 ), 16 )

            WriteQuad: ( number, isBigEndian ) =>
                argument( number, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeQuad( nil, number, 16 ) )

            -- Time
            ReadTime: =>
                return dos2unix( @ReadUShort!, @ReadUShort! )

            WriteTime: ( u ) =>
                t, d = unix2dos( u )
                @WriteUShort( t )
                return @WriteUShort( d )

            -- ZipFile ( https://medium.com/@felixstridsberg/the-zip-file-format-6c8a160d1c34 )
            ReadZipFile: ( doCRC ) =>
                if @Read( 4 ) ~= "PK\x03\x04"
                    return

                data = {}

                @Skip( 4 )

                compressionMethod = data.compression = @ReadUShort!
                data.time = @ReadTime!

                crc = data.crc = @ReadULong!
                compressedSize = @ReadULong!
                data.size = @ReadULong!

                pathLength = @ReadUShort!
                extraLength = @ReadUShort!

                data.path = @Read( pathLength )
                @Skip( extraLength )

                method = compressionMethods[ compressionMethod ]
                unless method
                    return data, "compression method not supported"

                content = data.content = method[ 2 ]( @Read( compressedSize ) )

                if doCRC and content and crc ~= CRC( content )
                    return data, "crc-32 mismatch"

                return data

            WriteZipFile: ( fileName, content, compressionMethod = 0, unixTime = time! ) =>
                argument( fileName, 1, "string" )
                argument( content, 2, "string" )
                argument( compressionMethod, 3, "number" )
                argument( unixTime, 4, "number" )

                -- signature
                @Write( "PK\x03\x04" )

                -- Version needed to extract (minimum)
                @WriteUShort( 0 )

                -- General purpose bit flag
                @WriteUShort( 0 )

                method = compressionMethods[ compressionMethod ]
                unless method
                    throw "Unsupported compression method: " .. compressionMethod
                    return nil

                -- Compression method
                @WriteUShort( compressionMethod )

                -- Modification time
                @WriteTime( unixTime )

                -- CRC-32
                @WriteULong( tonumber( CRC( content ), 10 ) )
                fileSize = len( content )

                content = method[ 1 ]( content )

                -- Compressed size
                @WriteULong( len( content ) )

                -- Uncompressed size
                @WriteULong( fileSize )

                -- File name length
                @WriteUShort( len( fileName ) )

                -- Extra field length
                @WriteUShort( 0 )

                @Write( fileName )
                return @Write( content )

            -- Color
            ReadColor: =>
                return Color( byte( @Read( 4 ) ) )

            WriteColor: ( color ) =>
                return @Write( char( color.r, color.g, color.b, color.a ) )

            -- Date
            ReadDate: =>
                return Date.FromBinary( @Read( 12 ) )

            WriteDate: ( date ) =>
                return @Write( date\ToBinary! )

        },
        {
            CompressionMethods: compressionMethods
        },
        struct.Cursor
    )

-- Version
do

    import ByteSplit, lower from string

    do

        import URL, isurl from environment
        import Flip from table

        string.PathFromURL = ( url ) ->
            unless isurl( url )
                url = URL( url )

            if not url.hostname or url.hostname == ""
                return url.scheme .. "/" .. lower(url.pathname)

            return url.scheme .. "/" .. concat( Flip( ByteSplit( lower(url.hostname), 0x2E --[[ . ]] ) ), "/" ) .. lower(url.pathname)

    import band, bor, lshift, rshift from environment.bit
    import isuint, max from math
    import ByteCount from string
    import sort from table

    compare = ( a, b ) ->
        return a == b and 0 or a < b and -1 or 1

    compareIDs = ( value, value2 ) ->
        if value == value2
            return 0

        unless value
            return -1

        unless value2
            return 1

        number, number2 = tonumber( value, 10 ), tonumber( value2, 10 )
        if number and number2
            return compare( number, number2 )

        if number
            return -1

        if number2
            return 1

        return compare( value, value2 )

    smallerPreRelease = ( first, second ) ->
        if not first or first == second
            return false

        unless second
            return true

        fisrt, fcount = ByteSplit( first, 0x2E --[[ . ]] )
        second, scount = ByteSplit( second, 0x2E --[[ . ]] )

        local comparison
        for index = 1, fcount
            comparison = compareIDs( fisrt[ index ], second[ index ] )
            if comparison ~= 0
                return comparison == -1

        return fcount < scount

    parsePreRelease = ( str ) ->
        if str == ""
            return nil

        preRelease = match( str, "^-(%w[%.%w-]*)$" )
        if not preRelease or match( preRelease, "%.%." )
            throw "the pre-release '" .. str .. "' is not valid"
            return nil

        return preRelease

    parseBuild = ( str ) ->
        if str == ""
            return nil

        build = match( str, "^%+(%w[%.%w-]*)$" )
        if not build or match( build, "%.%." )
            throw "the build '" .. str .. "' is not valid"
            return nil

        return build

    parsePreReleaseAndBuild = ( str ) =>
        if not str or str == ""
            return nil

        preRelease, build = match( str, "^(%-[^+]+)(%+.+)$" )
        unless preRelease and build
            switch byte( str, 1 )
                when 0x2d --[[ - ]]
                    preRelease = parsePrerelease( str )

                when 0x2b --[[ + ]]
                    build = parseBuild( str )

                else
                    throw "the parameter '" .. str .. "' must begin with + or - to denote a pre-release or a build", 3
                    return nil

        return preRelease, build

    -- Semver lua parser. Based on https://github.com/kikito/semver.lua
    -- https://github.com/Pika-Software/gpm_legacy/blob/main/lua/gpm/sh_semver.lua
    numbersToString = ( major, minor, patch, preRelease, build ) ->
        if preRelease and build
            return major .. "." .. minor .. "." .. patch .. "-" .. preRelease .. "+" .. build

        if preRelease
            return major .. "." .. minor .. "." .. patch .. "-" .. preRelease

        if build
            return major .. "." .. minor .. "." .. patch .. "+" .. build

        return major .. "." .. minor .. "." .. patch

    parse = ( major, minor, patch, preRelease, build ) ->
        unless major
            throw "at least one parameter is needed", 2
            return nil

        if isnumber( major )
            unless isuint( major )
                throw "major version must be unsigned integer", 2

            if minor
                unless isnumber( minor )
                    throw "minor version must be a number", 2

                unless isuint( minor )
                    throw "minor version must be unsigned integer", 2

            else
                minor = 0

            if patch
                unless isnumber( patch )
                    throw "patch version must be a number", 2

                unless isuint( patch )
                    throw "patch version must be unsigned integer", 2

            else
                patch = 0

            if isstring( build )
                if isstring( preRelease )
                    preRelease = parsePreRelease( preRelease )

                build = parseBuild( build )
            elseif isnumber( preRelease )
                preRelease, build = parsePreReleaseAndBuild( preRelease )

        else

            major, minor, patch, extra = match( tostring( major ), "^(%d+)%.?(%d*)%.?(%d*)(.-)$" )
            unless major
                throw "the major version of '#{str}' is missing", 2
                return nil

            major = tonumber( major, 10 )

            if minor == ""
                minor = "0"

            minor = tonumber( minor, 10 )

            if patch == ""
                patch = "0"

            patch = tonumber( patch, 10 )

            preRelease, build = parsePreReleaseAndBuild( extra )

        if major > 0x3ff or minor > 0x7ff or patch > 0x7ff
            throw "version is too large (max 1023.2047.2047)", 2

        elseif major < 0 or minor < 0 or patch < 0
            throw "version is too small (min 0.0.0)", 2

        return major, minor, patch, preRelease, build

    versions = {}

    sort_fn = ( a, b ) ->
        return a > b

    local versionClass
    versionClass = newClass(
        "Version",
        {
            __tostring: =>
                return @__string

            new: ( major, minor, patch, preRelease, build ) =>
                major, minor, patch, preRelease, build = parse( major, minor, patch, preRelease, build )
                str = numbersToString( major, minor, patch, preRelease, build )

                version = versions[ str ]
                if version and version.major == major and version.minor == minor and version.patch == patch and version.prerelease == preRelease and version.build == build
                    return true, version

                @major, @minor, @patch, @prerelease, @build = major, minor, patch, preRelease, build
                versions[ str ] = @
                @__string = str
                return false, nil

            __eq: ( other ) =>
                return @__string == other.__string

            __lt: ( other ) =>
                if @major ~= other.major
                    return @major < other.major

                if @minor ~= other.minor
                    return @minor < other.minor

                if @patch ~= other.patch
                    return @patch < other.patch

                return smallerPreRelease( @prerelease, other.prerelease )

            __pow: ( other ) =>
                if @major == 0
                    return @ == other

                return @major == other.major and @minor <= other.minor

            -- This works like 'satisfies' (fuzzy matching) in npm.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver
            -- A version range is a set of comparators which specify versions that satisfy the range.
            -- A comparator is composed of an operator and a version. The set of primitive operators is:
            --   < Less than
            --   <= Less than or equal to
            --   > Greater than
            --   >= Greater than or equal to
            --   = Equal. If no operator is specified, then equality is assumed, so this operator
            --     is optional, but MAY be included.
            -- Comparators can be joined by whitespace to form a comparator set, which is satisfied by
            -- the intersection of all of the comparators it includes.
            -- A range is composed of one or more comparator sets, joined by ||. A version matches
            -- a range if and only if every comparator in at least one of the ||-separated comparator
            -- sets is satisfied by the version.
            -- A 'version' is described by the v2.0.0 specification found at https://semver.org/.
            -- A leading '=' or 'v' character is stripped off and ignored
            __mod: ( str ) =>
                -- version range := comparator sets
                if find( str, "||", 1, true )
                    local pos, part
                    start = 1

                    while true
                        pos = find( str, "||", start, true )
                        part = sub( str, start, pos and ( pos - 1 ) )

                        if @ % part
                            return true

                        unless pos
                            return false

                        start = pos + 2

                -- comparator set := comparators
                str = gsub( gsub( gsub( str, "%s+", " " ), "^%s+", "" ), "%s+$", "" )

                if find( str, " ", 1, true )
                    local pos, part
                    start = 1

                    while true
                        pos = find( str, " ", start, true )
                        part = sub( str, start, pos and ( pos - 1 ) )

                        -- Hyphen Ranges: X.Y.Z - A.B.C
                        -- https://docs.npmjs.com/cli/v6/using-npm/semver#hyphen-ranges-xyz---abc
                        if pos and sub( str, pos, pos + 2 ) == " - "
                            unless @ % ( ">=" .. part )
                                return false

                            start = pos + 3
                            pos = find( str, " ", start, true )
                            part = sub( str, start, pos and ( pos - 1 ) )

                            unless @ % ( "<=" .. part )
                                return false

                        elseif not ( @ % part )
                            return false

                        unless pos
                            return true

                        start = pos + 1

                    return true

                -- comparators := operator + version
                str = gsub( gsub( str, "^=", "" ), "^v", "" )

                -- X-Ranges *
                -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
                if str == "" or str == "*"
                    return @ % ">=0.0.0"

                pos = find( str, "%d" )
                unless pos
                    throw "Version range must starts with number: " .. str, 2
                    return nil

                -- X-Ranges 1.2.x 1.X 1.2.*
                -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
                local operator
                if pos == 1
                    operator = "="
                else
                    operator = sub( str, 1, pos - 1 )

                version = gsub( sub( str, pos ), "%.[xX*]", "" )
                xrange = max( 2 - ByteCount( version, 0x2e --[[ . ]] ), 0 )

                for i = 1, xrange
                    version = version .. ".0"

                sv = versionClass( version )
                if operator == "<"
                    return @ < sv

                -- primitive operators
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#ranges
                if operator == "<="
                    if xrange > 0
                        if xrange == 1
                            sv = sv\nextMinor!
                        elseif xrange == 2
                            sv = sv\nextMajor!

                        return @ < sv

                    return @ <= sv

                if operator == ">"
                    if xrange > 0
                        if xrange == 1
                            sv = sv\nextMinor!
                        elseif xrange == 2
                            sv = sv\nextMajor!

                        return @ >= sv

                    return @ > sv

                if operator == ">="
                    return @ >= sv

                if operator == "="
                    if xrange > 0
                        if @ < sv
                            return false

                        if xrange == 1
                            sv = sv\nextMinor!
                        elseif xrange == 2
                            sv = sv\nextMajor!

                        return @ < sv

                    return @ == sv

                -- Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4
                -- Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple.
                -- In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for
                -- versions 0.X >=0.1.0, and no updates for versions 0.0.X.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#caret-ranges-123-025-004
                if operator == "^"
                    if sv.major == 0 and xrange < 2
                        if sv.minor == 0 and xrange < 1
                            return @major == 0 and @minor == 0 and @ >= sv and @ < sv\nextPatch!

                        return @major == 0 and @ >= sv and @ < sv\nextMinor!

                    return @major == sv.major and @ >= sv and @ < sv\nextMajor!

                -- Tilde Ranges ~1.2.3 ~1.2 ~1
                -- Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#tilde-ranges-123-12-1
                if operator == "~"
                    if @ < sv
                        return false

                    if xrange == 2
                        return @ < sv\nextMajor!

                    return @ < sv\nextMinor!

                throw "Invaild operator: '" .. operator .. "'", 2
                return nil

            nextMajor: =>
                return versionClass( @major + 1, 0, 0 )

            nextMinor: =>
                return versionClass( @major, @minor + 1, 0 )

            nextPatch: =>
                return versionClass( @major, @minor, @patch + 1 )

            toNumber: =>
                major = tonumber( @major, 10 )
                if major > 0x3ff
                    throw "major version is too large (max 1023)", 2
                    return nil

                minor = tonumber( @minor, 10 )
                if minor > 0x7ff
                    throw "minor version is too large (max 2047)", 2
                    return nil

                patch = tonumber( @patch, 10 )
                if patch > 0x7ff
                    throw "patch version is too large (max 2047)", 2
                    return nil

                return bor( lshift( patch, 21 ), lshift( minor, 10 ), major )
        },
        {
            :parse
            tostring: ( ... ) ->
                return numbersToString( parse( ... ) )

            fromNumber: ( uint ) ->
                return versionClass( band( uint, 0x3ff ), band( rshift( uint, 10 ), 0x7ff ), band( rshift( uint, 21 ), 0x7ff ) )

            select: ( target, versions ) ->
                sort( versions, sort_fn )

                for index = 1, #versions
                    version = versionClass( versions[ index ] )
                    if version % target
                        return version, index

                return nil, -1
        }
    )

    util.Version = versionClass

do

    import GetValue, SetValue from table
    import serialize, deserialize from environment.yaml
    import IsFile, AsyncWrite, Read, Write from environment.file

    environment.Config = newClass( "Config", {
        new: ( name, defaults, @config_type = "yaml" ) =>
            argument( name, 1, "string" )
            @name = name

            filePath = "/data/config/" .. name .. ".txt"
            @timer = "GPM::Config - " .. name
            @filepath = filePath

            if IsFile( filePath )
                @data = @Deserialize( Read( filePath ) )

            elseif defaults
                argument( defaults, 2, "table" )
                @data = defaults
                Write( filePath, @Serialize! )

            else
                @data = {}

            return nil

        GetAll: =>
            return @data

        Get: ( key ) =>
            return GetValue( @data, key )

        Set: ( key, value ) =>
            argument( key, 1, "string" )
            SetValue( @data, key, value )
            Create @timer, 1, 1, ->
                @Write!

            return nil

        Write: =>
            AsyncWrite( @filepath, @Serialize! )
            Remove( @timer )
            return nil

        Read: =>
            @data = @Deserialize( Read( @filepath ) )
            return nil

        Serialize: =>
            if @config_type == "yaml"
                return serialize( @data )

            return TableToJSON( @data, true )

        Deserialize: ( str ) =>
            if @config_type == "yaml"
                return deserialize( str )

            return JSONToTable( str, true, true )

    } )

--[[

    Standard SQL library

--]]

if _G.sql

    import SQLError from environment
    import SQLSafe from string
    import sql, pairs from _G
    import Query from sql
    lib = environment.sql

    lib.lastError = lib.LastError = ->
        return sql.m_strError

    escape = lib.escape = lib.Escape = ( str ) ->
        return str == nil and "null" or SQLSafe( str )

    rawQuery = lib.rawQuery = lib.RawQuery = ( str ) ->
        Logger\Debug( "Executing SQL query: " .. str )

        result = Query( str )
        if result == false
            throw SQLError sql.m_strError, nil, nil, 4

        return result

    tableExists = lib.tableExists = lib.TableExists = ( name ) ->
        return rawQuery( "select name from sqlite_master where name=" .. escape( name ) .. " and type='table'" ) and true or false

    lib.IndexExists = lib.IndexExists = ( name ) ->
        return rawQuery( "select name from sqlite_master where name=" .. escape( name ) .. " and type='index'" ) and true or false

    begin = lib.begin = lib.Begin = ->
        rawQuery( "begin" )
        return nil

    commit = lib.commit = lib.Commit = ->
        rawQuery( "commit" )
        return nil

    rollback = lib.rollback = lib.Rollback = ->
        rawQuery( "rollback" )
        return nil

    query = lib.query = lib.Query = ( str, ... ) ->
        args, index = { ... }, 0
        str = gsub( str, "?", ->
            index += 1
            return escape( args[ index ] )
        )

        result = rawQuery( str )

        -- convert NULL values into nil
        if result
            for tbl in *result
                for key, value in pairs( tbl )
                    if value == "NULL"
                        tbl[ key ] = nil

        return result

    queryRow = lib.queryRow = lib.QueryRow = ( str, row = 1, ... ) ->
        if result := query( str, ... )
            return result[ row ]

        return nil

    queryOne = lib.queryOne = lib.QueryOne = ( str, ... ) ->
        return queryRow( str, 1, ... )

    lib.queryValue = lib.QueryValue = ( str, ... ) ->
        if result := queryOne( str, ... )
            return next( result )

        return nil

    lib.transaction = lib.Transaction = ( func ) ->
        begin()

        ok, result = pcall( func )
        if ok
            commit()
            return result

        rollback()
        throw result
        return nil
