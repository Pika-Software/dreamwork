_G = _G
import gpm, SERVER from _G
import environment, Logger from gpm
import istable, pcall, require, tonumber, tostring from _G
import bit, math, string, table, os, util, argument, isstring, isnumber, isfunction, throw, type from environment
import char, byte, sub, gsub, len, find, format, match from string
import Create, Remove, Simple from environment.timer
import CRC, IsBinaryModuleInstalled from util
import concat, unpack from table
newClass = environment.class
import clamp from math
import time from os

do

    import CodeCompileError from environment

    installed, filePath = IsBinaryModuleInstalled( "moonloader" )
    if installed
        ok, msg = pcall( require, "moonloader" )
        if ok and istable( moonloader )
            Logger\Info( "gm_moonloader v%s loaded.", moonloader._VERSION )
            installed = true
        else
            Logger\Error( "gm_moonloader startup error: %s", msg or "unknown error" )
            installed = false

    yueFail = ->
        throw CodeCompileError "Attempt to compile Yuescript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader."

    if installed
        moonloader = environment.moon = _G.moonloader

        -- Yuescript
        import yue from moonloader

        if istable( yue )
            environment.yue = yue
        else

            environment.yue = {
                ToLua: yueFail
            }

            Logger\Warn( "Yuescript support is missing, yuescript code compilation is unavailable." )

    else

        moonFail = ->
            throw CodeCompileError "Attempt to compile MoonScript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader."

        environment.moon = {
            PreCacheFile: moonFail,
            PreCacheDir: moonFail,
            ToLua: moonFail
        }

        environment.yue = {
            ToLua: yueFail
        }

        Logger\Warn( "Binary module '" .. filePath .. "' is missing, support for moon and yue scripts is unavailable." )

-- https://github.com/WilliamVenner/gmsv_workshop
if SERVER and not ( istable( steamworks ) and isfunction( steamworks.DownloadUGC ) )
    installed, filePath = IsBinaryModuleInstalled( "workshop" )
    if installed
        unless pcall( require, "workshop" )
            Logger\Error( "Binary module '" .. filePath .. "' was corrupted!" )
    else
        Logger\Warn( "Binary module '" .. filePath .. "' is missing, Steam workshop downloads is unavailable." )

do

    local byteCodeSupported
    if SERVER
        -- https://github.com/willox/gmbc
        byteCodeSupported, filePath = IsBinaryModuleInstalled( "gmbc" )
        if byteCodeSupported
            byteCodeSupported = pcall( require, "gmbc" )
        else
            Logger\Warn( "Binary module '" .. filePath .. "' is missing, bytecode compilation is unavailable." )
    else
        byteCodeSupported = false

    import CompileString, gmbc_load_bytecode, setfenv from _G
    import yue, moon from environment
    import IsBytecode from string

    environment.loadstring = ( code, identifier, handleError = true, ignoreBytecode ) ->
        if not ignoreBytecode and IsBytecode( code )
            if byteCodeSupported
                return gmbc_load_bytecode( code )

            msg = "Bytecode compilation is not supported. Please install gmbc (https://github.com/willox/gmbc)"
            if handleError
                throw msg, 2
                return nil

            return msg

        return CompileString( code, identifier, handleError )

    load = ( chunk, chunkName, mode = "bt", env = getfenv( 2 ), config, handleError = true ) ->
        argument( chunkName, 2, "string" )

        switch type( chunk )
            when "string"
                modes = {}
                for byte0 in *{ byte( mode, 1, len( mode ) ) }
                    modes[ byte0 ] = true

                local func
                if modes[ 0x62 --[[ b ]] ] and IsBytecode( chunk )
                    if byteCodeSupported
                        func = gmbc_load_bytecode( chunk )

                    msg = "Bytecode compilation is not supported."
                    if handleError
                        throw msg, 2
                        return nil

                    return msg

                if modes[ 0x79 --[[ y ]] ]
                    if config
                        argument( config, 5, "table" )
                        chunk = yue.ToLua( chunk, config )
                    else
                        chunk = yue.ToLua( chunk )

                elseif modes[ 0x6D --[[ m ]] ]
                    chunk = moon.ToLua( chunk )

                if modes[ 0x74 --[[ t ]] ]
                    func = CompileString( chunk, chunkName, handleError )

                if func
                    if isfunction( func ) and env
                        setfenv( func, env )

                    return func

                msg = "wrong load mode"
                if handleError
                    throw msg, 2
                    return nil

                return msg

            when "function"
                result, length = {}, 0

                str = chunk!
                while str
                    length += 1
                    result[ length ] = str
                    str = chunk!

                if length == 0
                    return ->

                return load( concat( result, "", 1, length ), chunkName, mode, env, config, handleError )

        throw "Invalid argument #1 to 'load' (string/function expected)", 2
        return nil

    environment.load = load

do

    import BInt, IsBInt, struct from environment
    import FromBytes, ToBytes, ToNumber, CastSigned from BInt
    import io from struct

    local setEndianness
    do

        import Little, Set from io.endianness
        import Read from io.i

        util.LZMA_PROPS_SIZE = 5

        util.CompressedSize = ( binary ) ->
            if binary == ""
                return 0

            Little!
            return Read( nil, sub( binary, 6, 14 ), 8 )

        setEndianness = ( isBigEndian ) ->
            if isBigEndian
                Set( "big" )
                return true

            Set( "little" )
            return false

    local readUInt, writeUInt
    do
        uint = io.I
        readUInt, writeUInt = uint.Read, uint.Write

    local SteamID
    do

        import IsSteamID, IsSteamID64 from string
        import fdiv from math

        -- https://developer.valvesoftware.com/wiki/SteamID

        universes = {
            -- 4503603922337792
            [ 0 ]: { "450", 3603922337792, 3 }
            -- 76561197960265728
            [ 1 ]: { "765", 61197960265728, 3 }
            -- 148618791998193664
            [ 2 ]: { "1486", 18791998193664, 4 }
            -- 220676386036121600
            [ 3 ]: { "2206", 76386036121600, 4 }
            -- 292733980074049536
            [ 4 ]: { "2927", 33980074049536, 4 }
            -- 364791574111977472
            [ 5 ]: { "3647", 91574111977472, 4 }
        }

        util.SteamIDTo64 = ( str, fullUniverse ) ->
            x, y, z = match( str, "^STEAM_([0-5]):([01]):(%d+)$" )

            universe = tonumber( x, 10 )
            if not fullUniverse and universe == 0
                universe = 1

            data = universes[ universe ]
            return data[ 1 ] .. ( ( tonumber( z, 10 ) * 2 ) + data[ 2 ] ) + ( y == "1" and 1 or 0 )

        util.SteamIDFrom64 = ( str, skipUniverse ) ->
            local account_id, universe
            if skipUniverse == false
                for i = 0, 5
                    data = universes[ i ]
                    if data[ 1 ] == sub( str, 1, data[ 3 ] )
                        account_id = tonumber( sub( str, data[ 3 ] + 1 ), 10 ) - data[ 2 ]
                        universe = i
                        break

                unless universe
                    universe = 1
            else
                universe = 0
                account_id = tonumber( sub( str, 4 ), 10 ) - 61197960265728

            return "STEAM_"  .. ( universe or 0 ) .. ":" .. ( account_id % 2 == 0 and "0" or "1" ) .. ":" .. fdiv( account_id, 2 )

        metatable = {
            new: ( str, fullUniverse ) =>
                argument( str, 1, "string" )

                if IsSteamID64( str )
                    local account_id, universe
                    if fullUniverse
                        for i = 0, 5
                            data = universes[ i ]
                            if data[ 1 ] == sub( str, 1, data[ 3 ] )
                                account_id = tonumber( sub( str, data[ 3 ] + 1 ), 10 ) - data[ 2 ]
                                universe = i
                                break

                        unless universe
                            universe = 1
                    else
                        universe = 1
                        account_id = tonumber( sub( str, 4 ), 10 ) - 61197960265728

                    @universe, @id, @account_number, @account_id = universe, account_id % 2 ~= 0, fdiv( account_id, 2 ), account_id
                    return nil

                if IsSteamID( str )
                    x, y, z = match( str, "^STEAM_([0-5]):([01]):(%d+)$" )
                    universe, id, account_number = tonumber( x, 10 ), y == "1", tonumber( z, 10 )

                    if not fullUniverse and universe == 0
                        universe = 1

                    @universe, @id, @account_number, @account_id = universe, id, account_number, ( account_number * 2 ) + ( id and 1 or 0 )
                    return nil

                throw "Invalid SteamID", 3
                return nil

            ToXYZ: =>
                return @universe, @id, @account_number

            ToIntegers: =>
                return @universe, @id and 1 or 0, @account_number

            ToSteamID: =>
                return "STEAM_" .. @universe .. ":" .. ( @id and "1" or "0" ) .. ":" .. @account_number

            ToSteamID64: =>
                data = universes[ @universe ]
                return data[ 1 ] .. ( @account_id + data[ 2 ] )

            GetProfileURL: =>
                return "https://steamcommunity.com/profiles/" .. @ToSteamID64!

            ToAccountID: =>
                return @account_id

            ToHex: =>
                return format( "0x%x", @account_id )

            ToSteamID3: =>
                return "[U:" .. @universe .. ":" .. @account_id .. "]"

            ToBinary: ( isBigEndian, withUniverse ) =>
                setEndianness( isBigEndian )

                if withUniverse
                    return char( @universe ) .. writeUInt( nil, @account_id, 4 )

                return writeUInt( nil, @account_id, 4 )

            GetUniverse: =>
                return @universe

            SetUniverse: ( universe ) =>
                argument( universe, 1, "number" )
                if universe < 0 or universe > 5
                    throw( "Invalid SteamID universe", 2 )

                @universe = universe
                return @

        }

        metatable.__tostring = metatable.ToSteamID

        metatable.__eq = ( other ) =>
            return getmetatable( other ) == metatable and @universe == other.universe and @id == other.id and @account_number == other.account_number

        SteamID = newClass( "SteamID", metatable, {
            IsValid: ( steamid ) ->
                argument( steamid, 1, "string" )
                return IsSteamID( steamid )

            FromSteamID: ( steamid ) ->
                argument( steamid, 1, "string" )

                unless IsSteamID( steamid )
                    throw( "Invalid SteamID", 2 )

                x, y, z = match( steamid, "^STEAM_([0-5]):([01]):(%d+)$" )
                id, account_number = y == "1", tonumber( z, 10 )

                return setmetatable( {
                    universe: tonumber( x, 10 )
                    id: id
                    account_number: account_number
                    account_id: ( account_number * 2 ) + ( id and 1 or 0 )
                }, metatable )

            FromSteamID64: ( steamid64, fullUniverse ) ->
                steamid64 = tostring( steamid64 )

                local account_id, universe
                if fullUniverse
                    for i = 0, 5
                        data = universes[ i ]
                        if data[ 1 ] == sub( steamid64, 1, data[ 3 ] )
                            account_id = tonumber( sub( steamid64, data[ 3 ] + 1 ), 10 ) - data[ 2 ]
                            universe = i
                            break

                    unless universe
                        universe = 1
                else
                    universe = 1
                    account_id = tonumber( sub( steamid64, 4 ), 10 ) - 61197960265728

                return setmetatable( {
                    universe: universe
                    id: account_id % 2 ~= 0
                    account_number: fdiv( account_id, 2 )
                    account_id: account_id
                }, metatable )

            FromSteamID3: ( sid3 ) ->
                x, z = match( sid3, "^%[?U:(%d):(%d+)%]?$" )

                account_number = tonumber( z, 10 ) or -1
                if account_number < 0
                    throw( "Invalid SteamID3", 2 )

                account_number, id = fdiv( account_number, 2 ), z % 2 ~= 0

                return setmetatable( {
                    universe: tonumber( x, 10 )
                    id: id
                    account_number: account_number
                    account_id: ( account_number * 2 ) + ( id and 1 or 0 )
                }, metatable )

            FromBinary: ( binary, isBigEndian, withUniverse ) ->
                setEndianness( isBigEndian )

                account_id = readUInt( nil, withUniverse and sub( binary, 2 ) or binary, 4 ) or -1
                if account_id < 0
                    throw( "Invalid binary SteamID", 2 )

                return setmetatable( {
                    universe: withUniverse and clamp( byte( binary, 1 ), 0, 5 ) or 1
                    id: account_id % 2 ~= 0
                    account_number: fdiv( account_id, 2 )
                    account_id: account_id
                }, metatable )

            FromHex: ( hex ) ->
                unless isnumber( hex )
                    hex = tonumber( hex, 16 )

                argument( hex, 1, "number" )

                if hex < 0
                    throw( "Invalid hex", 2 )

                return setmetatable( {
                    universe: 1
                    id: hex % 2 ~= 0
                    account_number: fdiv( hex, 2 )
                    account_id: hex
                }, metatable )

            FromAccountID: ( account_id ) ->
                argument( account_id, 1, "number" )

                return setmetatable( {
                    universe: 1
                    id: account_id % 2 ~= 0
                    account_number: fdiv( account_id, 2 )
                    account_id: account_id
                }, metatable )
        } )

        environment.SteamID = SteamID

    -- lua 5.3 string features
    do

        import Read, Write from struct

        string.pack = ( fmt, ... ) ->
            return Write( fmt, { ... } )

        string.unpack = ( fmt, binary, offset ) ->
            if offset
                return unpack( Read( fmt, sub( binary, offset, len( binary ) ) ) )

            return unpack( Read( fmt, binary ) )

        string.packsize = struct.SizeOf

    -- Byte Stream
    import deflate, Color from environment
    import unix2dos, dos2unix from os
    import reverse from string
    import Date from util

    local readInt, writeInt
    do
        int = io.i
        readInt, writeInt = int.Read, int.Write

    local readFloat, writeFloat
    do
        float = io.f
        readFloat, writeFloat = float.Read, float.Write

    local readDouble, writeDouble
    do
        double = io.d
        readDouble, writeDouble = double.Read, double.Write

    noCompression = ( content ) ->
        return content

    compressionMethods = {
        -- No compression
        [ 0 ]: {
            [1]: noCompression,
            [2]: noCompression
        },

        -- Deflate
        [ 8 ]: {
            [1]: deflate.CompressDeflate,
            [2]: deflate.DecompressDeflate
        }
    }

    seek = ( position ) =>
        @Flush!

        if position
            argument( position, 2, "number" )
            position = clamp( position, 0, @size )
        else
            position = 0

        @pointer = position
        return position

    util.ByteStream = newClass(
        "ByteStream",
        {
            __tostring: =>
                return format( "ByteStream: %p [%d/%d]", @, @pointer, @size )

            IsValid: =>
                return @data ~= nil

            EndOfFile: =>
                return @pointer >= @size

            Size: =>
                return @size

            Tell: =>
                return @pointer

            Close: =>
                @Flush!
                @pointer = 0

            Seek: seek
            SeekTo: seek

            SeekToBegin: =>
                return @Seek( 0 )

            SeekToEnd: =>
                return @Seek( @size - @pointer )

            SkipEmpty: =>
                while not @EndOfFile!
                    if @ReadByte! ~= 0
                        @Skip( -1 )
                        break

            Skip: ( length ) =>
                if length
                    argument( length, 2, "number" )
                else
                    length = 1

                return @Seek( @pointer + length )

            -- Byte read
            Read: ( length ) =>
                :pointer, :size = @
                if length == "*a" or length == nil
                    length = size

                argument( length, 2, "number" )

                if length > 0
                    if pointer >= size
                        return nil, "eof"

                    return sub( @data, pointer + 1, @Skip( length ) )

                if length < 0
                    if pointer <= 0
                        return nil, "sof"

                    return sub( @data, @Skip( length ), pointer + 1 )

                return nil, "no data"

            ReadAll: =>
                @SeekToBegin!
                return @Read( @size )

            -- String
            ReadString: =>
                :pointer, :size = @
                if pointer >= size
                    return nil, "eof"

                length, data = 0, @data
                for index = pointer, size
                    if byte( data, index + 1 ) == 0
                        break

                    length += 1

                if length == 0
                    @Skip( 1 )
                    return nil

                str = @Read( length )
                @Skip( 1 )
                return str

            WriteString: ( str ) =>
                argument( str, 1, "string" )
                return @Write( str .. "\0" )

            -- Line
            ReadLine: =>
                :pointer, :size = @
                if pointer >= size
                    return nil, "eof"

                length, data = 0, @data
                for index = pointer, size
                    if byte( data, index + 1 ) == 0xA --[[ \n ]]
                        break

                    length += 1

                if length == 0
                    @Skip( 1 )
                    return nil

                return @Read( length )

            WriteLine: ( str ) =>
                argument( str, 1, "string" )
                return @Write( str .. "\n" )

            -- Byte
            ReadByte: =>
                if @EndOfFile!
                    return nil, "eof"

                return byte( @data, @Skip( 1 ) )

            WriteByte: ( number ) =>
                return @Write( char( number ) )

            -- Boolean
            ReadBool: =>
                switch @ReadByte!
                    when 0
                        return false

                    when 1
                        return true

                return nil, "eof"

            WriteBool: ( bool ) =>
                return @WriteByte( bool and 1 or 0 )

            -- UInt
            ReadUInt: ( bytes, isBigEndian ) =>
                argument( bytes, 2, "number", 4 )
                setEndianness( isBigEndian )
                return readUInt( nil, @Read( bytes ), bytes )

            WriteUInt: ( number, bytes, isBigEndian ) =>
                argument( number, 1, "number", 4 )
                argument( bytes, 2, "number", 4 )
                setEndianness( isBigEndian )
                return @Write( writeUInt( nil, number, bytes ) )

            -- UShort
            ReadUShort: ( isBigEndian ) =>
                return @ReadUInt( 2, isBigEndian )

            WriteUShort: ( number, isBigEndian ) =>
                return @WriteUInt( number, 2, isBigEndian )

            -- ULong
            ReadULong: ( isBigEndian ) =>
                return @ReadUInt( 4, isBigEndian )

            WriteULong: ( number, isBigEndian ) =>
                return @WriteUInt( number, 4, isBigEndian )

            -- UInt64
            ReadUInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readUInt( nil, sub( binary, 3 ), 6 )

                    return FromBytes( binary, false )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readUInt( nil, binary, 6 )

                return FromBytes( binary, true )

            WriteUInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( ToBytes( number, 8, false ) )

                    return @Write( ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @Write( "\0\0" )

                    if isBint
                        return @Write( writeUInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeUInt( nil, number, 6 ) )

                if isBint
                    @Write( writeUInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeUInt( nil, number, 6 ) )

                return @Write( "\0\0" )

            -- Int
            ReadInt: ( bytes, isBigEndian ) =>
                argument( bytes, 2, "number", 4 )
                setEndianness( isBigEndian )
                return readInt( nil, @Read( bytes ), bytes )

            WriteInt: ( number, bytes, isBigEndian ) =>
                argument( number, 1, "number", 4 )
                argument( bytes, 2, "number", 4 )
                setEndianness( isBigEndian )
                return @Write( writeInt( nil, number, bytes ) )

            -- Short
            ReadShort: ( isBigEndian ) =>
                return @ReadInt( 2, isBigEndian )

            WriteShort: ( number, isBigEndian ) =>
                return @WriteInt( number, 2, isBigEndian )

            -- Long
            ReadLong: ( isBigEndian ) =>
                return @ReadInt( 4, isBigEndian )

            WriteLong: ( number, isBigEndian ) =>
                return @WriteInt( number, 4, isBigEndian )

            -- Int64
            ReadInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readInt( nil, sub( binary, 3 ), 6 )

                    return CastSigned( FromBytes( binary, false ), 8 )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readInt( nil, binary, 6 )

                return CastSigned( FromBytes( binary, true ), 8 )

            WriteInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( ToBytes( number, 8, false ) )

                    return @Write( ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @Write( "\0\0" )

                    if isBint
                        return @Write( writeInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeInt( nil, number, 6 ) )

                if isBint
                    @Write( writeInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeInt( nil, number, 6 ) )

                return @Write( "\0\0" )

            -- Float
            ReadFloat: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readFloat( nil, @Read( 4 ), 4 )

            WriteFloat: ( number, isBigEndian ) =>
                argument( number, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeFloat( nil, number, 4 ) )

            -- Double
            ReadDouble: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readDouble( nil, @Read( 8 ), 8 )

            WriteDouble: ( number, isBigEndian ) =>
                argument( number, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeDouble( nil, number, 8 ) )

            -- Time
            ReadTime: =>
                return dos2unix( @ReadUShort!, @ReadUShort! )

            WriteTime: ( u ) =>
                t, d = unix2dos( u )
                @WriteUShort( t )
                return @WriteUShort( d )

            -- ZipFile ( https://medium.com/@felixstridsberg/the-zip-file-format-6c8a160d1c34 )
            ReadZipFile: ( doCRC ) =>
                if @Read( 4 ) ~= "PK\x03\x04"
                    return

                data = {}

                @Skip( 4 )

                compressionMethod = data.compression = @ReadUShort!
                data.time = @ReadTime!

                crc = data.crc = @ReadULong!
                compressedSize = @ReadULong!
                data.size = @ReadULong!

                pathLength = @ReadUShort!
                extraLength = @ReadUShort!

                data.path = @Read( pathLength )
                @Skip( extraLength )

                method = compressionMethods[ compressionMethod ]
                unless method
                    return data, "compression method not supported"

                content = data.content = method[ 2 ]( @Read( compressedSize ) )

                if doCRC and content and crc ~= CRC( content )
                    return data, "crc-32 mismatch"

                return data

            WriteZipFile: ( fileName, content, compressionMethod = 0, unixTime = time! ) =>
                argument( fileName, 1, "string" )
                argument( content, 2, "string" )
                argument( compressionMethod, 3, "number" )
                argument( unixTime, 4, "number" )

                -- signature
                @Write( "PK\x03\x04" )

                -- Version needed to extract (minimum)
                @WriteUShort( 0 )

                -- General purpose bit flag
                @WriteUShort( 0 )

                method = compressionMethods[ compressionMethod ]
                unless method
                    throw "Unsupported compression method: " .. compressionMethod
                    return nil

                -- Compression method
                @WriteUShort( compressionMethod )

                -- Modification time
                @WriteTime( unixTime )

                -- CRC-32
                @WriteULong( tonumber( CRC( content ), 10 ) )
                fileSize = len( content )

                content = method[ 1 ]( content )

                -- Compressed size
                @WriteULong( len( content ) )

                -- Uncompressed size
                @WriteULong( fileSize )

                -- File name length
                @WriteUShort( len( fileName ) )

                -- Extra field length
                @WriteUShort( 0 )

                @Write( fileName )
                return @Write( content )

            -- Color
            ReadColor: =>
                return Color( byte( @Read( 4 ) ) )

            WriteColor: ( color ) =>
                return @Write( char( color.r, color.g, color.b, color.a ) )

            -- Date
            ReadDate: =>
                return Date.FromBinary( @Read( 12 ) )

            WriteDate: ( date ) =>
                if isstring( date )
                    date = Date( date )

                argument( date, 1, "Date" )
                return @Write( date\ToBinary! )

            -- SteamID
            ReadSteamID: ( isBigEndian, withUniverse ) =>
                return SteamID.FromBinary( @Read( withUniverse and 5 or 4 ), setEndianness( isBigEndian ), withUniverse )

            WriteSteamID: ( steamid, withUniverse ) =>
                if isstring( steamid )
                    steamid = SteamID( steamid )

                argument( steamid, 1, "SteamID" )
                return @Write( steamid\ToBinary( withUniverse ) )

        },
        {
            CompressionMethods: compressionMethods
        },
        struct.Cursor
    )

    do

        import ceil, max, pow2, trunc from math
        import Insert from table
        import band from bit

        metatable = {
            __tostring: =>
                return format( "BitStream: %p [%d/%d]", @, @pointer, @size )

            new: ( str ) =>
                @buffer_size = 0
                @pointer = 0
                @buffer = {}

                local bits
                if str
                    argument( str, 1, "string" )
                    length = len( str )
                    bit_count = 0
                    bits = {}

                    for i = 1, length
                        uint = byte( str, i )

                        bits[ bit_count + 1 ] = band( uint, 1 ) ~= 0
                        bits[ bit_count + 2 ] = band( uint, 2 ) ~= 0
                        bits[ bit_count + 3 ] = band( uint, 4 ) ~= 0
                        bits[ bit_count + 4 ] = band( uint, 8 ) ~= 0
                        bits[ bit_count + 5 ] = band( uint, 16 ) ~= 0
                        bits[ bit_count + 6 ] = band( uint, 32 ) ~= 0
                        bits[ bit_count + 7 ] = band( uint, 64 ) ~= 0
                        bits[ bit_count + 8 ] = band( uint, 128 ) ~= 0

                        bit_count += 8

                    @size = max( length, 1 ) * 8
                else
                    bits = { false, false, false, false, false, false, false, false }
                    @size = 0

                @bits = bits

            Flush: =>
                :buffer_size = @
                if buffer_size == 0
                    return @bits

                :bits, :pointer, :size = @

                if pointer > size
                    for index = size, pointer
                        bits[ index ] = false

                    size = pointer

                Insert( @buffer, pointer, buffer_size, pointer, bits )

                @pointer = pointer + buffer_size
                @size = size + buffer_size

                @buffer_size = 0
                @buffer = {}
                return bits

            Size: ( inBytes ) =>
                if inBytes
                    return ceil( @size * 0.125 )

                return @size

            SkipZeros: =>
                pointer = @pointer + 1
                :bits, :size = @

                while pointer <= size
                    pointer += 1

                    if bits[ pointer ]
                        pointer -= 1
                        break

                @pointer = pointer
                return pointer

            -- Bits
            ReadBits: ( length ) =>
                @Flush!

                :pointer, :size = @
                if length == "*a" or length == nil
                    length = size

                argument( length, 2, "number" )

                if length > 0
                    if pointer >= size
                        return nil, "eof"

                    return unpack( @bits, pointer + 1, pointer + length )

                if length < 0
                    if pointer <= 0
                        return nil, "sof"

                    start, finish = pointer + 1, pointer + length
                    return unpack( table.Reverse( { unpack( @bits, start, finish ) } ), start, finish )

                return nil

            WriteBits: ( ... ) =>
                args = { ... }
                arg_count = #args

                buffer = @buffer
                buffer_size = @buffer_size

                for index = 1, arg_count
                    buffer_size += 1
                    buffer[ buffer_size ] = args[ index ] == true

                @buffer_size = buffer_size
                return nil

            -- Boolean
            ReadBit: =>
                if @EndOfFile!
                    return nil, "eof"

                return @bits[ @Skip( 1 ) ] == true

            WriteBit: ( bool ) =>
                buffer_size = @buffer_size + 1
                @buffer[ buffer_size ] = bool == true
                @buffer_size = buffer_size
                return nil

            -- Byte
            ReadByte: ( ignoreSize ) =>
                :pointer = @

                unless ignoreSize
                    if pointer >= @size
                        return nil, "eof"

                    if ( @Skip( 8 ) - pointer ) ~= 8
                        return nil, "eof"

                :bits = @

                return ( bits[ pointer + 1 ] and 1 or 0 ) +
                    ( bits[ pointer + 2 ] and 2 or 0 ) +
                    ( bits[ pointer + 3 ] and 4 or 0 ) +
                    ( bits[ pointer + 4 ] and 8 or 0 ) +
                    ( bits[ pointer + 5 ] and 16 or 0 ) +
                    ( bits[ pointer + 6 ] and 32 or 0 ) +
                    ( bits[ pointer + 7 ] and 64 or 0 ) +
                    ( bits[ pointer + 8 ] and 128 or 0 )

            WriteByte: ( uint ) =>
                argument( uint, 1, "number" )

                if uint < 0 or uint > 255
                    throw "uint must be between 0 and 255", 2

                :buffer, :buffer_size = @

                buffer[ buffer_size + 1 ] = band( uint, 1 ) ~= 0
                buffer[ buffer_size + 2 ] = band( uint, 2 ) ~= 0
                buffer[ buffer_size + 3 ] = band( uint, 4 ) ~= 0
                buffer[ buffer_size + 4 ] = band( uint, 8 ) ~= 0
                buffer[ buffer_size + 5 ] = band( uint, 16 ) ~= 0
                buffer[ buffer_size + 6 ] = band( uint, 32 ) ~= 0
                buffer[ buffer_size + 7 ] = band( uint, 64 ) ~= 0
                buffer[ buffer_size + 8 ] = band( uint, 128 ) ~= 0

                @buffer_size = buffer_size + 8
                return @

            WriteNull: =>
                :buffer, :buffer_size = @

                buffer[ buffer_size + 1 ] = false
                buffer[ buffer_size + 2 ] = false
                buffer[ buffer_size + 3 ] = false
                buffer[ buffer_size + 4 ] = false
                buffer[ buffer_size + 5 ] = false
                buffer[ buffer_size + 6 ] = false
                buffer[ buffer_size + 7 ] = false
                buffer[ buffer_size + 8 ] = false

                @buffer_size = buffer_size + 8
                return @

            -- Bytes
            Read: ( length ) =>
                :pointer, :size = @

                local reverseMode

                if length == nil
                    length = ceil( ( size - pointer ) / 8 )
                elseif length == 0
                    return nil, "no data"
                else
                    reverseMode = length < 0
                    if reverseMode
                        if pointer <= 0
                            return nil, "sof"

                        length = max( -length, ceil( pointer / 8 ) )
                    elseif pointer >= size
                        return nil, "eof"
                    else
                        length = max( length, ceil( ( size - pointer ) / 8 ) )

                bytes = {}
                :bits = @

                if reverseMode
                    for i = length, 1, -1
                        uint = 0

                        for j = 7, 0, -1
                            if bits[ pointer - 7 + j ] == true
                                uint += pow2[ j ]

                        pointer -= 8

                        bytes[ i ] = char( uint )
                else
                    for i = 1, length, 1
                        uint = 0

                        pointer += 1

                        for j = 0, 7, 1
                            if bits[ pointer + j ] == true
                                uint += pow2[ j ]

                        pointer += 7

                        bytes[ i ] = char( uint )

                @pointer = pointer

                return concat( bytes, "", 1, length )

            Write: ( str ) =>
                argument( str, 1, "string" )

                buffer = @buffer
                buffer_size = @buffer_size

                for i = 1, len( str )
                    uint = byte( str, i )

                    buffer[ buffer_size + 1 ] = band( uint, 1 ) ~= 0
                    buffer[ buffer_size + 2 ] = band( uint, 2 ) ~= 0
                    buffer[ buffer_size + 3 ] = band( uint, 4 ) ~= 0
                    buffer[ buffer_size + 4 ] = band( uint, 8 ) ~= 0
                    buffer[ buffer_size + 5 ] = band( uint, 16 ) ~= 0
                    buffer[ buffer_size + 6 ] = band( uint, 32 ) ~= 0
                    buffer[ buffer_size + 7 ] = band( uint, 64 ) ~= 0
                    buffer[ buffer_size + 8 ] = band( uint, 128 ) ~= 0

                    buffer_size += 8

                @buffer_size = buffer_size
                return @

            -- String
            ReadString: =>
                :pointer = @
                if pointer >= @size
                    return nil, "eof"

                parts, length = {}, 0

                uint = @ReadByte!
                while uint ~= 0
                    length += 1
                    parts[ length ] = char( uint )
                    uint = @ReadByte!

                if length == 0
                    return nil, "no data"

                return concat( parts, "", 1, length )

            WriteString: ( str ) =>
                argument( str, 1, "string" )
                @Write( str )
                @WriteNull!
                return @

            ReadLine: =>
                :pointer, :size = @
                if pointer >= size
                    return nil, "eof"

                length = 0
                for index = pointer, size
                    uint = @ReadByte!
                    unless uint
                        return nil, "eof"

                    if uint == 0xA --[[ \n ]] or uint == 0
                        break

                    length += 1

                if length == 0
                    return nil

                @Seek( pointer )
                return @Read( length )

            -- UInt64
            ReadUInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readUInt( nil, sub( binary, 3 ), 6 )

                    return FromBytes( binary, false )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readUInt( nil, binary, 6 )

                return FromBytes( binary, true )

            WriteUInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( ToBytes( number, 8, false ) )

                    return @Write( ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @WriteNull!
                    @WriteNull!

                    if isBint
                        return @Write( writeUInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeUInt( nil, number, 6 ) )

                if isBint
                    @Write( writeUInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeUInt( nil, number, 6 ) )

                @WriteNull!
                return @WriteNull!

            -- Int64
            ReadInt64: ( isBigEndian ) =>
                binary = @Read( 8 )
                unless binary
                    return nil, "eof"

                if setEndianness( isBigEndian )
                    if byte( binary, 1 ) == 0 and byte( binary, 2 ) == 0
                        return readInt( nil, sub( binary, 3 ), 6 )

                    return CastSigned( FromBytes( binary, false ), 8 )

                if byte( binary, 7 ) == 0 and byte( binary, 8 ) == 0
                    return readInt( nil, binary, 6 )

                return CastSigned( FromBytes( binary, true ), 8 )

            WriteInt64: ( number, isBigEndian ) =>
                local isBint
                if isnumber( number )
                    isBint = false
                else
                    number = BInt( number )
                    isBint = true

                if isBint or number > 0xFFFFFFFFFFFF
                    if setEndianness( isBigEndian )
                        return @Write( ToBytes( number, 8, false ) )

                    return @Write( ToBytes( number, 8, true ) )

                if setEndianness( isBigEndian )
                    @WriteNull!
                    @WriteNull!

                    if isBint
                        return @Write( writeInt( nil, ToNumber( number ), 6 ) )

                    return @Write( writeInt( nil, number, 6 ) )

                if isBint
                    @Write( writeInt( nil, ToNumber( number ), 6 ) )
                else
                    @Write( writeInt( nil, number, 6 ) )

                @WriteNull!
                return @WriteNull!

            -- Float
            ReadFloat: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readFloat( nil, @Read( 4 ), 4 )

            WriteFloat: ( number, isBigEndian ) =>
                argument( number, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeFloat( nil, number, 4 ) )

            -- Double
            ReadDouble: ( isBigEndian ) =>
                setEndianness( isBigEndian )
                return readDouble( nil, @Read( 8 ), 8 )

            WriteDouble: ( number, isBigEndian ) =>
                argument( number, 2, "number" )
                setEndianness( isBigEndian )
                return @Write( writeDouble( nil, number, 8 ) )

            -- Color
            ReadColor: =>
                return Color( @ReadByte!, @ReadByte!, @ReadByte!, @ReadByte! )

            WriteColor: ( color ) =>
                @WriteByte( color.r )
                @WriteByte( color.g )
                @WriteByte( color.b )
                return @WriteByte( color.a )

        }

        -- Yep, in bitstream bool is a bit
        metatable.ReadBool = metatable.ReadBit
        metatable.WriteBool = metatable.WriteBit

        util.BitStream = environment.extend( util.ByteStream, "BitStream", metatable )

-- Version
do

    import ByteSplit, lower from string

    do

        import URL, isurl from environment
        import Flip from table

        string.PathFromURL = ( url ) ->
            unless isurl( url )
                url = URL( url )

            if not url.hostname or url.hostname == ""
                return url.scheme .. "/" .. lower(url.pathname)

            return url.scheme .. "/" .. concat( Flip( ByteSplit( lower(url.hostname), 0x2E --[[ . ]] ) ), "/" ) .. lower(url.pathname)

    import band, bor, lshift, rshift from bit
    import isuint, max from math
    import ByteCount from string
    import sort from table

    compare = ( a, b ) ->
        return a == b and 0 or a < b and -1 or 1

    compareIDs = ( value, value2 ) ->
        if value == value2
            return 0

        unless value
            return -1

        unless value2
            return 1

        number, number2 = tonumber( value, 10 ), tonumber( value2, 10 )
        if number and number2
            return compare( number, number2 )

        if number
            return -1

        if number2
            return 1

        return compare( value, value2 )

    smallerPreRelease = ( first, second ) ->
        if not first or first == second
            return false

        unless second
            return true

        fisrt, fcount = ByteSplit( first, 0x2E --[[ . ]] )
        second, scount = ByteSplit( second, 0x2E --[[ . ]] )

        local comparison
        for index = 1, fcount
            comparison = compareIDs( fisrt[ index ], second[ index ] )
            if comparison ~= 0
                return comparison == -1

        return fcount < scount

    parsePreRelease = ( str ) ->
        if str == ""
            return nil

        preRelease = match( str, "^-(%w[%.%w-]*)$" )
        if not preRelease or match( preRelease, "%.%." )
            throw "the pre-release '" .. str .. "' is not valid"
            return nil

        return preRelease

    parseBuild = ( str ) ->
        if str == ""
            return nil

        build = match( str, "^%+(%w[%.%w-]*)$" )
        if not build or match( build, "%.%." )
            throw "the build '" .. str .. "' is not valid"
            return nil

        return build

    parsePreReleaseAndBuild = ( str ) =>
        if not str or str == ""
            return nil

        preRelease, build = match( str, "^(%-[^+]+)(%+.+)$" )
        unless preRelease and build
            switch byte( str, 1 )
                when 0x2d --[[ - ]]
                    preRelease = parsePrerelease( str )

                when 0x2b --[[ + ]]
                    build = parseBuild( str )

                else
                    throw "the parameter '" .. str .. "' must begin with + or - to denote a pre-release or a build", 3
                    return nil

        return preRelease, build

    -- Semver lua parser. Based on https://github.com/kikito/semver.lua
    -- https://github.com/Pika-Software/gpm_legacy/blob/main/lua/gpm/sh_semver.lua
    numbersToString = ( major, minor, patch, preRelease, build ) ->
        if preRelease and build
            return major .. "." .. minor .. "." .. patch .. "-" .. preRelease .. "+" .. build

        if preRelease
            return major .. "." .. minor .. "." .. patch .. "-" .. preRelease

        if build
            return major .. "." .. minor .. "." .. patch .. "+" .. build

        return major .. "." .. minor .. "." .. patch

    parse = ( major, minor, patch, preRelease, build ) ->
        unless major
            throw "at least one parameter is needed", 2
            return nil

        if isnumber( major )
            unless isuint( major )
                throw "major version must be unsigned integer", 2

            if minor
                unless isnumber( minor )
                    throw "minor version must be a number", 2

                unless isuint( minor )
                    throw "minor version must be unsigned integer", 2

            else
                minor = 0

            if patch
                unless isnumber( patch )
                    throw "patch version must be a number", 2

                unless isuint( patch )
                    throw "patch version must be unsigned integer", 2

            else
                patch = 0

            if isstring( build )
                if isstring( preRelease )
                    preRelease = parsePreRelease( preRelease )

                build = parseBuild( build )
            elseif isnumber( preRelease )
                preRelease, build = parsePreReleaseAndBuild( preRelease )

        else

            major, minor, patch, extra = match( tostring( major ), "^(%d+)%.?(%d*)%.?(%d*)(.-)$" )
            unless major
                throw "the major version of '#{str}' is missing", 2
                return nil

            major = tonumber( major, 10 )

            if minor == ""
                minor = "0"

            minor = tonumber( minor, 10 )

            if patch == ""
                patch = "0"

            patch = tonumber( patch, 10 )

            preRelease, build = parsePreReleaseAndBuild( extra )

        if major > 0x3ff or minor > 0x7ff or patch > 0x7ff
            throw "version is too large (max 1023.2047.2047)", 2

        elseif major < 0 or minor < 0 or patch < 0
            throw "version is too small (min 0.0.0)", 2

        return major, minor, patch, preRelease, build

    versions = {}

    sort_fn = ( a, b ) ->
        return a > b

    local versionClass
    versionClass = newClass(
        "Version",
        {
            __tostring: =>
                return @__string

            new: ( major, minor, patch, preRelease, build ) =>
                major, minor, patch, preRelease, build = parse( major, minor, patch, preRelease, build )
                str = numbersToString( major, minor, patch, preRelease, build )

                version = versions[ str ]
                if version and version.major == major and version.minor == minor and version.patch == patch and version.prerelease == preRelease and version.build == build
                    return true, version

                @major, @minor, @patch, @prerelease, @build = major, minor, patch, preRelease, build
                versions[ str ] = @
                @__string = str
                return false, nil

            __eq: ( other ) =>
                return @__string == other.__string

            __lt: ( other ) =>
                if @major ~= other.major
                    return @major < other.major

                if @minor ~= other.minor
                    return @minor < other.minor

                if @patch ~= other.patch
                    return @patch < other.patch

                return smallerPreRelease( @prerelease, other.prerelease )

            __pow: ( other ) =>
                if @major == 0
                    return @ == other

                return @major == other.major and @minor <= other.minor

            -- This works like 'satisfies' (fuzzy matching) in npm.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver
            -- A version range is a set of comparators which specify versions that satisfy the range.
            -- A comparator is composed of an operator and a version. The set of primitive operators is:
            --   < Less than
            --   <= Less than or equal to
            --   > Greater than
            --   >= Greater than or equal to
            --   = Equal. If no operator is specified, then equality is assumed, so this operator
            --     is optional, but MAY be included.
            -- Comparators can be joined by whitespace to form a comparator set, which is satisfied by
            -- the intersection of all of the comparators it includes.
            -- A range is composed of one or more comparator sets, joined by ||. A version matches
            -- a range if and only if every comparator in at least one of the ||-separated comparator
            -- sets is satisfied by the version.
            -- A 'version' is described by the v2.0.0 specification found at https://semver.org/.
            -- A leading '=' or 'v' character is stripped off and ignored
            __mod: ( str ) =>
                -- version range := comparator sets
                if find( str, "||", 1, true )
                    local pos, part
                    start = 1

                    while true
                        pos = find( str, "||", start, true )
                        part = sub( str, start, pos and ( pos - 1 ) )

                        if @ % part
                            return true

                        unless pos
                            return false

                        start = pos + 2

                -- comparator set := comparators
                str = gsub( gsub( gsub( str, "%s+", " " ), "^%s+", "" ), "%s+$", "" )

                if find( str, " ", 1, true )
                    local pos, part
                    start = 1

                    while true
                        pos = find( str, " ", start, true )
                        part = sub( str, start, pos and ( pos - 1 ) )

                        -- Hyphen Ranges: X.Y.Z - A.B.C
                        -- https://docs.npmjs.com/cli/v6/using-npm/semver#hyphen-ranges-xyz---abc
                        if pos and sub( str, pos, pos + 2 ) == " - "
                            unless @ % ( ">=" .. part )
                                return false

                            start = pos + 3
                            pos = find( str, " ", start, true )
                            part = sub( str, start, pos and ( pos - 1 ) )

                            unless @ % ( "<=" .. part )
                                return false

                        elseif not ( @ % part )
                            return false

                        unless pos
                            return true

                        start = pos + 1

                    return true

                -- comparators := operator + version
                str = gsub( gsub( str, "^=", "" ), "^v", "" )

                -- X-Ranges *
                -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
                if str == "" or str == "*"
                    return @ % ">=0.0.0"

                pos = find( str, "%d" )
                unless pos
                    throw "Version range must starts with number: " .. str, 2
                    return nil

                -- X-Ranges 1.2.x 1.X 1.2.*
                -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
                local operator
                if pos == 1
                    operator = "="
                else
                    operator = sub( str, 1, pos - 1 )

                version = gsub( sub( str, pos ), "%.[xX*]", "" )
                xrange = max( 2 - ByteCount( version, 0x2e --[[ . ]] ), 0 )

                for i = 1, xrange
                    version = version .. ".0"

                sv = versionClass( version )
                if operator == "<"
                    return @ < sv

                -- primitive operators
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#ranges
                if operator == "<="
                    if xrange > 0
                        if xrange == 1
                            sv = sv\nextMinor!
                        elseif xrange == 2
                            sv = sv\nextMajor!

                        return @ < sv

                    return @ <= sv

                if operator == ">"
                    if xrange > 0
                        if xrange == 1
                            sv = sv\nextMinor!
                        elseif xrange == 2
                            sv = sv\nextMajor!

                        return @ >= sv

                    return @ > sv

                if operator == ">="
                    return @ >= sv

                if operator == "="
                    if xrange > 0
                        if @ < sv
                            return false

                        if xrange == 1
                            sv = sv\nextMinor!
                        elseif xrange == 2
                            sv = sv\nextMajor!

                        return @ < sv

                    return @ == sv

                -- Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4
                -- Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple.
                -- In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for
                -- versions 0.X >=0.1.0, and no updates for versions 0.0.X.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#caret-ranges-123-025-004
                if operator == "^"
                    if sv.major == 0 and xrange < 2
                        if sv.minor == 0 and xrange < 1
                            return @major == 0 and @minor == 0 and @ >= sv and @ < sv\nextPatch!

                        return @major == 0 and @ >= sv and @ < sv\nextMinor!

                    return @major == sv.major and @ >= sv and @ < sv\nextMajor!

                -- Tilde Ranges ~1.2.3 ~1.2 ~1
                -- Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.
                -- https://docs.npmjs.com/cli/v6/using-npm/semver#tilde-ranges-123-12-1
                if operator == "~"
                    if @ < sv
                        return false

                    if xrange == 2
                        return @ < sv\nextMajor!

                    return @ < sv\nextMinor!

                throw "Invaild operator: '" .. operator .. "'", 2
                return nil

            nextMajor: =>
                return versionClass( @major + 1, 0, 0 )

            nextMinor: =>
                return versionClass( @major, @minor + 1, 0 )

            nextPatch: =>
                return versionClass( @major, @minor, @patch + 1 )

            toNumber: =>
                major = tonumber( @major, 10 )
                if major > 0x3ff
                    throw "major version is too large (max 1023)", 2
                    return nil

                minor = tonumber( @minor, 10 )
                if minor > 0x7ff
                    throw "minor version is too large (max 2047)", 2
                    return nil

                patch = tonumber( @patch, 10 )
                if patch > 0x7ff
                    throw "patch version is too large (max 2047)", 2
                    return nil

                return bor( lshift( patch, 21 ), lshift( minor, 10 ), major )
        },
        {
            :parse
            tostring: ( ... ) ->
                return numbersToString( parse( ... ) )

            fromNumber: ( uint ) ->
                return versionClass( band( uint, 0x3ff ), band( rshift( uint, 10 ), 0x7ff ), band( rshift( uint, 21 ), 0x7ff ) )

            select: ( target, versions ) ->
                sort( versions, sort_fn )

                for index = 1, #versions
                    version = versionClass( versions[ index ] )
                    if version % target
                        return version, index

                return nil, -1
        }
    )

    util.Version = versionClass

do

    import GetValue, SetValue from table
    import serialize, deserialize from environment.yaml
    import IsFile, AsyncWrite, Read, Write from environment.file

    environment.Config = newClass( "Config", {
        new: ( name, defaults, @config_type = "yaml" ) =>
            argument( name, 1, "string" )
            @name = name

            filePath = "/data/config/" .. name .. ".txt"
            @timer = "GPM::Config - " .. name
            @filepath = filePath

            if IsFile( filePath )
                @data = @Deserialize( Read( filePath ) )

            elseif defaults
                argument( defaults, 2, "table" )
                @data = defaults
                Write( filePath, @Serialize! )

            else
                @data = {}

            return nil

        GetAll: =>
            return @data

        Get: ( key ) =>
            return GetValue( @data, key )

        Set: ( key, value ) =>
            argument( key, 1, "string" )
            SetValue( @data, key, value )
            Create @timer, 1, 1, ->
                @Write!

            return nil

        Write: =>
            AsyncWrite( @filepath, @Serialize! )
            Remove( @timer )
            return nil

        Read: =>
            @data = @Deserialize( Read( @filepath ) )
            return nil

        Serialize: =>
            if @config_type == "yaml"
                return serialize( @data )

            return TableToJSON( @data, true )

        Deserialize: ( str ) =>
            if @config_type == "yaml"
                return deserialize( str )

            return JSONToTable( str, true, true )

    } )

--[[

    Standard SQL library

--]]

if _G.sql

    import SQLError from environment
    import SQLSafe from string
    import sql, pairs from _G
    import Query from sql
    lib = environment.sql

    lib.lastError = lib.LastError = ->
        return sql.m_strError

    escape = lib.escape = lib.Escape = ( str ) ->
        return str == nil and "null" or SQLSafe( str )

    rawQuery = lib.rawQuery = lib.RawQuery = ( str ) ->
        Logger\Debug( "Executing SQL query: " .. str )

        result = Query( str )
        if result == false
            throw SQLError sql.m_strError, nil, nil, 4

        return result

    tableExists = lib.tableExists = lib.TableExists = ( name ) ->
        return rawQuery( "select name from sqlite_master where name=" .. escape( name ) .. " and type='table'" ) and true or false

    lib.IndexExists = lib.IndexExists = ( name ) ->
        return rawQuery( "select name from sqlite_master where name=" .. escape( name ) .. " and type='index'" ) and true or false

    begin = lib.begin = lib.Begin = ->
        rawQuery( "begin" )
        return nil

    commit = lib.commit = lib.Commit = ->
        rawQuery( "commit" )
        return nil

    rollback = lib.rollback = lib.Rollback = ->
        rawQuery( "rollback" )
        return nil

    query = lib.query = lib.Query = ( str, ... ) ->
        args, index = { ... }, 0
        str = gsub( str, "?", ->
            index += 1
            return escape( args[ index ] )
        )

        result = rawQuery( str )

        -- convert NULL values into nil
        if result
            for tbl in *result
                for key, value in pairs( tbl )
                    if value == "NULL"
                        tbl[ key ] = nil

        return result

    queryRow = lib.queryRow = lib.QueryRow = ( str, row = 1, ... ) ->
        result = query( str, ... )
        if result
            return result[ row ]

        return nil

    queryOne = lib.queryOne = lib.QueryOne = ( str, ... ) ->
        return queryRow( str, 1, ... )

    lib.queryValue = lib.QueryValue = ( str, ... ) ->
        result = queryOne( str, ... )
        if result
            return next( result )

        return nil

    lib.transaction = lib.Transaction = ( func ) ->
        begin()

        ok, result = pcall( func )
        if ok
            commit()
            return result

        rollback()
        throw result
        return nil
