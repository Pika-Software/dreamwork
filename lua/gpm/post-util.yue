_G = _G
import environment, Logger from _G.gpm
import getmetatable, setmetatable, istable from _G
import bit, math, string, table, util, ArgAssert, isfunction, error from environment
import band, bor, lshift, rshift from bit
import byte, sub, len from string
import fdiv from math

do

    import CodeCompileError from environment
    local installed

    if util.IsBinaryModuleInstalled( "moonloader" )
        ok, msg = pcall( require, "moonloader" )
        if ok and istable( moonloader )
            Logger\Loaded( "gm_moonloader v%s", moonloader._VERSION )
            installed = true
        else
            Logger\Error( "gm_moonloader startup error: %s", msg or "unknown error" )
            installed = false
    else
        installed = false

    yueFail = ->
        error CodeCompileError "Attempt to compile Yuescript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader."

    if installed
        moonloader = environment.moon = _G.moonloader

        -- Yuescript
        import yue from moonloader

        if istable( yue )
            environment.yue = yue
        else

            environment.yue = {
                ToLua: yueFail
            }

            Logger\Warn( "Yuescript support is missing, yue package execution is unavailable!" )

    else

        moonFail = ->
            error CodeCompileError "Attempt to compile MoonScript failed, install gm_moonloader and try again, https://github.com/Pika-Software/gm_moonloader."

        environment.moon = {
            PreCacheFile: moonFail,
            PreCacheDir: moonFail,
            ToLua: moonFail
        }

        environment.yue = {
            ToLua: yueFail
        }

        Logger\Warn( "gm_moonloader is missing, support for moon and yue scripts is unavailable!" )

do


    -- https://github.com/willox/gmbc
    byteCodeSupported = false
    if util.IsBinaryModuleInstalled( "gmbc" )
        byteCodeSupported = pcall( require, "gmbc" )

    import CompileString, gmbc_load_bytecode, setfenv from _G
    import yue, moon from environment
    import IsBytecode from string

    environment.loadstring = ( code, identifier, handleError = true, ignoreBytecode ) ->
        if not ignoreBytecode and IsBytecode( code )
            if byteCodeSupported
                return gmbc_load_bytecode( code )

            msg = "Bytecode compilation is not supported. Please install gmbc (https://github.com/willox/gmbc)"
            if handleError
                error msg, 2
                return nil

            return msg

        return CompileString( code, identifier, handleError )

    load = ( chunk, chunkName, mode = "bt", env = getfenv( 2 ), config, handleError = true ) ->
        ArgAssert( chunkName, 2, "string" )

        if mode == ""
            mode = "bt"

        switch type( chunk )
            when "string"
                modes = {}
                for byte0 in *{ byte( mode, 1, len( mode ) ) }
                    modes[ byte0 ] = true

                local func
                if modes[ 0x62 --[[ b ]] ] and IsBytecode( chunk )
                    if byteCodeSupported
                        func = gmbc_load_bytecode( chunk )

                    msg = "Bytecode compilation is not supported."
                    if handleError
                        error msg, 2
                        return nil

                    return msg

                if modes[ 0x79 --[[ y ]] ]
                    if config
                        ArgAssert( config, 5, "table" )
                        chunk = yue.ToLua( chunk, config )
                    else
                        chunk = yue.ToLua( chunk )

                elseif modes[ 0x6D --[[ m ]] ]
                    chunk = moon.ToLua( chunk )

                if modes[ 0x74 --[[ t ]] ]
                    func = CompileString( chunk, chunkName, handleError )

                if func
                    if isfunction( func ) and env
                        setfenv( func, env )

                    return func

                msg = "wrong load mode"
                if handleError
                    error msg, 2
                    return nil

                return msg

            when "function"
                result, length = {}, 0

                str = chunk!
                while str
                    length += 1
                    result[ length ] = str
                    str = chunk!

                if length == 0
                    return ->

                return load( concat( result, "", 1, length ), chunkName, mode, env, config, handleError )

        error "Invalid argument #1 to 'load' (string/function expected)", 2
        return nil

    environment.load = load

do

    import Delay, SafeAwait from environment.Promise

    environment.sleep = ( time = 0 ) ->
        ArgAssert( time, 1, "number" )
        SafeAwait( Delay( time ) )
        return nil

table.Flip = ( tbl ) ->
    length = #tbl
    finish = fdiv( length, 2 )
    length += 1

    for index = 1, finish, 1
        tbl[ index ], tbl[ length - index ] = tbl[ length - index ], tbl[ index ]

    return tbl

do

    import struct from environment

    -- lua 5.3 string features
    do

        import Read, Write from struct
        import unpack from table

        string.pack = ( fmt, ... ) ->
            return Write( fmt, { ... } )

        string.unpack = ( fmt, binary, offset ) ->
            if offset
                return unpack( Read( fmt, sub( binary, offset, len( binary ) ) ) )

            return unpack( Read( fmt, binary ) )

        string.packsize = struct.SizeOf

    import io from struct
    import Read from io.i
    import Little from io.endianness

    util.LZMA_PROPS_SIZE = 5

    util.CompressedSize = ( binary ) ->
        if binary == ""
            return 0

        Little!
        return Read( nil, sub( binary, 6, 14 ), 8 )

-- Byte Stream
do

    import struct, deflate, os, Color from environment
    import char, reverse, format from string
    import clamp from math
    import CRC from util
    import io from struct
    import time from os

    dos2unix = os.dos2unix = ( t, d ) ->
        data = { year: 1980, month: 1, day: 1, hour: 0, min: 0, sec: 0 }

        if t
            data.hour = rshift( band( t, 0xF800 ), 11 )
            data.min = rshift( band( t, 0x07E0 ), 5 )
            data.sec = band( t, 0x001F ) * 2

        if d
            data.year += rshift( band( d, 0xFE00 ), 9 )
            data.month = rshift( band( d, 0x01E0 ), 5 )
            data.day = band( d, 0x001F )

        return time( data )

    local unix2dos
    do

        import date from os

        unix2dos = os.unix2dos = ( u ) ->
            data = date( "*t", u )
            return bor( lshift( data.hour, 11 ), lshift( data.min, 5 ), fdiv( data.sec, 2 ) ), bor( lshift( data.year - 1980, 9 ), lshift( data.month, 5 ), data.day )

    local readInt, writeInt
    do
        int = io.i
        readInt, writeInt = int.Read, int.Write

    local readUInt, writeUInt
    do
        uint = io.I
        readUInt, writeUInt = uint.Read, uint.Write

    local readFloat, writeFloat
    do
        float = io.f
        readFloat, writeFloat = float.Read, float.Write

    local readDouble, writeDouble
    do
        double = io.d
        readDouble, writeDouble = double.Read, double.Write

    local readQuad, writeQuad
    do
        quad = io.q
        readQuad, writeQuad = quad.Read, quad.Write

    setEndianness = io.endianness.Set

    noCompression = ( content ) ->
        return content

    compressionMethods = {
        -- No compression
        [ 0 ]: {
            [1]: noCompression,
            [2]: noCompression
        },

        -- Deflate
        [ 8 ]: {
            [1]: deflate.CompressDeflate,
            [2]: deflate.DecompressDeflate
        }
    }

    seek = ( position ) =>
        @Flush!

        if position
            ArgAssert( position, 2, "number" )
            position = clamp( position, 0, @size )
        else
            position = 0

        @position = position
        return position

    util.ByteStream = environment.class(
        "ByteStream",
        {
            __tostring: =>
                return format( "ByteStream: %p [%d/%d]", @, @position, @size )

            IsValid: =>
                return @data ~= nil

            EndOfFile: =>
                return @position >= @size

            Size: =>
                return @size

            Tell: =>
                return @position

            Close: =>
                @Flush!
                @position = 0

            Seek: seek
            SeekTo: seek

            SeekToBegin: =>
                return @Seek( 0 )

            SeekToEnd: =>
                return @Seek( @size - @position )

            SkipEmpty: =>
                while not @EndOfFile!
                    if @ReadByte! ~= 0
                        @Skip( -1 )
                        break

            Skip: ( bytes ) =>
                if bytes
                    ArgAssert( bytes, 2, "number" )
                else
                    bytes = 1

                return @Seek( @position + bytes )

            -- Byte read
            Read: ( bytes ) =>
                :position, :size = @

                if bytes == "*a" or bytes == nil
                    bytes = size

                ArgAssert( bytes, 2, "number" )

                if bytes > 0
                    if position >= size
                        return nil, "eof"

                    return sub( @data, position + 1, @Skip( bytes ) )

                if bytes < 0
                    if position <= 0
                        return nil, "sof"

                    return reverse( sub( @data, position + 1, @Skip( bytes ) ) )

            ReadAll: =>
                @SeekToBegin!
                return @Read( @size )

            -- String
            ReadString: =>
                :position, :size = @
                if position >= size
                    return

                bytes, data = 0, @data
                for index = position, size
                    if byte( data, index + 1 ) == 0
                        break

                    bytes += 1

                if bytes == 0
                    return

                return @Read( bytes ), @Skip( 1 )

            WriteString: ( str ) =>
                ArgAssert( str, 1, "string" )
                return @Write( str .. "\0" )

            -- Line
            ReadLine: =>
                :position, :size = @
                if position >= size
                    return

                bytes, data = 0, @data
                for index = position, size
                    if byte( data, index + 1 ) == 0xA --[[ \n ]]
                        break

                    bytes += 1

                if bytes == 0
                    return "", @Skip( 1 )

                return @Read( bytes ), @Skip( 1 )

            WriteLine: ( str ) =>
                ArgAssert( str, 1, "string" )
                return @Write( str .. "\n" )

            -- Byte
            ReadByte: =>
                if @EndOfFile!
                    return

                return byte( @data, @Skip( 1 ) )

            WriteByte: ( number ) =>
                return @Write( char( number ) )

            -- Boolean
            ReadBool: =>
                switch @ReadByte!
                    when 0
                        return false

                    when 1
                        return true

                return nil

            WriteBool: ( bool ) =>
                return @WriteByte( bool and 1 or 0 )

            -- UInt
            ReadUInt: ( bytes, endianness ) =>
                ArgAssert( bytes, 2, "number", 4 )
                setEndianness( endianness or "little" )
                return readUInt( nil, @Read( bytes ), bytes )

            WriteUInt: ( number, bytes, endianness ) =>
                ArgAssert( number, 1, "number", 4 )
                ArgAssert( bytes, 2, "number", 4 )
                setEndianness( endianness or "little" )
                return @Write( writeUInt( nil, number, bytes ) )

            -- UShort
            ReadUShort: ( endianness ) =>
                return @ReadUInt( 2, endianness )

            WriteUShort: ( number, endianness ) =>
                return @WriteUInt( number, 2, endianness )

            -- ULong
            ReadULong: ( endianness ) =>
                return @ReadUInt( 4, endianness )

            WriteULong: ( number, endianness ) =>
                return @WriteUInt( number, 4, endianness )

            -- UInt64
            ReadUInt64: ( endianness ) =>
                return @ReadUInt( 8, endianness )

            WriteUInt64: ( number, endianness ) =>
                @WriteUInt( number, 8, endianness )

            -- Int
            ReadInt: ( bytes, endianness ) =>
                ArgAssert( bytes, 2, "number", 4 )
                setEndianness( endianness or "little" )
                return readInt( nil, @Read( bytes ), bytes )

            WriteInt: ( number, bytes, endianness ) =>
                ArgAssert( number, 1, "number", 4 )
                ArgAssert( bytes, 2, "number", 4 )
                setEndianness( endianness or "little" )
                return @Write( writeInt( nil, number, bytes ) )

            -- Short
            ReadShort: ( endianness ) =>
                return @ReadInt( 2, endianness )

            WriteShort: ( number, endianness ) =>
                return @WriteInt( number, 2, endianness )

            -- Long
            ReadLong: ( endianness ) =>
                return @ReadInt( 4, endianness )

            WriteLong: ( number, endianness ) =>
                return @WriteInt( number, 4, endianness )

            -- Int64
            ReadInt64: ( endianness ) =>
                return @ReadInt( 8, endianness )

            WriteInt64: ( number, endianness ) =>
                return @WriteInt( number, 8, endianness )

            -- Float
            ReadFloat: ( endianness ) =>
                setEndianness( endianness or "little" )
                return readFloat( nil, @Read( 4 ), 4 )

            WriteFloat: ( number, endianness ) =>
                ArgAssert( number, 2, "number" )
                setEndianness( endianness or "little" )
                return @Write( writeFloat( nil, number, 4 ) )

            -- Double
            ReadDouble: ( endianness ) =>
                setEndianness( endianness or "little" )
                return readDouble( nil, @Read( 8 ), 8 )

            WriteDouble: ( number, endianness ) =>
                ArgAssert( number, 2, "number" )
                setEndianness( endianness or "little" )
                return @Write( writeDouble( nil, number, 8 ) )

            -- Quad
            ReadQuad: ( endianness ) =>
                setEndianness( endianness or "little" )
                return readQuad( nil, @Read( 16 ), 16 )

            WriteQuad: ( number, endianness ) =>
                ArgAssert( number, 2, "number" )
                setEndianness( endianness or "little" )
                return @Write( writeQuad( nil, number, 16 ) )

            -- Time
            ReadTime: =>
                return dos2unix( @ReadUShort!, @ReadUShort! )

            WriteTime: ( u ) =>
                t, d = unix2dos( u )
                @WriteUShort( t )
                return @WriteUShort( d )

            -- ZipFile ( https://medium.com/@felixstridsberg/the-zip-file-format-6c8a160d1c34 )
            ReadZipFile: ( doCRC ) =>
                if @Read( 4 ) ~= "PK\x03\x04"
                    return

                data = {}

                @Skip( 4 )

                compressionMethod = data.compression = @ReadUShort!
                data.time = @ReadTime!

                crc = data.crc = @ReadULong!
                compressedSize = @ReadULong!
                data.size = @ReadULong!

                pathLength = @ReadUShort!
                extraLength = @ReadUShort!

                data.path = @Read( pathLength )
                @Skip( extraLength )

                method = compressionMethods[ compressionMethod ]
                unless method
                    return data, "compression method not supported"

                content = data.content = method[ 2 ]( @Read( compressedSize ) )

                if doCRC and content and crc ~= CRC( content )
                    return data, "crc-32 mismatch"

                return data

            WriteZipFile: ( fileName, content, compressionMethod = 0, unixTime = time! ) =>
                ArgAssert( fileName, 1, "string" )
                ArgAssert( content, 2, "string" )
                ArgAssert( compressionMethod, 3, "number" )
                ArgAssert( unixTime, 4, "number" )

                -- signature
                @Write( "PK\x03\x04" )

                -- Version needed to extract (minimum)
                @WriteUShort( 0 )

                -- General purpose bit flag
                @WriteUShort( 0 )

                method = compressionMethods[ compressionMethod ]
                unless method
                    error "Unsupported compression method: " .. compressionMethod
                    return nil

                -- Compression method
                @WriteUShort( compressionMethod )

                -- Modification time
                @WriteTime( unixTime )

                -- CRC-32
                @WriteULong( tonumber( CRC( content ), 10 ) )
                fileSize = len( content )

                content = method[ 1 ]( content )

                -- Compressed size
                @WriteULong( len( content ) )

                -- Uncompressed size
                @WriteULong( fileSize )

                -- File name length
                @WriteUShort( len( fileName ) )

                -- Extra field length
                @WriteUShort( 0 )

                @Write( fileName )
                return @Write( content )

            -- Color
            ReadColor: =>
                return Color( byte( @Read( 4 ) ) )

            WriteColor: ( color ) =>
                return @Write( char( color.r, color.g, color.b, color.a ) )

        },
        {
            CompressionMethods: compressionMethods
        },
        struct.Cursor
    )

-- Version
do

    import ByteSplit from string

    do

        import URL, isurl from environment
        import concat, Flip from table

        string.PathFromURL = ( url ) ->
            unless isurl( url )
                url = URL( url )

            if url.hostname == ""
                return url.scheme .. url.pathname

            return url.scheme .. "/" .. concat( Flip( ByteSplit( url.hostname, 0x2E --[[ . ]] ) ), "/" ) .. url.pathname

    import isnumber, tonumber, isstring, tostring from _G
    import match, find, gsub, ByteCount from string
    import isuint, max from math
    import sort from table

    compare = ( a, b ) ->
        return a == b and 0 or a < b and -1 or 1

    compareIDs = ( value, value2 ) ->
        if value == value2
            return 0

        unless value
            return -1

        unless value2
            return 1

        number, number2 = tonumber( value ), tonumber( value2 )
        if number and number2
            return compare( number, number2 )

        if number
            return -1

        if number2
            return 1

        return compare( value, value2 )

    smallerPrerelease = ( first, second ) ->
        if not first or first == second
            return false

        unless second
            return true

        fisrt, fcount = ByteSplit( first, 0x2E --[[ . ]] )
        second, scount = ByteSplit( second, 0x2E --[[ . ]] )

        local comparison
        for index = 1, fcount
            comparison = compareIDs( fisrt[ index ], second[ index ] )
            if comparison ~= 0
                return comparison == -1

        return fcount < scount

    parsePrerelease = ( str ) ->
        if str == ""
            return nil

        prelease = match( str, "^-(%w[%.%w-]*)$" )
        if not prelease or match( prelease, "%.%." )
            error "the pre-release '" .. str .. "' is not valid"
            return nil

        return prelease

    parseBuild = ( str ) ->
        if str == ""
            return nil

        build = match( str, "^%+(%w[%.%w-]*)$" )
        if not build or match( build, "%.%." )
            error "the build '" .. str .. "' is not valid"
            return nil

        return build

    parsePrereleaseAndBuild = ( str ) =>
        if not str or str == ""
            return nil

        prerelease, build = match( str, "^(%-[^+]+)(%+.+)$" )
        unless prerelease and build
            switch byte( str, 1 )
                when 0x2d --[[ - ]]
                    prerelease = parsePrerelease( str )

                when 0x2b --[[ + ]]
                    build = parseBuild( str )

                else
                    error "the parameter '" .. str .. "' must begin with + or - to denote a pre-release or a build"
                    return nil

        return prerelease, build

    -- Semver lua parser. Based on https://github.com/kikito/semver.lua
    -- https://github.com/Pika-Software/gpm_legacy/blob/main/lua/gpm/sh_semver.lua
    local Version

    _base_0  = {
        __tostring: =>
            preRelease, build = @prelease, @build
            if preRelease and build
                return @major .. "." .. @minor .. "." .. @patch .. "-" .. preRelease .. "+" .. build

            if preRelease
                return @major .. "." .. @minor .. "." .. @patch .. "-" .. preRelease

            if build
                return @major .. "." .. @minor .. "." .. @patch .. "+" .. build

            return @major .. "." .. @minor .. "." .. @patch

        __eq: ( other ) =>
            return @major == other.major and @minor == other.minor and @patch == other.patch and @prerelease == other.prerelease

        __lt: ( other ) =>
            if @major ~= other.major
                return @major < other.major

            if @minor ~= other.minor
                return @minor < other.minor

            if @patch ~= other.patch
                return @patch < other.patch

            return smallerPrerelease( @prerelease, other.prerelease )

        __pow: ( other ) =>
            if @major == 0
                return @ == other

            return @major == other.major and @minor <= other.minor

        -- This works like 'satisfies' (fuzzy matching) in npm.
        -- https://docs.npmjs.com/cli/v6/using-npm/semver
        -- A version range is a set of comparators which specify versions that satisfy the range.
        -- A comparator is composed of an operator and a version. The set of primitive operators is:
        --   < Less than
        --   <= Less than or equal to
        --   > Greater than
        --   >= Greater than or equal to
        --   = Equal. If no operator is specified, then equality is assumed, so this operator
        --     is optional, but MAY be included.
        -- Comparators can be joined by whitespace to form a comparator set, which is satisfied by
        -- the intersection of all of the comparators it includes.
        -- A range is composed of one or more comparator sets, joined by ||. A version matches
        -- a range if and only if every comparator in at least one of the ||-separated comparator
        -- sets is satisfied by the version.
        -- A 'version' is described by the v2.0.0 specification found at https://semver.org/.
        -- A leading '=' or 'v' character is stripped off and ignored
        __mod: ( str ) =>
            -- version range := comparator sets
            if find( str, "||", 1, true )
                local pos, part
                start = 1

                while true
                    pos = find( str, "||", start, true )
                    part = sub( str, start, pos and ( pos - 1 ) )

                    if @ % part
                        return true

                    unless pos
                        return false

                    start = pos + 2

            -- comparator set := comparators
            str = gsub( gsub( gsub( str, "%s+", " " ), "^%s+", "" ), "%s+$", "" )

            if find( str, " ", 1, true )
                local pos, part
                start = 1

                while true
                    pos = find( str, " ", start, true )
                    part = sub( str, start, pos and ( pos - 1 ) )

                    -- Hyphen Ranges: X.Y.Z - A.B.C
                    -- https://docs.npmjs.com/cli/v6/using-npm/semver#hyphen-ranges-xyz---abc
                    if pos and sub( str, pos, pos + 2 ) == " - "
                        unless @ % ( ">=" .. part )
                            return false

                        start = pos + 3
                        pos = find( str, " ", start, true )
                        part = sub( str, start, pos and ( pos - 1 ) )

                        unless @ % ( "<=" .. part )
                            return false

                    elseif not ( @ % part )
                        return false

                    unless pos
                        return true

                    start = pos + 1

                return true

            -- comparators := operator + version
            str = gsub( gsub( str, "^=", "" ), "^v", "" )

            -- X-Ranges *
            -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
            if str == "" or str == "*"
                return @ % ">=0.0.0"

            pos = find( str, "%d" )
            unless pos
                error "Version range must starts with number: " .. str
                return nil

            -- X-Ranges 1.2.x 1.X 1.2.*
            -- Any of X, x, or * may be used to 'stand in' for one of the numeric values in the [major, minor, patch] tuple.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#x-ranges-12x-1x-12-
            local operator
            if pos == 1
                operator = "="
            else
                operator = sub( str, 1, pos - 1 )

            version = gsub( sub( str, pos ), "%.[xX*]", "" )
            xrange = max( 2 - ByteCount( version, 0x2e --[[ . ]] ), 0 )

            for i = 1, xrange
                version = version .. ".0"

            sv = Version( version )
            if operator == "<"
                return @ < sv

            -- primitive operators
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#ranges
            if operator == "<="
                if xrange > 0
                    if xrange == 1
                        sv = sv\nextMinor!
                    elseif xrange == 2
                        sv = sv\nextMajor!

                    return @ < sv

                return @ <= sv

            if operator == ">"
                if xrange > 0
                    if xrange == 1
                        sv = sv\nextMinor!
                    elseif xrange == 2
                        sv = sv\nextMajor!

                    return @ >= sv

                return @ > sv

            if operator == ">="
                return @ >= sv

            if operator == "="
                if xrange > 0
                    if @ < sv
                        return false

                    if xrange == 1
                        sv = sv\nextMinor!
                    elseif xrange == 2
                        sv = sv\nextMajor!

                    return @ < sv

                return @ == sv

            -- Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4
            -- Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple.
            -- In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for
            -- versions 0.X >=0.1.0, and no updates for versions 0.0.X.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#caret-ranges-123-025-004
            if operator == "^"
                if sv.major == 0 and xrange < 2
                    if sv.minor == 0 and xrange < 1
                        return @major == 0 and @minor == 0 and @ >= sv and @ < sv\nextPatch!

                    return @major == 0 and @ >= sv and @ < sv\nextMinor!

                return @major == sv.major and @ >= sv and @ < sv\nextMajor!

            -- Tilde Ranges ~1.2.3 ~1.2 ~1
            -- Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not.
            -- https://docs.npmjs.com/cli/v6/using-npm/semver#tilde-ranges-123-12-1
            if operator == "~"
                if @ < sv
                    return false

                if xrange == 2
                    return @ < sv\nextMajor!

                return @ < sv\nextMinor!

            error "Invaild operator: '" .. operator .. "'"
            return nil

        nextMajor: =>
            return Version( @major + 1, 0, 0 )

        nextMinor: =>
            return Version( @major, @minor + 1, 0 )

        nextPatch: =>
            return Version( @major, @minor, @patch + 1 )

        toNumber: =>
            major = tonumber( @major )
            if major > 0x3ff
                error "major version is too large (max 1023)"
                return nil

            minor = tonumber( @minor )
            if minor > 0x7ff
                error "minor version is too large (max 2047)"
                return nil

            patch = tonumber( @patch )
            if patch > 0x7ff
                error "patch version is too large (max 2047)"
                return nil

            return bor( lshift( patch, 21 ), lshift( minor, 10 ), major )
    }

    _base_0.__index = _base_0

    Version = {
        __base: _base_0
        __name: "Version"
        __init: ( major, minor, patch, prerelease, build ) =>
            unless major
                error "at least one parameter is needed"
                return nil

            if isnumber( major )
                unless isuint( major )
                    error "major version must be unsigned integer"
                    return nil

                @major = major

                if minor
                    unless isnumber( minor )
                        error "minor version must be a number"

                    unless isuint( minor )
                        error "minor version must be unsigned integer"

                @minor = minor or 0

                if patch
                    unless isnumber( patch )
                        error "patch version must be a number"

                    unless isuint( patch )
                        error "patch version must be unsigned integer"

                @patch = patch or 0

                if isstring( build )
                    if isstring( prerelease )
                        @prelease = parsePrerelease( prerelease )

                    @build = parseBuild( build )
                elseif isnumber( prerelease )
                    @prelease, @build = parsePrereleaseAndBuild( prerelease )

                return nil

            str = tostring( major )

            major, minor, patch, extra = match( str, "^(%d+)%.?(%d*)%.?(%d*)(.-)$" )
            unless major
                error "the major version of '" .. str .. "' is missing"
                return nil

            @prelease, @build = parsePrereleaseAndBuild( extra )

            if minor == ""
                minor = "0"

            if patch == ""
                patch = "0"

            @major = tonumber( major )
            @minor = tonumber( minor )
            @patch = tonumber( patch )
            return nil

        fromNumber: ( uint ) ->
            return Version( band( uint, 0x3ff ), band( rshift( uint, 10 ), 0x7ff ), band( rshift( uint, 21 ), 0x7ff ) )

        select: ( target, versions ) ->
            sort( versions, ( a, b ) -> a > b )

            for index = 1, #versions
                version = Version( versions[ index ] )
                if version % target
                    return version, index

            return nil, -1
    }

    versions = {}

    util.Version = _base_0.__class = setmetatable( Version, {
        __index: _base_0,
        __call: ( cls, ... ) ->
            obj = setmetatable( {}, _base_0 )
            cls.__init( obj, ... )

            existing = versions[ obj\__tostring! ]
            if existing
                return existing

            versions[ obj\__tostring! ] = obj
            return obj
    } )
