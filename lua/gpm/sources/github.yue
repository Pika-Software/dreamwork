-- Seconds iteration of github source handler
import path, string, table, http, util, loader, file, addon from gpm -- libraries
import isstring, istable, isurl, tostring, async, await, pairs from gpm -- functions
import URL, Package, SourceError, Logger from gpm -- classes

-- TODO: Create GithubAPI class to handle requests

-- url syntax: github:user/repo[/branch]
-- github://[apiToken@]user/repo[/branch]
class GithubSource extends loader.Source
    APIRequest = ( url, ... ) ->
        args = { ... }
        parts = string.IsURL( url ) and { url } or { "https://api.github.com", url }
        headers = { "Accept": "application/vnd.github+json", "X-GitHub-Api-Version": "2022-11-28" }
        for arg in *{ ... }
            if isstring( arg )
                parts[] = arg
            elseif istable( arg )
                table.Merge( headers, arg )

        url = table.concat( parts, "/" )
        
        res = await http.CachedFetch( url, headers )
        if res.status == 200
            data = util.JSONToTable( res.body )
            unless data
                error SourceError "Failed to parse JSON response from #{url}."
            
            return data
        
        error SourceError "Failed to fetch #{url} (#{res.status})."

    GetDefaultBranch = ( user, repository, auth ) ->
        res = APIRequest( "repos", user, repository, auth ) -- GET /repos/:owner/:repo
        return res.default_branch

    -- pattern: priority
    PACKAGE_PATH_PRIORITIES = {
        "^package%..+$": 10
        "package.yue": 11
        "package.moon": 12
        "package.lua": 15
        "package%..+": 20
    }

    FindPackageInfo = ( user, repository, branch, auth ) ->
        -- you might say, why recursive? well, github api rate limits us to 60 requests per hour, so we need to minimize them
        res = APIRequest( "repos", user, repository, "git", "trees", branch .. "?recursive=1", auth ) -- GET /repos/:owner/:repo/git/trees/:tree_sha
        
        entries = []
        for entry in *res.tree
            if entry.type == "blob" and string.match( entry.path, "package%..+$" )
                entries[] = entry

        if #entries == 1
            return entries[1]
        
        -- welp, we have multiple package.lua files, lets try to find the correct one
        priority = math.huge -- 0 is the highest priority
        package_entry = nil
        for entry in *entries
            for pattern, p in pairs PACKAGE_PATH_PRIORITIES
                if string.match( entry.path, pattern )
                    if pattern == entry.path
                        p = p - 10 -- paths that match the exact pattern are more important
                    
                    if p < priority
                        priority = p
                        package_entry = entry
                    
                    -- TODO: check if we have duplicates (i.e packages/a/package.lua and packages/b/package.lua)

        return package_entry

    FetchFile = ( entry, auth ) ->
        res = APIRequest( entry.url, auth ) -- GET /repos/:owner/:repo/git/blobs/:file_sha
        return {
            data: util.Base64Decode( res.content )
            size: res.size
            path: entry.path
        }

    FetchInfo: async ( url ) =>
        segments = string.ByteSplit( url.pathname, 0x2F --[[ / ]] )
        if hostname := url.hostname
            insert( segments, 1, hostname )

        user = segments[ 1 ]
        repository = segments[ 2 ]
        unless user and user != "" and repository and repository != ""
            error SourceError "Invalid url '#{url}' (missing user or repository, got '#{user}' and '#{repository}')."
        
        auth = nil
        if url.username or url.password
            auth = { "Authorization": "Bearer " .. ( url.username or "" ) .. ( url.password or "" ) }

        Logger\Debug( "Fetching information for Github repository '%s'...", table.concat(segments, "/") )
        branch = segments[ 3 ] or GetDefaultBranch( user, repository, auth )
        unless branch
            error SourceError "Failed to get default branch for '#{user}/#{repository}'."

        package_entry = FindPackageInfo( user, repository, branch, auth )
        unless package_entry
                    error SourceError "Failed to find package file in #{user}/#{repository} (#{branch})."

        res = FetchFile( package_entry, auth )
        packageURL = URL( path.getFile( res.path ), @WorkingDirectory( url ) )
        file.Set( packageURL.pathname, res.data ) -- TODO: prevent overwriting existing files

        pkg = await Package.read( packageURL )
        unless pkg
            error SourceError "Failed to read package file from #{packageURL}. (url = #{url})"
        
        return {
            package: pkg,
            url: url,
            metadata: {
                user: user,
                repository: repository,
                branch: branch,
                auth: auth,
                package_entry: package_entry
            }
        }

    Install: async ( info, workdir ) =>
        unless workdir
            workdir = @WorkingDirectory( info.url ).pathname

        Logger\Debug( "Installing package '%s@%s' from Github repository '%s/%s/%s'...", info.package.name, info.package.version, info.metadata.user, info.metadata.repository, info.metadata.branch )

        -- TODO: cache files

        res = await http.CachedFetch("https://api.github.com/repos/#{info.metadata.user}/#{info.metadata.repository}/zipball/#{info.metadata.branch}", info.metadata.auth)
        if res.status != 200
            error SourceError "Failed to fetch zipball from Github repository '#{info.metadata.user}/#{info.metadata.repository}/#{info.metadata.branch}' (#{res.status})."

        root = path.getDirectory( info.metadata.package_entry.path )
        rootLength = #root + 1 -- +1 to remove the trailing slash

        gma = addon.GMA()
        gma\SetTitle( info.url.href )

        for entry, err in file.IterateZipFiles( util.ByteStream(res.body), false ) -- entry: { path, content }
            if err
                Logger\Debug( "Skipping file from zipball '%s/%s/%s' with path '%s' and reason '%s'", info.metadata.user, info.metadata.repository, info.metadata.branch, entry.path, err )
                continue
            
            -- first remove first directory from the path (appended by github)
            entryPath = string.sub( entry.path, string.indexOf(entry.path, "/") + 1 )

            -- then remove the root directory
            entryPath = string.sub( entryPath, rootLength ) -- TODO: check if string is even valid
            if entryPath == ""
                continue

            -- add working directory
            entryPath = path.join( workdir, entryPath )

            gma\SetFile( entryPath, entry.content )

        await gma\AsyncMount()


GithubSource( "github" )
