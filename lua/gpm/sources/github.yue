_G = _G
import gpm from _G
import environment from gpm
import await, async, load, SourceError, ModuleError, error, isstring from environment
import BaseSource, BaseSourceHandler, Module from gpm.loader
import Base64Decode, JSONToTable from environment.util
import MountZIPData from environment.file
import getExtension from environment.path
import CachedFetch from environment.http
import ByteSplit from environment.string
import insert from environment.table

class RepositoryHandler extends BaseSourceHandler
    FetchInfo: async ( url ) =>
        segments = url.path
        if isstring( segments )
            segments = ByteSplit( segments, 0x2F --[[ / ]] )

        if url.hostname
            insert( segments, 1, url.hostname )

        user = segments[ 1 ]
        unless user
            error SourceError "Repository user not specified."
            return nil

        repository = segments[ 2 ]
        unless repository
            error SourceError "Repository name not specified."
            return nil

        headers = {}
        if url.username or url.password
            headers[ "Authorization" ] = "Bearer " .. ( url.username or "" ) .. ( url.password or "" )

        url.username = nil
        url.password = nil

        branch = segments[ 3 ]
        if not branch or branch == ""
            response = await CachedFetch( "https://api.github.com/repos/" .. user .. "/" .. repository, headers )
            if response.status ~= 200
                json = JSONToTable( response.body )
                error SourceError json and json.message or "Failed to fetch repository info."
                return nil

            json = JSONToTable( response.body )
            unless json
                error SourceError "Unable to parse JSON response."
                return nil

            branch = json.default_branch
            unless branch
                error SourceError "Failed to fetch repository default branch."
                return nil

            segments[ 3 ] = branch

        response = await CachedFetch( "https://api.github.com/repos/" .. user .. "/" .. repository .. "/git/trees/" .. branch, headers )
        if response.status ~= 200
            json = JSONToTable( response.body )
            error SourceError json and json.message or "Failed to fetch repository info."
            return nil

        info = JSONToTable( response.body )
        unless info
            error SourceError "Unable to parse JSON response."
            return nil

        if #segments > 3
            path = {}
            for i = 4, #segments
                path[ i - 3 ] = segments[ i ]

            info.path = path

        info.repository = repository
        info.headers = headers
        info.branch = branch
        info.user = user
        return info

    Install: async ( url, info, _, env ) =>
        unless info.path
            response = await CachedFetch( "https://api.github.com/repos/" .. info.user .. "/" .. info.repository .. "/zipball/" .. info.branch, info.headers )
            if response.status ~= 200
                error SourceError "Failed to download the repository."
                return nil

            return MountZIPData( response, url.href )

        :path = info
        pathStart, pathEnd = 1, #path
        currentPath = ""

        :tree = info
        ::tree::

        treeLength = #tree

        for i = pathStart, pathEnd
            fileName = path[ i ]

            if currentPath == ""
                currentPath = fileName
            else
                currentPath ..= "/" .. fileName

            for j = 1, treeLength
                item = tree[ j ]
                if item.path == fileName
                    if item.type == "tree"
                        response = await CachedFetch( item.url, info.headers )
                        if response.status ~= 200
                            json = JSONToTable( response.body )
                            error SourceError json and json.message or "Failed to resolve repository path."
                            return nil

                        json = JSONToTable( response.body )
                        unless json
                            error SourceError "Unable to parse JSON response."
                            return nil

                        tree = json.tree
                        pathStart += 1
                        goto tree

                    elseif item.type == "blob"
                        if i ~= pathEnd
                            error SourceError "Can't download the blob file in the middle of the path."
                            return nil

                        response = await CachedFetch( item.url, info.headers )
                        if response.status ~= 200
                            json = JSONToTable( response.body )
                            error SourceError json and json.message or "Failed to get repository file."
                            return nil

                        json = JSONToTable( response.body )
                        unless json
                            error SourceError "Unable to parse JSON response."
                            return nil

                        :content = json

                        switch json.encoding
                            when "base64"
                                content = Base64Decode( content )

                        config = {}
                        for key, value in url.searchParams\iterator!
                            config[ key ] = value

                        -- Optimize compilation?
                        extension = getExtension( currentPath, false )

                        if extension == "lua"
                            func = load( content, await( Module.cache( url, content ) ), "t", env, config, false )
                            if func
                                if isstring( func )
                                    error ModuleError func
                                    return nil

                                return Module.run( func, url, env )

                            error ModuleError "File '" .. url.href .. "' cannot be compiled."
                            return nil

                        if extension == "luac" or extension == "lc"
                            func = load( content, await( Module.cache( url, content ) ), "bt", env, config, false )
                            if func
                                if isstring( func )
                                    error ModuleError func
                                    return nil

                                return Module.run( func, url, env )

                            error ModuleError "File '" .. url.href .. "' cannot be compiled."
                            return nil

                        if extension == "moon"
                            func = load( content, await( Module.cache( url, content ) ), "mt", env, config, false )
                            if func
                                if isstring( func )
                                    error ModuleError func
                                    return nil

                                return Module.run( func, url, env )

                            error ModuleError "File '" .. url.href .. "' cannot be compiled."
                            return nil

                        if extension == "yue"
                            func = load( content, await( Module.cache( url, content ) ), "yt", env, config, false )
                            if func
                                if isstring( func )
                                    error ModuleError func
                                    return nil

                                return Module.run( func, url, env )

                            error ModuleError "File '" .. url.href .. "' cannot be compiled."
                            return nil

                        if extension == "json"
                            return JSONToTable( content, true, false )

                        return content

                    break

            if i == pathEnd
                error SourceError "Couldn't find `" .. currentPath .. "` in " .. info.user .. "/" .. info.repository .. " (" .. info.branch .. ")."
                return nil

        error SourceError "Invalid path: " .. currentPath
        return nil

class RepositorySource extends BaseSource

gh = RepositorySource( "github" )
gh\RegisterHandler( RepositoryHandler! )
