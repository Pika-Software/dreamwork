-- Seconds iteration of github source handler
import path, string, table, http, util, loader, file, addon from gpm -- libraries
import isstring, istable, isurl, tostring, async, await, pairs from gpm -- functions
import URL, Package, SourceError, Logger, github from gpm -- classes

-- TODO: Create GithubAPI class to handle requests

-- url syntax: github:user/repo[/branch]
-- github://[apiToken@]user/repo[/branch]
class GithubSource extends loader.Source
    -- pattern: priority
    PACKAGE_PATH_PRIORITIES = {
        "^package%..+$": 10
        "package.yue": 11
        "package.moon": 12
        "package.lua": 15
        "package%..+": 20
    }

    FindPackageInfo = ( user, repository, tree_sha ) ->
        -- you might say, why recursive? well, github api rate limits us to 60 requests per hour, so we need to minimize them
        res = await github.getTree( user, repository, tree_sha, true )
        
        entries = []
        for entry in *res.tree
            if entry.type == "blob" and string.match( entry.path, "package%..+$" )
                entries[] = entry

        if #entries == 1
            return entries[1]
        
        -- welp, we have multiple package.lua files, lets try to find the correct one
        priority = math.huge -- 0 is the highest priority
        package_entry = nil
        for entry in *entries
            for pattern, p in pairs PACKAGE_PATH_PRIORITIES
                if string.match( entry.path, pattern )
                    if pattern == entry.path
                        p = p - 10 -- paths that match the exact pattern are more important
                    
                    if p < priority
                        priority = p
                        package_entry = entry
                    
                    -- TODO: check if we have duplicates (i.e packages/a/package.lua and packages/b/package.lua)

        return package_entry

    FetchInfo: async ( url ) =>
        segments = string.ByteSplit( url.pathname, 0x2F --[[ / ]] )
        if hostname := url.hostname
            insert( segments, 1, hostname )

        user = segments[ 1 ]
        repository = segments[ 2 ]
        unless user and user != "" and repository and repository != ""
            error SourceError "Invalid url '#{url}' (missing user or repository, got '#{user}' and '#{repository}')."

        Logger\Debug( "Fetching information for Github repository '%s'...", table.concat(segments, "/") )
        branch = segments[ 3 ] or github.getRepository( user, repository )\await().default_branch
        unless branch
            error SourceError "Failed to get default branch for '#{user}/#{repository}'."

        -- first letÃ¤s try to find file locally
        workdir = @WorkingDirectory( url )
        pkg = await Package.read( url )
        if pkg
            return {
                package: pkg,
                url: url,
                -- no metadata indicates that the package is locally installed
            }

        package_entry = FindPackageInfo( user, repository, branch )
        unless package_entry
            error SourceError "Failed to find package file in #{user}/#{repository} (#{branch})."

        res = await github.getBlob( user, repository, package_entry.sha )
        packageURL = URL( path.getFile( package_entry.path ), workdir )
        file.Set( packageURL.pathname, res.content ) -- TODO: prevent overwriting existing files

        pkg = await Package.read( packageURL )
        unless pkg
            error SourceError "Failed to read package file from #{packageURL}. (url = #{url})"
        
        return {
            package: pkg,
            url: url,
            metadata: {
                user: user,
                repository: repository,
                branch: branch,
                auth: auth,
                package_entry: package_entry
            }
        }

    Install: async ( info, workdir ) =>
        unless workdir
            workdir = @WorkingDirectory( info.url ).pathname

        unless info.metadata
            -- TODO: if workdir is set, 
            return -- package is already installed

        Logger\Debug( "Installing package '%s@%s' from Github repository '%s/%s/%s'...", info.package.name, info.package.version, info.metadata.user, info.metadata.repository, info.metadata.branch )

        -- TODO: cache files

        res = await http.CachedFetch("https://api.github.com/repos/#{info.metadata.user}/#{info.metadata.repository}/zipball/#{info.metadata.branch}", info.metadata.auth)
        if res.status != 200
            error SourceError "Failed to fetch zipball from Github repository '#{info.metadata.user}/#{info.metadata.repository}/#{info.metadata.branch}' (#{res.status})."

        root = path.getDirectory( info.metadata.package_entry.path )
        rootLength = #root + 1 -- +1 to remove the trailing slash

        gma = addon.GMA()
        gma\SetTitle( info.url.href )

        for entry, err in file.IterateZipFiles( util.ByteStream(res.body), false ) -- entry: { path, content }
            if err
                Logger\Debug( "Skipping file from zipball '%s/%s/%s' with path '%s' and reason '%s'", info.metadata.user, info.metadata.repository, info.metadata.branch, entry.path, err )
                continue
            
            -- first remove first directory from the path (appended by github)
            entryPath = string.sub( entry.path, string.indexOf(entry.path, "/") + 1 )

            -- then remove the root directory
            entryPath = string.sub( entryPath, rootLength ) -- TODO: check if string is even valid
            if entryPath == ""
                continue

            -- add working directory
            entryPath = path.join( workdir, entryPath )

            gma\SetFile( entryPath, entry.content )

        await gma\AsyncMount( nil, true )


GithubSource( "github" )
