import gpm from _G
import environment from gpm
import await, async, SourceError, ModuleError, error from environment
import Base64Decode, JSONToTable, CompileLuaString, CompileMoonString, CompileYueString from environment.util
import BaseSource, BaseSourceHandler, Module from gpm.loader
import MountZIPData from environment.file
import CachedFetch from environment.http
import extname from environment.path
import insert from environment.table

class RepositoryHandler extends BaseSourceHandler
    FetchInfo: async ( url ) =>
        segments = url.path
        if url.hostname
            insert( segments, 1, url.hostname )

        user = segments[ 1 ]
        unless user
            error SourceError "Repository user not specified."
            return nil

        repository = segments[ 2 ]
        unless repository
            error SourceError "Repository name not specified."
            return nil

        headers = {
            ["Authorization"]: "Bearer " .. ( url.username or "" ) .. ( url.password or "" )
        }

        url.username = nil
        url.password = nil

        branch = segments[ 3 ]
        if not branch or branch == ""
            response = await CachedFetch( "https://api.github.com/repos/" .. user .. "/" .. repository, headers )
            if response.status ~= 200
                json = JSONToTable( response.body )
                error SourceError json and json.message or "Failed to fetch repository info."
                return nil

            json = JSONToTable( response.body )
            unless json
                error SourceError "Unable to parse JSON response."
                return nil

            branch = json.default_branch
            unless branch
                error SourceError "Failed to fetch repository default branch."
                return nil

            segments[ 3 ] = branch

        response = await CachedFetch( "https://api.github.com/repos/" .. user .. "/" .. repository .. "/git/trees/" .. branch, headers )
        if response.status ~= 200
            json = JSONToTable( response.body )
            error SourceError json and json.message or "Failed to fetch repository info."
            return nil

        info = JSONToTable( response.body )
        unless info
            error SourceError "Unable to parse JSON response."
            return nil

        if #segments > 3
            path = {}
            for i = 4, #segments
                path[ i - 3 ] = segments[ i ]

            info.path = path

        info.repository = repository
        info.headers = headers
        info.branch = branch
        info.user = user
        return info

    Install: async ( url, info, _, env ) =>
        unless info.path
            response = await CachedFetch( "https://api.github.com/repos/" .. info.user .. "/" .. info.repository .. "/zipball/" .. info.branch, info.headers )
            if response.status ~= 200
                error SourceError "Failed to download the repository."
                return nil

            return MountZIPData( response, url.href )

        :path = info
        pathStart, pathEnd = 1, #path
        currentPath = ""

        :tree = info
        ::tree::

        treeLength = #tree

        for i = pathStart, pathEnd
            fileName = path[ i ]

            if currentPath == ""
                currentPath = fileName
            else
                currentPath ..= "/" .. fileName

            for j = 1, treeLength
                item = tree[ j ]
                if item.path == fileName
                    if item.type == "tree"
                        response = await CachedFetch( item.url, info.headers )
                        if response.status ~= 200
                            json = JSONToTable( response.body )
                            error SourceError json and json.message or "Failed to resolve repository path."
                            return nil

                        json = JSONToTable( response.body )
                        unless json
                            error SourceError "Unable to parse JSON response."
                            return nil

                        tree = json.tree
                        pathStart += 1
                        goto tree

                    elseif item.type == "blob"
                        if i ~= pathEnd
                            error SourceError "Can't download the blob file in the middle of the path."
                            return nil

                        response = await CachedFetch( item.url, info.headers )
                        if response.status ~= 200
                            json = JSONToTable( response.body )
                            error SourceError json and json.message or "Failed to get repository file."
                            return nil

                        json = JSONToTable( response.body )
                        unless json
                            error SourceError "Unable to parse JSON response."
                            return nil

                        :content = json

                        switch json.encoding
                            when "base64"
                                content = Base64Decode( content )

                        -- Optimize compilation?
                        switch extname( currentPath )
                            when "lua"
                                func = await CompileLuaString( content, url.href, true, false )
                                unless func
                                    error ModuleError "File '" .. url.href .. "' cannot be compiled."
                                    return nil

                                return Module.run( func, url, env )

                            when "moon"
                                func = await CompileMoonString( content, url.href, true )
                                unless func
                                    error ModuleError "File '" .. url.href .. "' cannot be compiled."
                                    return nil

                                return Module.run( func, url, env )

                            when "yue"
                                yueConfig = {}
                                for key, value in url.searchParams\iterator!
                                    yueConfig[ key ] = value

                                func = await CompileYueString( content, url.href, true, yueConfig )
                                unless func
                                    error ModuleError "File '" .. url.href .. "' cannot be compiled."
                                    return nil

                                return Module.run( func, url, env )

                            when "json"
                                return JSONToTable( content, true, false )

                        return content

                    break

            if i == pathEnd
                error SourceError "Couldn't find `" .. currentPath .. "` in " .. info.user .. "/" .. info.repository .. " (" .. info.branch .. ")."
                return nil

        error SourceError "Invalid path: " .. currentPath
        return nil

class RepositorySource extends BaseSource

gh = RepositorySource( "github" )
gh\RegisterHandler( RepositoryHandler! )
