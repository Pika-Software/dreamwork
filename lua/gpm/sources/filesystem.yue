gpm = gpm
:Promise, :BaseSource, :BaseSourceHandler, :SourceError, :GMAD, :ByteStream, :util, :fs = gpm
:async, :await = Promise

--[[

    Handler List:
    [  ] file://data/my_gma.gma ( gma, zip, lua, moon, yue )
    [  ] module://module_name ( binarry or lua modules )
    [  ] lua://my_addon/init.lua ( lua, moon, yue )
    [  ] package://package_name ( package from lua/packages folder )

    Single File Package:
        lua://packages/pkg1.lua

    Multi-File Package:
        lua://packages/pkg2
            ||
            ||
            package.lua
                ||
                ||
                init.lua

]]

class FileHandler extends BaseSourceHandler
    SupportedExtensions: {
        "moon": true
        "yue": true
        "lua": true
        "zip": true
        "gma": true
    }

    ShouldHandle: ( url ) =>
        if string.StartsWith( url, "file://" )
            extension = string.GetExtensionFromFilename( url )
            if extension and @SupportedExtensions[ extension ]
                return true
        return false

    FetchInfo: async ( url ) =>
        filePath = string.gsub( url, "^.-://", "" )
        switch string.GetExtensionFromFilename( filePath )
            when "gma"
                return {}
            when "zip"
                return {}
            when "lua"
                return {}
            when "zip"
                return {}
            when "moon"
                return {}
            when "yue"
                return {}

class ModuleHandler extends BaseSourceHandler
    ShouldHandle: ( url ) => string.StartsWith( url, "module://" )

    FetchInfo: async ( url ) =>
        moduleName = string.gsub( url, "^.-://", "" )
        return {
            "name": moduleName
            "type": util.IsBinaryModuleInstalled( moduleName ) and "binary" or "lua"
        }


class LuaHandler extends BaseSourceHandler
    ShouldHandle: (url) => string.StartsWith url, "lua://"

    FindPackageLua: (path) ->
        if string.EndsWith path, "package.lua"
            return path
        path ..= "package.lua" -- path.join here
        return file.Exists( path ) and path

    FetchInfo: async (url) =>
        path = string.gsub url, "^.-://", ""
        package_lua_path = LuaHandler.FindPackageLua path
        if package_lua_path
            env = {}
            env.dir = dir -- We are assigning here, so package.lua can define custom directory

            func = CompileFile package_info_path
            unless func then error SourceError "Failed to compile package info file: #{package_info_path}"

            await Promise.delay 1

            setfenv func, env
            unless success, reason = try func!
                error SourceError reason

            return env
        elseif string.EndsWith path, ".lua"
            dir = path -- extreact dir from path
            -- Make stub env
            env = {}
            env.name = "unknown" -- get name from path
            env.dir = dir --

            return env
        else
            return @FetchInfo "lua://#{path}.lua"

class PackageHandler extends BaseSourceHandler
    ShouldHandle: (url) => string.StartsWith( url, "package://" )
    FetchInfo: async ( url ) => gpm.FetchInfo( "lua://packages/" .. string.gsub( url, "^.-://", "" ) )

class FilesystemSource extends BaseSource

fs = FilesystemSource!
fs\RegisterHandler FileHandler!
fs\RegisterHandler ModuleHandler!
fs\RegisterHandler LuaHandler!
fs\RegisterHandler PackageHandler!

gpm.RegisterSource( "file", fs )
gpm.RegisterSource( "module", fs )
gpm.RegisterSource( "lua", fs )
gpm.RegisterSource( "package", fs )
