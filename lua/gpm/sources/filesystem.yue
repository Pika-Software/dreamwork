_G = _G
import gpm from _G
import environment from gpm
import file, path, async, await, ModuleError, MountError, SourceError, error from environment
import BaseSource, BaseSourceHandler, Module from gpm.loader
import STATE_PENDING from environment.Promise
import AsyncRead, NormalizeGamePath from file
import getExtension, equal from path

do

    import IsBinaryModuleInstalled from environment.util
    import require from _G

    class BinarySourceHandler extends BaseSourceHandler
        Install: async ( url ) =>
            name = url.pathname
            if not name or name == ""
                error SourceError "Binary module name is not specified!"
                return

            unless IsBinaryModuleInstalled( name )
                error SourceError "Binary module " .. name .. " is not installed locally!"
                return

            require( name )
            return _G[ name ]

    class BinarySource extends BaseSource

    BinarySource( "dll" )\RegisterHandler( BinarySourceHandler! )

do

    import File from environment.addon

    class GMAHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            return getExtension( url.pathname ) == "gma"

        Install: async ( url ) =>
            f = File!
            await f\AsyncRead( url.pathname, true, true )
            -- f\SetTitle( url.href )
            unless f\VerifyCRC!
                error SourceError "Invalid CRC checksum for '" .. url.href .. "'"

            return f\AsyncMount( false )

    local ZIPHandler
    do

        import MountZIP from file

        promises = {}

        mountZip = ( filePath ) ->
            promise = promises[ filePath ]
            if promise and promise.state == STATE_PENDING
                return promise

            filePath, gamePath = NormalizeGamePath( filePath, gamePath )
            promise = MountZIP( filePath, gamePath, true )
            promises[ filePath ] = promise
            return promise

        class ZIPHandler extends BaseSourceHandler
            ShouldHandle: ( url ) =>
                return getExtension( url.pathname ) == "zip"

            Install: async ( url ) =>
                return mountZip( url.pathname )

    local LuaHandler
    do

        import yue, moon, load from environment
        import stripExtension from path
        import sub from _G.string
        import IsFile from file

        promises = {}

        codeCompile = async ( url ) ->
            filePath, gamePath = NormalizeGamePath( url.pathname )
            filePath, extension = stripExtension( filePath )

            if IsFile( filePath .. ".yue", gamePath, true )
                extension = "yue"
            elseif IsFile( filePath .. ".moon", gamePath, true )
                extension = "moon"
            elseif IsFile( filePath .. ".luac", gamePath, true )
                extension = "luac"
            elseif IsFile( filePath .. ".lc", gamePath, true )
                extension = "lc"

            chunk = await AsyncRead( filePath .. "." .. extension, gamePath, true )

            mode = "t"
            if extension == "yue"
                config = {}
                for key, value in url.searchParams\iterator!
                    config[ key ] = value

                chunk = yue.ToLua( chunk, config )

            elseif extension == "moon"
                chunk = moon.ToLua( chunk )

            elseif extension == "luac" or extension == "lc"
                mode = "b" .. mode

            return {
                name: sub( await( Module.cache( url, chunk ) ), 2 ),
                :chunk,
                :mode
            }

        compile = ( url ) ->
            promise = promises[ url.href ]
            if promise and promise.state == STATE_PENDING
                return promise

            promise = codeCompile( url )
            promises[ url.href ] = promise
            return promise

        class LuaHandler extends BaseSourceHandler
            ShouldHandle: ( url ) =>
                return equal( sub( url.pathname, 1, 5 ), "/lua/" )

            Install: async ( url, _, __, env ) =>
                result = await compile( url )

                func = load( result.chunk, result.name, result.mode, env, nil, false )
                if func
                    if isstring( func )
                        error ModuleError func
                        return nil

                    return Module.run( func, url, env )

                error ModuleError "File '" .. url.pathname .. "' cannot be compiled."
                return nil

    class FileSource extends BaseSource

    fs = FileSource( "file" )
    fs\RegisterHandler( LuaHandler! )
    fs\RegisterHandler( ZIPHandler! )
    fs\RegisterHandler( GMAHandler! )
