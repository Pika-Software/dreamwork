_G = _G
import gpm, error from _G
import environment from gpm

import file, async, await, ModuleError, MountError, SourceError from environment
import BaseSource, BaseSourceHandler, Module from gpm.loader
import getExtension, equal from environment.path
import STATE_PENDING from environment.Promise
import NormalizeGamePath from file

do

    import IsBinaryModuleInstalled from environment.util
    import require from _G

    class BinarySourceHandler extends BaseSourceHandler
        Install: async ( url ) =>
            name = url.pathname
            if not name or name == ""
                error SourceError "Binary module name is not specified!"
                return

            unless IsBinaryModuleInstalled( name )
                error SourceError "Binary module " .. name .. " is not installed locally!"
                return

            require( name )
            return _G[ name ]

    class BinarySource extends BaseSource

    BinarySource( "dll" )\RegisterHandler( BinarySourceHandler! )

do

    import MountGMA from file
    import sub from environment.string
    import MD5 from environment.util
    import time from environment.os

    class GMAHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            return getExtension( url.pathname ) == "gma"

        Install: async ( url ) =>
            gma = Addon!
            gma\Read( url.pathname, true, true )

            :files = gma
            for index = 1, #files
                data = files[ index ]

                filePath = data.path
                if find( filePath, "/lua/packages/", 1, true ) ~= nil
                    data.path = gsub( filePath, "/lua/packages/", "/lua/gpm/vfs/packages/" )

            filePath = "/data/" .. MD5( url.href .. time! )
            gma\Write( filePath )

            ok, result = MountGMA( filePath )
            if ok
                return result

            error MountError result
            return nil

    local ZIPHandler
    do

        import MountZIP from file

        promises = {}

        mountZip = ( filePath ) ->
            promise = promises[ filePath ]
            if promise and promise.state == STATE_PENDING
                return promise

            filePath, gamePath = NormalizeGamePath( filePath, gamePath )
            promise = MountZIP( filePath, gamePath, true )
            promises[ filePath ] = promise
            return promise

        class ZIPHandler extends BaseSourceHandler
            ShouldHandle: ( url ) =>
                return getExtension( url.pathname ) == "zip"

            Install: async ( url ) =>
                return await mountZip( url.pathname )

    local LuaHandler
    do

        import Compile from file

        promises = {}

        compile = ( filePath, handleError, yueConfig ) ->
            promise = promises[ filePath ]
            if promise and promise.state == STATE_PENDING
                return promise

            filePath, gamePath = NormalizeGamePath( filePath, gamePath )
            promise = Compile( filePath, gamePath, handleError, yueConfig, true )
            promises[ filePath ] = promise
            return promise

        class LuaHandler extends BaseSourceHandler
            ShouldHandle: ( url ) =>
                return equal( sub( url.pathname, 1, 5 ), "/lua/" )

            FetchInfo: ( url ) =>
                yueConfig = {}
                for key, value in url.searchParams\iterator!
                    yueConfig[ key ] = value

                return await compile( url.pathname, true, yueConfig )

            Install: async ( url, func, _, env ) =>
                if func
                    return Module.run( func, url, env )

                error ModuleError "File '" .. url.pathname .. "' cannot be compiled."
                return

    class FileSource extends BaseSource

    fs = FileSource( "file" )
    fs\RegisterHandler( LuaHandler! )
    fs\RegisterHandler( ZIPHandler! )
    fs\RegisterHandler( GMAHandler! )
