_G = _G
import gpm from _G
import environment from gpm
import file, path, async, await, SourceError, error from environment
import BaseSource, BaseSourceHandler, Module from gpm.loader
import STATE_PENDING from environment.Promise
import getExtension, equal from path
import NormalizeGamePath from file

do

    import IsBinaryModuleInstalled from environment.util
    import require from _G

    binnaries = {}

    class BinarySourceHandler extends BaseSourceHandler
        Install: async ( url ) =>
            name = url.pathname
            if not name or name == ""
                error SourceError "Binary module name is not specified!"
                return nil

            if binnaries[ name ]
                return _G[ name ]

            if IsBinaryModuleInstalled( name )
                binnaries[ name ] = true
                require( name )
                return name

            error SourceError "Binary module " .. name .. " is not installed locally!"
            return nil

        Run: async ( url, name ) =>
            return _G[ name ]

    class BinarySource extends BaseSource

    BinarySource( "dll" )\RegisterHandler( BinarySourceHandler! )

do

    import MountGMA from file

    class GMAHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            return getExtension( url.pathname, false ) == "gma"

        Run: async ( url ) =>
            return MountGMA( url.pathname )

    local ZIPHandler
    do

        import MountZIP from file

        promises = {}

        task = ( filePath ) ->
            promise = promises[ filePath ]
            if promise and promise.state == STATE_PENDING
                return promise

            filePath, gamePath = NormalizeGamePath( filePath, gamePath )
            promise = MountZIP( filePath, gamePath, true )
            promises[ filePath ] = promise
            return promise

        class ZIPHandler extends BaseSourceHandler
            ShouldHandle: ( url ) =>
                return getExtension( url.pathname, false ) == "zip"

            Install: async ( url ) =>
                return task( url.pathname )

    local LuaHandler
    do

        import AsyncCompile from file
        import sub from _G.string

        promises = {}

        codeCompile = async ( url ) ->
            config = {}
            for key, value in url.searchParams\iterator!
                config[ key ] = value

            filePath, gamePath = NormalizeGamePath( url.pathname )
            compileResult = await AsyncCompile( filePath, nil, config, gamePath, true )
            await Module.cache( "file://" .. compileResult.path, compileResult.content )
            return compileResult.func

        task = ( url ) ->
            promise = promises[ url.href ]
            if promise and promise.state == STATE_PENDING
                return promise

            promise = codeCompile( url )
            promises[ url.href ] = promise
            return promise

        class LuaHandler extends BaseSourceHandler
            ShouldHandle: ( url ) =>
                return equal( sub( url.pathname, 1, 5 ), "/lua/" )

            Install: async ( url, _, __, env ) =>
                return Module.run( await( task( url ) ), url, env )

    class FileSource extends BaseSource

    fs = FileSource( "file" )
    fs\RegisterHandler( LuaHandler! )
    fs\RegisterHandler( ZIPHandler! )
    fs\RegisterHandler( GMAHandler! )
