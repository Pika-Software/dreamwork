import gpm from _G
import environment, loader from gpm
import BaseSource, BaseSourceHandler, SetFileEnvironment from loader
import GetExtensionFromFilename from environment.string
import await, async, util from environment
import Fetch from environment.http

--[[

    Concept:

    download and compile
    http://domain.com/path/to/file.lua
    https://domain.com/path/to/other/file.lua

    http://domain.com/path/to/file.moon
    https://domain.com/path/to/file.yue

    will return a table of decoded json because yeeeep ( will create error if json is invalid )
    http://domain.com/path/to/file.json

    will return a string ( file content )
    http://domain.com/path/to/file.txt

    will just download, and the next step is to mount the gma with data://gpm/downloads/{md5_url_hash}.gma
    https://domain.com/path/to/file.gma

    download the zip file, create a new gma into data://gpm/downloads/{md5_url_hash}.gma, then mount it.
    http://domain.com/path/to/file.zip

    download the default or specified brunch and mount it as a gma to the game just like a zip.
    https://github.com/pika-software/gm_moonloader

    github://pika-software/gm_moonloader/?/path/to/file ->
        https://api.github.com/repos/pika-software/gm_moonloader ( default_branch ) ->
            https://api.github.com/repos/pika-software/gm_moonloader/git/trees/{default_branch} ->

]]

local LuaCodeHandler
do

    import CompileLuaString, CompileMoonString, CompileYueString from util

    extensions = {
        "lua": true
        "moon": true
        "yue": true
    }

    class LuaCodeHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            url.extension or= GetExtensionFromFilename( url.pathname ) or "txt"
            return extensions[ url.extension ]

        FetchInfo: async ( url ) =>
            result = await Fetch( url.href )
            if result.code ~= 200
                error "failed to fetch " .. url.href

            return result.body

        Install: async ( url, luaCode, _, parentPackage, parentEnvironment ) =>
            func = await switch url.extension
                when "lua"
                    util.CompileLuaString( luaCode, url.href )

                when "moon"
                    util.CompileMoonString( luaCode, url.href )

                when "yue"
                    util.CompileYueString( luaCode, url.href )

            unless func
                error ModuleLoadError "File '" .. filePath .. "' cannot be compiled."
                return

            SetFileEnvironment( func, url.href, parentPackage, parentEnvironment )
            return func!

class TextHandler extends BaseSourceHandler
    ShouldHandle: ( url ) =>
        url.extension or= GetExtensionFromFilename( url.pathname ) or "txt"
        return url.extension == "txt"

    FetchInfo: async ( url ) =>
        result = await Fetch( url.href )
        if result.code ~= 200
            error "failed to fetch " .. url.href

        return result.body

    Install: async ( url, text ) =>
        return text

local JSONHandler
do

    import JSONToTable from util

    class JSONHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            url.extension or= GetExtensionFromFilename( url.pathname ) or "txt"
            return url.extension == "json"

        FetchInfo: async ( url ) =>
            result = await Fetch( url.href )
            if result.code ~= 200
                error "failed to fetch " .. url.href

            return result.body

        Install: async ( url, json ) =>
            tbl = JSONToTable( json, true, false )
            if tbl
                return tbl

            error "failed to decode json"
            return

class WebSource extends BaseSource

ws = WebSource( "http", "https" )
ws\RegisterHandler( LuaCodeHandler! )
ws\RegisterHandler( TextHandler! )
ws\RegisterHandler( JSONHandler! )
