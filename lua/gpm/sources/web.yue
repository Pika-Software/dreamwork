import gpm, pairs from _G
import environment from gpm
import await, async, string, file, util, ModuleLoadError, SourceError from environment

import AsyncImport, BaseSource, BaseSourceHandler from gpm.loader
import AsyncWrite, MountZIPData from file
import Module from environment.package
import Fetch from environment.http
import MD5 from util
import time from os

file.Delete( "gpm/downloads" )
file.CreateDir( "gpm/downloads" )

local getExtension
do

    import GetExtensionFromFilename from string

    getExtension = ( url ) ->
        extension = url.extension
        unless extension
            extension = url.extension = GetExtensionFromFilename( url.pathname ) or ""

        return extension

local LuaCodeHandler
do

    import CompileLuaString, CompileMoonString, CompileYueString from util

    extensions = {
        "moon": true
        "yue": true
        "lua": true
    }

    class LuaCodeHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            return extensions[ getExtension( url ) ]

        FetchInfo: async ( url ) =>
            result = await Fetch( url.href )
            if result.status ~= 200
                error SourceError "failed to fetch " .. url.href

            return result.body

        Install: async ( url, luaCode, _, __, parentEnvironment ) =>
            func = await switch url.extension
                when "lua"
                    CompileLuaString( luaCode, url.href, true )

                when "moon"
                    CompileMoonString( luaCode, url.href, true )

                when "yue"
                    yueConfig = {}
                    for key, value in url.searchParams\iterator!
                        yueConfig[ key ] = value

                    CompileYueString( luaCode, url.href, true, yueConfig )

            unless func
                error ModuleLoadError "File '" .. url.href .. "' cannot be compiled."
                return

            Module( func, url, parentEnvironment )
            return func!

class TextHandler extends BaseSourceHandler
    ShouldHandle: ( url ) =>
        return getExtension( url ) == "txt"

    FetchInfo: async ( url ) =>
        return url.href

    Install: async ( url, href ) =>
        result = await Fetch( href )
        if result.status ~= 200
            error SourceError "failed to fetch " .. href

        return result.body

local JSONHandler
do

    import JSONToTable from util

    class JSONHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            return getExtension( url ) == "json"

        FetchInfo: async ( url ) =>
            result = await Fetch( url.href )
            if result.status ~= 200
                error SourceError "failed to fetch " .. url.href

            return result.body

        Install: async ( url, json ) =>
            tbl = JSONToTable( json, true, false )
            if tbl
                return tbl

            error SourceError "failed to parse json"
            return

class GMAHandler extends BaseSourceHandler
    ShouldHandle: ( url ) =>
        return getExtension( url ) == "gma"

    FetchInfo: async ( url ) =>
        result = await Fetch( url.href )
        if result.status ~= 200
            error SourceError "failed to fetch " .. url.href

        return AsyncWrite( "gpm/downloads/" .. MD5( url.href .. time! ) .. ".gma", result.body )

    Install: async ( url, data ) =>
        return AsyncImport( "file://data/" .. data.fileName )

class ZIPHandler extends BaseSourceHandler
    ShouldHandle: ( url ) =>
        return getExtension( url ) == "zip"

    FetchInfo: async ( url ) =>
        result = await Fetch( url.href )
        if result.status ~= 200
            error SourceError "failed to fetch " .. url.href

        return result.body

    Install: async ( url, data ) =>
        return MountZIPData( data, url.href )

class WebSource extends BaseSource

ws = WebSource( "http", "https" )
ws\RegisterHandler( LuaCodeHandler! )
ws\RegisterHandler( TextHandler! )
ws\RegisterHandler( JSONHandler! )
ws\RegisterHandler( GMAHandler! )
ws\RegisterHandler( ZIPHandler! )
