import gpm, pairs from _G
import environment, loader, Module from gpm
import BaseSource, BaseSourceHandler from loader
import GetExtensionFromFilename from environment.string
import await, async, file, util from environment
import Fetch from environment.http
import AsyncWrite from file
import MD5 from util
import time from os

--[[

    Concept:

    download and compile
    http://domain.com/path/to/file.lua
    https://domain.com/path/to/other/file.lua

    http://domain.com/path/to/file.moon
    https://domain.com/path/to/file.yue

    will return a table of decoded json because yeeeep ( will create error if json is invalid )
    http://domain.com/path/to/file.json

    will return a string ( file content )
    http://domain.com/path/to/file.txt

    will just download, and the next step is to mount the gma with data://gpm/mount/{md5_url_hash}.gma
    https://domain.com/path/to/file.gma

    download the zip file, create a new gma into data://gpm/mount/{md5_url_hash}.gma, then mount it.
    http://domain.com/path/to/file.zip

    download the default or specified brunch and mount it as a gma to the game just like a zip.
    https://github.com/pika-software/gm_moonloader

    github://pika-software/gm_moonloader/?/path/to/file ->
        https://api.github.com/repos/pika-software/gm_moonloader ( default_branch ) ->
            https://api.github.com/repos/pika-software/gm_moonloader/git/trees/{default_branch} ->

]]

file.CreateDir( "gpm/mount" )

local LuaCodeHandler
do

    import CompileLuaString, CompileMoonString, CompileYueString from util

    extensions = {
        "lua": true
        "moon": true
        "yue": true
    }

    class LuaCodeHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            url.extension or= GetExtensionFromFilename( url.pathname ) or "txt"
            return extensions[ url.extension ]

        FetchInfo: async ( url ) =>
            result = await Fetch( url.href )
            if result.code ~= 200
                error "failed to fetch " .. url.href

            return result.body

        Install: async ( url, luaCode, _, parentPackage, parentEnvironment ) =>
            func = await switch url.extension
                when "lua"
                    util.CompileLuaString( luaCode, url.href )

                when "moon"
                    util.CompileMoonString( luaCode, url.href )

                when "yue"
                    util.CompileYueString( luaCode, url.href )

            unless func
                error ModuleLoadError "File '" .. filePath .. "' cannot be compiled."
                return

            Module( func, url.href, parentPackage, parentEnvironment )
            return func!

class TextHandler extends BaseSourceHandler
    ShouldHandle: ( url ) =>
        url.extension or= GetExtensionFromFilename( url.pathname ) or "txt"
        return url.extension == "txt"

    FetchInfo: async ( url ) =>
        result = await Fetch( url.href )
        if result.code ~= 200
            error "failed to fetch " .. url.href

        return result.body

    Install: async ( url, text ) =>
        return text

local JSONHandler
do

    import JSONToTable from util

    class JSONHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            url.extension or= GetExtensionFromFilename( url.pathname ) or "txt"
            return url.extension == "json"

        FetchInfo: async ( url ) =>
            result = await Fetch( url.href )
            if result.code ~= 200
                error "failed to fetch " .. url.href

            return result.body

        Install: async ( url, json ) =>
            tbl = JSONToTable( json, true, false )
            if tbl
                return tbl

            error "failed to parse json"
            return

local GMAHandler
do

    class GMAHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            url.extension or= GetExtensionFromFilename( url.pathname ) or "txt"
            return url.extension == "gma"

        FetchInfo: async ( url ) =>
            result = await Fetch( url.href )
            if result.code ~= 200
                error "failed to fetch " .. url.href

            return await AsyncWrite( "gpm/mount/" .. MD5( url.href .. time! ) .. ".gma", result.body )

        Install: async ( url, data ) =>
            ok, result = file.MountGMA( "data/" .. data.fileName )
            if ok
                return result

            error result
            return

local ZIPHandler
do

    import GMAD, IsFilePathAllowed from environment.addon
    import IterateZipFiles from file
    import match, sub from string
    import ByteStream from util

    class ZIPHandler extends BaseSourceHandler
        ShouldHandle: ( url ) =>
            url.extension or= GetExtensionFromFilename( url.pathname ) or "txt"
            return url.extension == "zip"

        FetchInfo: async ( url ) =>
            result = await Fetch( url.href )
            if result.code ~= 200
                error "failed to fetch " .. url.href

            return result.body

        Install: async ( url, data ) =>
            gma = GMAD!

            local isInFolder, last
            temp = {}

            for fileName, data in IterateZipFiles( ByteStream( data ) )
                temp[ fileName ] = data

                if isInFolder ~= false
                    current = match( fileName, "^(.-)/" )
                    if last
                        isInFolder = last == current

                    last = current

            files = temp
            if isInFolder
                files = {}
                endPos = #last + 2
                for fileName, data in pairs( temp )
                    files[ sub( fileName, endPos ) ] = data

            for fileName, data in pairs( files )
                if IsFilePathAllowed( fileName )
                    gma\AddFile( fileName, data )

            bs = ByteStream!
            gma\SetTitle( MD5( url.href .. time! ) )
            gma\Write( bs, nil, false )

            filePath = "gpm/mount/" .. gma\GetTitle! .. ".gma"
            await AsyncWrite( filePath, bs.Data )

            ok, result = file.MountGMA( "data/" .. filePath )
            if ok
                return result

            error result
            return

class WebSource extends BaseSource

ws = WebSource( "http", "https" )
ws\RegisterHandler( LuaCodeHandler! )
ws\RegisterHandler( TextHandler! )
ws\RegisterHandler( JSONHandler! )
ws\RegisterHandler( GMAHandler! )
ws\RegisterHandler( ZIPHandler! )
