:Promise, :Error = gpm
:async, :await = Promise

class SourceError extends Error
class PackageParseError extends Error

sources = {}
class Source
    Register: (protocol, src) =>
        sources[protocol] = src

    @FindSourceByURL: (url) ->
        protocol = string.match url, "^(.-)://"
        return protocol and sources[protocol]

    @FetchInfo: (url) ->
        src = Source.FindSourceByURL url
        unless src then error SourceError "unknown protocol: " .. protocol
        unless src.Download then error SourceError "#{src.__name} doesn't support FetchInfo method"
        return src\FetchInfo url

    @Download: (url, info) ->
        src = Source.FindSourceByURL url
        unless src then error SourceError "unknown protocol: " .. protocol
        unless src.Download then error SourceError "#{src.__name} doesn't support Download method"
        return src\Download url, info

    -- more methods?

class LocalSource extends Source
    FetchInfo: async (url) =>
        dir = string.gsub url, "lua://", ""
        package_info_path = dir .. "package.lua" -- path.join here

        env = {}
        env.dir = dir -- We are assigning here, so package.lua can define custom directory

        func = CompileFile package_info_path
        unless func then error SourceError "Failed to compile package info file: " .. package_info_path

        await Promise.delay 1

        setfenv func, env
        unless success, reason = try func!
            error SourceError reason

        return env

    Download: async (url, info) => -- what should i do here?

-- Registering local source!
Source\Register "lua", LocalSource

--[[

    http://github.com/pika/repository
        |
        |
    HTTP Source
        |
    ( github.com )
        |
    github://pika/repository
        |
    GitHub Source
        |
    https://github.com/pika/repository/archive/refs/heads/master.zip
        |
        |
    HTTP Source
        |
        |
    Downloading `zip` type ( master.zip )
        |
        |
    HTTP Source ( zip type )
        |
        |
    Creating and writing GMA in DATA
        |
        |
    FileSystem Source ( file://data/master.gma )
        |
        |
    Type GMA ( master.gma )
        |
        |
    Mounting GMA to game ( `table` with lua and other ( material, sound, models ) files )
        |
        |
    Filesystem type LUA
        |
        |
    Package

--]]


--[[

    FileSystem

    Source.Types = { "gma", "lua", "module", "zip", "package" }

    Source.Handler = ( typeName, filePath, ... ) ->
        if typeName == "package"
            typeName = "lua"
            filePath = "packages/" .. filePath .. ".lua"

        return Source.TypeImport( typeName, filePath, ... )

    require( "package://my_pkg" )


]]

once = (field, fn) ->
    (...) =>
        if @[field] then return @[field]
        @[field] = fn @, ...
        return @[field]

class Package
    new: (@url) =>

    GetID: =>
        if @name
            return "#{@name}@#{@version or "unknown"}"
        return tostring @url

    __tostring: =>
        return "Package #{@GetID!}"

    GetInfo: once "info", async =>
        pkg_info = await Source.FetchInfo @url
        unless istable pkg_info
            error PackageParseError "source hasn't found a package info"

        info = {}
        info.name = pkg_info.name
        unless isstring info.name
            error PackageParseError "`name` must be a string"

        info.dir = pkg_info.dir
        unless isstring info.dir
            error PackageParseError "package directory hasn't been found"

        info.init = pkg_info.init or "init.lua"
        unless isstring info.init
            error PackageParseError "`init` must be a string"

        -- Parse other fields

        @name = info.name
        @version = info.version or "0.0.0"

        return info

    GetResult: once "result", async =>
        info = await @GetInfo!
        await Source.Download @url, info

        entry = info.dir .. info.init -- path.join here
        entry_fn = CompileFile entry
        unless entry_fn
            error SourceError "Failed to compile package entry file: " .. entry

        -- setup env here

        entry_fn = async entry_fn -- making it asynchronous
        return entry_fn!


main = async ->
    pkg = Package "lua://packages/package_v2/"

    print "--- #{CurTime!} ---"
    print "Getting package info..."
    info = await pkg\GetInfo!

    print "Loading package `#{info.name}`..."
    result = await pkg\GetResult!
    print "Result is #{result}"
    print "#{pkg} has been loaded"
    print "--- #{CurTime!} ---"


main!\Catch (err)->
    ErrorNoHaltWithStack err
