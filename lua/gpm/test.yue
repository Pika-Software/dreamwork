import Promise, Error, debug from gpm
import async, await from Promise

-- class SourceError extends Error
-- class PackageParseError extends Error

-- sources = {}
-- class Source
--     Register: (protocol, src) =>
--         sources[protocol] = src

--     @FindSourceByURL: (url) ->
--         protocol = string.match url, "^(.-)://"
--         return protocol and sources[protocol]

--     @FetchInfo: (url) ->
--         src = Source.FindSourceByURL url
--         unless src then error SourceError "unknown protocol: " .. protocol
--         unless src.Download then error SourceError "#{src.__name} doesn't support FetchInfo method"
--         return src\FetchInfo url

--     @Download: (url, info) ->
--         src = Source.FindSourceByURL url
--         unless src then error SourceError "unknown protocol: " .. protocol
--         unless src.Download then error SourceError "#{src.__name} doesn't support Download method"
--         return src\Download url, info

--     -- more methods?

-- class LocalSource extends Source
--     FetchInfo: async (url) =>
--         dir = string.gsub url, "lua://", ""
--         package_info_path = dir .. "package.lua" -- path.join here

--         env = {}
--         env.dir = dir -- We are assigning here, so package.lua can define custom directory

--         func = CompileFile package_info_path
--         unless func then error SourceError "Failed to compile package info file: " .. package_info_path

--         await Promise.delay 1

--         setfenv func, env
--         unless success, reason := try func!
--             error SourceError reason

--         return env

--     Download: async (url, info) => -- what should i do here?

-- -- Registering local source!
-- Source\Register "lua", LocalSource

--[[

    http://github.com/pika/repository
        |
        |
    HTTP Source
        |
    ( github.com )
        |
    github://pika/repository
        |
    GitHub Source
        |
    https://github.com/pika/repository/archive/refs/heads/master.zip
        |
        |
    HTTP Source
        |
        |
    Downloading `zip` type ( master.zip )
        |
        |
    HTTP Source ( zip type )
        |
        |
    Creating and writing GMA in DATA
        |
        |
    FileSystem Source ( file://data/master.gma )
        |
        |
    Type GMA ( master.gma )
        |
        |
    Mounting GMA to game ( `table` with lua and other ( material, sound, models ) files )
        |
        |
    Filesystem type LUA
        |
        |
    Package

--]]


--[[

    FileSystem

    Source.Types = { "gma", "lua", "module", "zip", "package" }

    Source.Handler = ( typeName, filePath, ... ) ->
        if typeName == "package"
            typeName = "lua"
            filePath = "packages/" .. filePath .. ".lua"

        return Source.TypeImport( typeName, filePath, ... )

    require( "package://my_pkg" )


]]

-- once = (field, fn) ->
--     (...) =>
--         if @[field] then return @[field]
--         @[field] = fn @, ...
--         return @[field]

-- class Package
--     new: (@url) =>

--     GetID: =>
--         if @name
--             return "#{@name}@#{@version or "unknown"}"
--         return tostring @url

--     __tostring: =>
--         return "Package #{@GetID!}"

--     GetInfo: once "info", async =>
--         pkg_info = await Source.FetchInfo @url
--         unless istable pkg_info
--             error PackageParseError "source hasn't found a package info"

--         info = {}
--         info.name = pkg_info.name
--         unless isstring info.name
--             error PackageParseError "`name` must be a string"

--         info.dir = pkg_info.dir
--         unless isstring info.dir
--             error PackageParseError "package directory hasn't been found"

--         info.init = pkg_info.init or "init.lua"
--         unless isstring info.init
--             error PackageParseError "`init` must be a string"

--         -- Parse other fields

--         @name = info.name
--         @version = info.version or "0.0.0"

--         return info

--     GetResult: once "result", async =>
--         info = await @GetInfo!
--         await Source.Download @url, info

--         entry = info.dir .. info.init -- path.join here
--         entry_fn = CompileFile entry
--         unless entry_fn
--             error SourceError "Failed to compile package entry file: " .. entry

--         -- setup env here

--         entry_fn = async entry_fn -- making it asynchronous
--         return entry_fn!

concommand.Add "gpm_test", ->
    include( "gpm/test.lua" )

getPackages = () ->
    pkgs = {}
    local files, folders = file.Find "packages/*", "LUA"
    for folder in *folders
        pkgs[] = gpm.ParsePackage gpm.path.Join "packages", folder, "package.lua"
    return pkgs

import format from string
SysTime = SysTime

bench = (name, fn) ->
    iter = 1000000
    st = SysTime!

    for i = 1, iter
        fn!

    st = SysTime! - st
    print format( "%s time: %f sec.", name, st )

main = async ->
    GLuaTest.runAllTests!
    -- gpm.Import "package_v2"
    -- specifier = "b"
    -- print "=== Loading `#{specifier}` #{CurTime()} ==="

    -- entry = await gpm.loader.Resolve specifier
    -- print "Entry is #{entry} (#{entry and debug.getfpathi(entry) or "???"})"
    -- if entry
    --     print "return:", await entry!

    -- pkgs = getPackages!
    -- for pkg in *pkgs
    --     gpm.Logger\Info "Loading package `#{pkg}`..."
    --     gpm.Import "lua://" .. pkg.dir .. pkg.entry

    return
    -- print "fetching info..."
    -- info = await gpm.FetchInfo "package_v2"
    -- print "info: #{info}"
    -- if istable info then PrintTable info
    -- pkg = Package "lua://packages/package_v2/"

    -- print "--- #{CurTime!} ---"
    -- print "Getting package info..."
    -- info = await pkg\GetInfo!

    -- print "Loading package `#{info.name}`..."
    -- result = await pkg\GetResult!
    -- print "Result is #{result}"
    -- print "#{pkg} has been loaded"
    -- print "--- #{CurTime!} ---"

main!\Catch (err)->
    try Error.display err
    catch err
        ErrorNoHaltWithStack err
        return
    return
